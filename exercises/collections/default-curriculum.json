{
  "id": "default-curriculum",
  "name": "Default Curriculum",
  "description": "The standard learning path from basics to advanced",
  "isDefault": true,
  "exerciseIds": [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    384,
    385,
    386,
    387,
    388,
    389,
    390,
    391,
    392,
    393,
    394,
    395,
    396,
    397,
    398,
    399,
    400,
    401,
    402,
    403,
    404,
    405,
    406,
    620,
    621,
    622,
    623,
    624,
    630,
    631,
    632,
    634,
    635,
    637,
    638,
    639,
    643,
    644,
    645,
    646,
    647,
    652,
    653,
    654,
    655,
    658,
    660,
    662,
    663,
    664,
    665,
    671,
    674,
    675,
    676,
    677,
    680,
    681,
    682,
    683,
    684,
    685,
    686,
    687,
    689,
    690,
    693,
    694,
    695,
    696,
    700,
    701,
    702,
    703,
    707,
    708,
    709,
    711,
    712,
    713,
    714,
    715,
    716,
    717,
    718,
    719,
    721,
    722,
    723,
    724,
    725,
    726,
    727,
    728,
    731,
    732,
    733,
    734,
    735,
    736,
    737,
    741,
    742,
    743,
    744,
    746,
    747,
    748,
    751,
    753,
    755,
    757
  ],
  "exercises": [
    {
      "id": 1,
      "title": "Hello, Variables",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "variables",
        "strings",
        "concatenation",
        "beginner"
      ],
      "description": "Create a function that returns a greeting string using the provided name.",
      "instructions": "Write a function called `greet` that takes a `name` parameter and returns the string \"Hello, [name]!\" where [name] is replaced with the argument.\n\nExample:\n  greet(\"Alex\")  →  \"Hello, Alex!\"\n  greet(\"World\") →  \"Hello, World!\"",
      "starterCode": "function greet(name) {\n  // Your code here\n\n}",
      "solution": "function greet(name) {\n  return \"Hello, \" + name + \"!\";\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return greet;')(); return [ { pass: fn('Alex') === 'Hello, Alex!', description: 'greet(\"Alex\") → \"Hello, Alex!\"', got: fn('Alex') }, { pass: fn('World') === 'Hello, World!', description: 'greet(\"World\") → \"Hello, World!\"', got: fn('World') }, { pass: fn('') === 'Hello, !', description: 'greet(\"\") → \"Hello, !\"', got: fn('') } ]; }",
      "hint": "The return keyword sends a value back from a function. To build a greeting, you need to combine a fixed string with the name parameter.",
      "resources": [
        {
          "label": "MDN: Functions",
          "url": "/docs/mdn/functions.html",
          "description": "How functions work, including return values"
        },
        {
          "label": "MDN: String concatenation",
          "url": "/docs/mdn/string-concat.html",
          "description": "Combining strings with + or template literals"
        }
      ],
      "hints": [
        "How do you combine a fixed string like \"Hello, \" with a variable name to produce the final greeting?",
        "The return keyword sends a value back from a function. To build a greeting, you need to combine a fixed string with the name parameter.",
        "The function should return a string."
      ]
    },
    {
      "id": 2,
      "title": "Even or Odd",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "modulo",
        "conditionals",
        "operators",
        "beginner"
      ],
      "description": "Use the modulo operator to determine if a number is even or odd.",
      "instructions": "Write a function called `evenOrOdd` that takes a number and returns \"even\" if even, or \"odd\" if odd.\n\nExample:\n  evenOrOdd(4) →  \"even\"\n  evenOrOdd(7) →  \"odd\"\n  evenOrOdd(0) →  \"even\"",
      "starterCode": "function evenOrOdd(num) {\n  // Your code here\n\n}",
      "solution": "function evenOrOdd(num) {\n  return num % 2 === 0 ? \"even\" : \"odd\";\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return evenOrOdd;')(); return [ { pass: fn(4) === 'even', description: 'evenOrOdd(4) → \"even\"', got: fn(4) }, { pass: fn(7) === 'odd', description: 'evenOrOdd(7) → \"odd\"', got: fn(7) }, { pass: fn(0) === 'even', description: 'evenOrOdd(0) → \"even\"', got: fn(0) }, { pass: fn(-3) === 'odd', description: 'evenOrOdd(-3) → \"odd\"', got: fn(-3) } ]; }",
      "hint": "The modulo operator (%) gives you the remainder after division. What is the remainder when you divide an even number by 2?",
      "resources": [
        {
          "label": "MDN: Arithmetic operators",
          "url": "/docs/mdn/arithmetic.html",
          "description": "All math operators including modulo (%)"
        },
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "A shorthand for if/else"
        }
      ],
      "hints": [
        "What does the remainder operator (%) give you when you divide a number by 2, and how does that differ for odd vs. even?",
        "The modulo operator (%) gives you the remainder after division. What is the remainder when you divide an even number by 2?",
        "Break the problem into smaller steps and handle edge cases."
      ]
    },
    {
      "id": 3,
      "title": "Sum of Array",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "loops",
        "accumulator",
        "beginner"
      ],
      "description": "Calculate the sum of all numbers in an array using a loop.",
      "instructions": "Write a function called `sumArray` that takes an array of numbers and returns their sum. Return 0 for empty arrays.\n\nExample:\n  sumArray([1, 2, 3])    →  6\n  sumArray([10, -5, 3])  →  8\n  sumArray([])            →  0",
      "starterCode": "function sumArray(arr) {\n  // Your code here\n\n}",
      "solution": "function sumArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return sumArray;')(); return [ { pass: fn([1,2,3]) === 6, description: 'sumArray([1,2,3]) → 6', got: fn([1,2,3]) }, { pass: fn([10,-5,3]) === 8, description: 'sumArray([10,-5,3]) → 8', got: fn([10,-5,3]) }, { pass: fn([]) === 0, description: 'sumArray([]) → 0', got: fn([]) }, { pass: fn([100]) === 100, description: 'sumArray([100]) → 100', got: fn([100]) } ]; }",
      "hint": "You need to visit every element in the array and keep a running total. A for loop with an accumulator variable is one approach. There is also a built-in array method that does exactly this.",
      "resources": [
        {
          "label": "MDN: for loop",
          "url": "/docs/mdn/for-loop.html",
          "description": "Iterating through arrays with for"
        },
        {
          "label": "MDN: Array.reduce()",
          "url": "/docs/mdn/array-reduce.html",
          "description": "Reducing an array to a single value"
        }
      ],
      "hints": [
        "You need a single total from many numbers — do you reach for a loop with a running total, or is there a built-in method that accumulates values?",
        "You need to visit every element in the array and keep a running total. A for loop with an accumulator variable is one approach. There is also a built-in array method that does exactly this.",
        "Use a loop to iterate, then return the accumulated result. The function should return a number."
      ]
    },
    {
      "id": 4,
      "title": "Reverse a String",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "arrays",
        "methods",
        "beginner"
      ],
      "description": "Reverse the characters in a string.",
      "instructions": "Write a function called `reverseString` that takes a string and returns it reversed.\n\nExample:\n  reverseString(\"hello\")      →  \"olleh\"\n  reverseString(\"JavaScript\") →  \"tpircSavaJ\"",
      "starterCode": "function reverseString(str) {\n  // Your code here\n\n}",
      "solution": "function reverseString(str) {\n  return str.split(\"\").reverse().join(\"\");\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return reverseString;')(); return [ { pass: fn('hello') === 'olleh', description: 'reverseString(\"hello\") → \"olleh\"', got: fn('hello') }, { pass: fn('JavaScript') === 'tpircSavaJ', description: 'reverseString(\"JavaScript\") → \"tpircSavaJ\"', got: fn('JavaScript') }, { pass: fn('') === '', description: 'reverseString(\"\") → \"\"', got: fn('') } ]; }",
      "hint": "A string can be split into an array of individual characters. Arrays have a method that reverses their order. And arrays can be joined back into a string.",
      "resources": [
        {
          "label": "MDN: String.split()",
          "url": "/docs/mdn/string-split.html",
          "description": "Breaking a string into an array"
        },
        {
          "label": "MDN: Array.reverse()",
          "url": "/docs/mdn/array-reverse.html",
          "description": "Reversing array element order"
        },
        {
          "label": "MDN: Array.join()",
          "url": "/docs/mdn/array-join.html",
          "description": "Combining array elements into a string"
        }
      ],
      "hints": [
        "What happens if you split a string into an array of characters, reverse the array, and join it back?",
        "A string can be split into an array of individual characters. Arrays have a method that reverses their order. And arrays can be joined back into a string.",
        "Key method(s): `split`, `reverse`, `join`. The function should return a string."
      ]
    },
    {
      "id": 5,
      "title": "Property Counter",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "objects",
        "Object.keys",
        "beginner"
      ],
      "description": "Count the number of properties in an object.",
      "instructions": "Write a function called `countProps` that takes an object and returns the number of its own properties.\n\nExample:\n  countProps({ a: 1, b: 2 })  →  2\n  countProps({})               →  0",
      "starterCode": "function countProps(obj) {\n  // Your code here\n\n}",
      "solution": "function countProps(obj) {\n  return Object.keys(obj).length;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countProps;')(); return [ { pass: fn({a:1,b:2}) === 2, description: 'countProps({a:1,b:2}) → 2', got: fn({a:1,b:2}) }, { pass: fn({}) === 0, description: 'countProps({}) → 0', got: fn({}) }, { pass: fn({x:1,y:2,z:3}) === 3, description: 'countProps 3 props → 3', got: fn({x:1,y:2,z:3}) } ]; }",
      "hint": "Object.keys() gives you an array of all property names in an object. The length of that array tells you something useful.",
      "resources": [
        {
          "label": "MDN: Object.keys()",
          "url": "/docs/mdn/object-keys.html",
          "description": "Getting all property names from an object"
        },
        {
          "label": "MDN: Working with objects",
          "url": "/docs/mdn/objects.html",
          "description": "Creating and accessing object properties"
        }
      ],
      "hints": [
        "The `keys` method will be helpful here.",
        "Object.keys() gives you an array of all property names in an object. The length of that array tells you something useful.",
        "Key method(s): `keys`, `Object.keys`."
      ]
    },
    {
      "id": 6,
      "title": "Filter the Evens",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "filter",
        "modulo",
        "prototype-methods",
        "intermediate"
      ],
      "description": "Use .filter() to extract even numbers from an array.",
      "instructions": "Write a function called `getEvens` that takes an array of numbers and returns only the even numbers. Use .filter().\n\nExample:\n  getEvens([1,2,3,4,5,6])  →  [2,4,6]\n  getEvens([1,3,5])         →  []",
      "starterCode": "function getEvens(arr) {\n  // Use .filter()\n\n}",
      "solution": "function getEvens(arr) {\n  return arr.filter(num => num % 2 === 0);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return getEvens;')(); return [ { pass: JSON.stringify(fn([1,2,3,4,5,6])) === '[2,4,6]', description: 'getEvens([1,2,3,4,5,6]) → [2,4,6]', got: JSON.stringify(fn([1,2,3,4,5,6])) }, { pass: JSON.stringify(fn([1,3,5])) === '[]', description: 'getEvens([1,3,5]) → []', got: JSON.stringify(fn([1,3,5])) }, { pass: JSON.stringify(fn([2,4])) === '[2,4]', description: 'getEvens([2,4]) → [2,4]', got: JSON.stringify(fn([2,4])) } ]; }",
      "hint": "Arrays have a built-in method specifically designed to create a new array containing only elements that pass a test. The test is a function you provide that returns true or false for each element.",
      "resources": [
        {
          "label": "MDN: Array.filter()",
          "url": "/docs/mdn/array-filter.html",
          "description": "Creating a subset of an array based on a condition"
        },
        {
          "label": "MDN: Callback functions",
          "url": "/docs/mdn/callbacks.html",
          "description": "Passing functions as arguments"
        }
      ],
      "hints": [
        "Consider how `filter` works.",
        "Arrays have a built-in method specifically designed to create a new array containing only elements that pass a test. The test is a function you provide that returns true or false for each element.",
        "Key method(s): `filter`. Filter elements that match your condition."
      ]
    },
    {
      "id": 7,
      "title": "Transform with Map",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "map",
        "objects",
        "prototype-methods",
        "intermediate"
      ],
      "description": "Use .map() to transform each element in an array.",
      "instructions": "Write `doubleAll` — takes an array of numbers, returns each doubled.\nWrite `getNames` — takes an array of objects with `name`, returns just the names.\n\nExample:\n  doubleAll([1, 2, 3]) → [2, 4, 6]\n  getNames([{name:\"Alex\"}, {name:\"Sam\"}]) → [\"Alex\",\"Sam\"]",
      "starterCode": "function doubleAll(arr) {\n  // Use .map()\n\n}\n\nfunction getNames(people) {\n  // Use .map()\n\n}",
      "solution": "function doubleAll(arr) {\n  return arr.map(num => num * 2);\n}\n\nfunction getNames(people) {\n  return people.map(person => person.name);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return { doubleAll, getNames };')(); return [ { pass: JSON.stringify(fn.doubleAll([1,2,3])) === '[2,4,6]', description: 'doubleAll([1,2,3]) → [2,4,6]', got: JSON.stringify(fn.doubleAll([1,2,3])) }, { pass: JSON.stringify(fn.doubleAll([0,-1,5])) === '[0,-2,10]', description: 'doubleAll([0,-1,5]) → [0,-2,10]', got: JSON.stringify(fn.doubleAll([0,-1,5])) }, { pass: JSON.stringify(fn.getNames([{name:'Alex'},{name:'Sam'}])) === '[\"Alex\",\"Sam\"]', description: 'getNames extracts names', got: JSON.stringify(fn.getNames([{name:'Alex'},{name:'Sam'}])) } ]; }",
      "hint": "There is an array method that creates a new array by transforming every element. You give it a function that receives each element and returns the transformed version.",
      "resources": [
        {
          "label": "MDN: Array.map()",
          "url": "/docs/mdn/array-map.html",
          "description": "Transforming every element in an array"
        },
        {
          "label": "MDN: Arrow functions",
          "url": "/docs/mdn/arrow-functions.html",
          "description": "Compact function syntax for callbacks"
        }
      ],
      "hints": [
        "When you need a new array with each element transformed, which array method runs a function on every element and collects the results?",
        "There is an array method that creates a new array by transforming every element. You give it a function that receives each element and returns the transformed version.",
        "Key method(s): `map`. Map each element to its transformed value. The function should return an array."
      ]
    },
    {
      "id": 8,
      "title": "Reduce to Total",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "reduce",
        "objects",
        "accumulator",
        "prototype-methods",
        "intermediate"
      ],
      "description": "Use .reduce() to accumulate values from an array of objects.",
      "instructions": "Write `totalPrice` that takes an array of objects with `price` and returns the total. Use .reduce().\n\nExample:\n  totalPrice([{price:10},{price:20},{price:5}])  →  35\n  totalPrice([])  →  0",
      "starterCode": "function totalPrice(items) {\n  // Use .reduce()\n\n}",
      "solution": "function totalPrice(items) {\n  return items.reduce((total, item) => total + item.price, 0);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return totalPrice;')(); return [ { pass: fn([{price:10},{price:20},{price:5}]) === 35, description: 'totalPrice → 35', got: fn([{price:10},{price:20},{price:5}]) }, { pass: fn([{price:99.99}]) === 99.99, description: 'single item → 99.99', got: fn([{price:99.99}]) }, { pass: fn([]) === 0, description: 'empty → 0', got: fn([]) } ]; }",
      "hint": "There is an array method that processes all elements and produces a single result. It takes a function with two parameters: the running accumulator and the current element. It also takes a starting value.",
      "resources": [
        {
          "label": "MDN: Array.reduce()",
          "url": "/docs/mdn/array-reduce.html",
          "description": "Reducing an array to a single value"
        },
        {
          "label": "MDN: Array iteration methods",
          "url": "/docs/mdn/array-iteration.html",
          "description": "Overview of map, filter, reduce, and more"
        }
      ],
      "hints": [
        "`reduce` is a key tool for this exercise.",
        "There is an array method that processes all elements and produces a single result. It takes a function with two parameters: the running accumulator and the current element. It also takes a starting value.",
        "Key method(s): `reduce`. The accumulator should track the running result through each iteration."
      ]
    },
    {
      "id": 9,
      "title": "Closure Counter",
      "type": "js",
      "tier": 3,
      "category": [
        "functions",
        "scope"
      ],
      "tags": [
        "closure",
        "scope",
        "functions",
        "intermediate"
      ],
      "description": "Build a counter factory using closures.",
      "instructions": "Write a function `makeCounter` that returns a function. Each time the returned function is called, it returns the next integer starting from 0.\n\nExample:\n  const count = makeCounter();\n  count() → 0\n  count() → 1\n  count() → 2",
      "starterCode": "function makeCounter() {\n  // Return a function that increments and returns a count\n\n}",
      "solution": "function makeCounter() {\n  let count = 0;\n  return function() {\n    return count++;\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return makeCounter;')(); const c1 = fn(); const c2 = fn(); return [ { pass: c1() === 0, description: 'first call returns 0', got: 'see test' }, { pass: c1() === 1, description: 'second call returns 1', got: 'see test' }, { pass: c1() === 2, description: 'third call returns 2', got: 'see test' }, { pass: c2() === 0, description: 'new counter starts at 0 (independent)', got: 'see test' } ]; }",
      "hint": "A function can remember variables from the scope where it was created, even after that scope has closed. This is the mechanism that lets each counter have its own independent count.",
      "resources": [
        {
          "label": "MDN: Closures",
          "url": "/docs/mdn/closures.html",
          "description": "Functions that remember their creation scope"
        }
      ],
      "hints": [
        "Start by thinking about closures and scope and closures.",
        "A function can remember variables from the scope where it was created, even after that scope has closed. This is the mechanism that lets each counter have its own independent count.",
        "The function should return a number."
      ]
    },
    {
      "id": 10,
      "title": "Method Chaining",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "chaining",
        "filter",
        "map",
        "reduce",
        "intermediate"
      ],
      "description": "Chain array methods to transform data in a single expression.",
      "instructions": "Write `topScorers` — takes an array of player objects `{name, score}`, filters to scores >= 80, sorts descending, returns just the names.\n\nExample:\n  topScorers([{name:'A',score:90},{name:'B',score:70},{name:'C',score:85}])\n  → ['A','C']",
      "starterCode": "function topScorers(players) {\n  // Chain: filter → sort → map\n\n}",
      "solution": "function topScorers(players) {\n  return players\n    .filter(p => p.score >= 80)\n    .sort((a, b) => b.score - a.score)\n    .map(p => p.name);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return topScorers;')(); const p = [{name:'A',score:90},{name:'B',score:70},{name:'C',score:85}]; return [ { pass: JSON.stringify(fn(p)) === '[\"A\",\"C\"]', description: 'filters, sorts, maps correctly', got: JSON.stringify(fn(p)) }, { pass: JSON.stringify(fn([])) === '[]', description: 'empty array → []', got: JSON.stringify(fn([])) } ]; }",
      "hint": "Array methods can be called one after another because each returns a new array. Think about what each step in your pipeline needs to do — first narrow down, then order, then extract.",
      "resources": [
        {
          "label": "MDN: Array.sort()",
          "url": "/docs/mdn/array-sort.html",
          "description": "Sorting arrays with a comparator function"
        },
        {
          "label": "MDN: Method chaining",
          "url": "/docs/mdn/chaining.html",
          "description": "Composing array operations"
        }
      ],
      "hints": [
        "The `filter` method will be helpful here.",
        "Array methods can be called one after another because each returns a new array. Think about what each step in your pipeline needs to do — first narrow down, then order, then extract.",
        "Key method(s): `filter`, `sort`, `map`. Chain filter first to narrow down elements, then map to transform. The function should return an array."
      ]
    },
    {
      "id": 11,
      "title": "Flatten Nested Array",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "flat",
        "reduce",
        "recursion",
        "intermediate"
      ],
      "description": "Flatten a one-level nested array into a single array.",
      "instructions": "Write `flattenOnce` that takes an array of arrays and returns a flat array.\n\nExample:\n  flattenOnce([[1,2],[3,4],[5]]) → [1,2,3,4,5]\n  flattenOnce([]) → []",
      "starterCode": "function flattenOnce(arr) {\n  // Your code here\n\n}",
      "solution": "function flattenOnce(arr) {\n  return arr.reduce((acc, sub) => acc.concat(sub), []);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return flattenOnce;')(); return [ { pass: JSON.stringify(fn([[1,2],[3,4],[5]])) === '[1,2,3,4,5]', description: 'flattenOnce([[1,2],[3,4],[5]]) → [1,2,3,4,5]', got: JSON.stringify(fn([[1,2],[3,4],[5]])) }, { pass: JSON.stringify(fn([])) === '[]', description: 'empty → []', got: JSON.stringify(fn([])) }, { pass: JSON.stringify(fn([[1],[2],[3]])) === '[1,2,3]', description: 'single-element sub-arrays', got: JSON.stringify(fn([[1],[2],[3]])) } ]; }",
      "hint": "You need to combine multiple arrays into one. Think about an accumulator that starts empty and grows with each sub-array. Alternatively, arrays have a newer built-in method specifically for this.",
      "resources": [
        {
          "label": "MDN: Array.flat()",
          "url": "/docs/mdn/array-flat.html",
          "description": "The newer built-in for flattening"
        },
        {
          "label": "MDN: Array.concat()",
          "url": "/docs/mdn/array-concat.html",
          "description": "Merging arrays together"
        }
      ],
      "hints": [
        "Consider how `reduce` works.",
        "You need to combine multiple arrays into one. Think about an accumulator that starts empty and grows with each sub-array. Alternatively, arrays have a newer built-in method specifically for this.",
        "Key method(s): `reduce`, `concat`. The accumulator should track the running result through each iteration."
      ]
    },
    {
      "id": 12,
      "title": "Destructure & Default",
      "type": "js",
      "tier": 3,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "destructuring",
        "defaults",
        "objects",
        "es6",
        "intermediate"
      ],
      "description": "Extract object properties with destructuring and provide fallback defaults.",
      "instructions": "Write `formatUser` that takes a user object and returns a formatted string. Use destructuring with defaults.\n\n  formatUser({name: 'Alex', role: 'admin'}) → 'Alex (admin)'\n  formatUser({name: 'Sam'}) → 'Sam (student)'",
      "starterCode": "function formatUser(user) {\n  // Use destructuring with a default for role\n\n}",
      "solution": "function formatUser({ name, role = 'student' }) {\n  return `${name} (${role})`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return formatUser;')(); return [ { pass: fn({name:'Alex',role:'admin'}) === 'Alex (admin)', description: 'formatUser with role → \"Alex (admin)\"', got: fn({name:'Alex',role:'admin'}) }, { pass: fn({name:'Sam'}) === 'Sam (student)', description: 'missing role defaults to student', got: fn({name:'Sam'}) } ]; }",
      "hint": "Object destructuring lets you extract properties by name in a function's parameter list. You can provide a default value using = after the property name.",
      "resources": [
        {
          "label": "MDN: Destructuring assignment",
          "url": "/docs/mdn/destructuring.html",
          "description": "Extracting values from objects and arrays"
        },
        {
          "label": "MDN: Default parameters",
          "url": "/docs/mdn/default-params.html",
          "description": "Fallback values when arguments are missing"
        }
      ],
      "hints": [
        "How do you pull specific properties out of an object directly in the function parameter list, and what happens if a property is missing?",
        "Object destructuring lets you extract properties by name in a function's parameter list. You can provide a default value using = after the property name.",
        "The function should return a string."
      ]
    },
    {
      "id": 13,
      "title": "Async Fetch Wrapper",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "promises",
        "error-handling",
        "advanced"
      ],
      "description": "Wrap a fetch call with async/await and proper error handling.",
      "instructions": "Write `fetchData(url)` — an async function that fetches a URL and returns the parsed JSON. If the response is not ok, throw an Error with the status code.\n\n  await fetchData('https://example.com/api') → parsed JSON\n  await fetchData('https://bad-url') → throws Error('404')",
      "starterCode": "async function fetchData(url) {\n  // Your code here\n\n}",
      "solution": "async function fetchData(url) {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(String(response.status));\n  }\n  return response.json();\n}",
      "testRunner": "(code) => { const results = []; try { const fn = new Function(code + '; return fetchData;')(); if (typeof fn !== 'function') { results.push({ pass: false, description: 'fetchData is a function', got: typeof fn }); } else { results.push({ pass: true, description: 'fetchData is defined and is a function', got: 'function' }); const p = fn('https://jsonplaceholder.typicode.com/todos/1'); results.push({ pass: p instanceof Promise, description: 'fetchData returns a Promise', got: p instanceof Promise ? 'Promise' : typeof p }); } } catch(e) { results.push({ pass: false, description: 'No syntax errors', got: e.message }); } return results; }",
      "hint": "async functions always return a Promise. The await keyword pauses execution until a Promise resolves. After awaiting the fetch response, you need to check if the request succeeded before trying to parse it.",
      "resources": [
        {
          "label": "MDN: async/await",
          "url": "/docs/mdn/async-await.html",
          "description": "Writing asynchronous code in a synchronous style"
        },
        {
          "label": "MDN: Fetch API",
          "url": "/docs/mdn/fetch.html",
          "description": "Making HTTP requests from JavaScript"
        }
      ],
      "hints": [
        "What does `await fetch(url)` give you — the data itself, or something you still need to parse?",
        "async functions always return a Promise. The await keyword pauses execution until a Promise resolves. After awaiting the fetch response, you need to check if the request succeeded before trying to parse it.",
        "Key method(s): `json`, `new Error`."
      ]
    },
    {
      "id": 14,
      "title": "Template Literal Tags",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literals",
        "strings",
        "es6",
        "beginner"
      ],
      "description": "Use template literals to build multi-line strings with expressions.",
      "instructions": "Write `buildCard(item)` where item has `name`, `price`, `inStock`. Return a formatted string:\n\n  Name: Widget\n  Price: $9.99\n  Status: In Stock\n\n(Use template literals and a ternary for status)",
      "starterCode": "function buildCard(item) {\n  // Use a template literal\n\n}",
      "solution": "function buildCard({ name, price, inStock }) {\n  return `Name: ${name}\\nPrice: $${price}\\nStatus: ${inStock ? 'In Stock' : 'Out of Stock'}`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return buildCard;')(); const r1 = fn({name:'Widget',price:'9.99',inStock:true}); const r2 = fn({name:'Gadget',price:'4.50',inStock:false}); return [ { pass: r1.includes('Widget'), description: 'includes name', got: r1 }, { pass: r1.includes('$9.99'), description: 'includes formatted price', got: r1 }, { pass: r1.includes('In Stock'), description: 'inStock: true → \"In Stock\"', got: r1 }, { pass: r2.includes('Out of Stock'), description: 'inStock: false → \"Out of Stock\"', got: r2 } ]; }",
      "hint": "Template literals use backticks and ${} to embed expressions. A ternary expression inside ${} lets you choose between two strings based on a condition.",
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation and multi-line strings"
        },
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "Inline if/else for expressions"
        }
      ],
      "hints": [
        "Start by thinking about template literals and string methods.",
        "Template literals use backticks and ${} to embed expressions. A ternary expression inside ${} lets you choose between two strings based on a condition.",
        "The function should return a string."
      ]
    },
    {
      "id": 15,
      "title": "Pipeline: Filter → Map → Reduce",
      "type": "js",
      "tier": 5,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "chaining",
        "filter",
        "map",
        "reduce",
        "advanced",
        "pipeline"
      ],
      "description": "Combine filter, map, and reduce in a data transformation pipeline.",
      "instructions": "Write `salaryBudget(employees)` where each employee has `{name, dept, salary, active}`. Return the total salary budget for active employees only.\n\n  salaryBudget([{name:'A',dept:'Eng',salary:100000,active:true}, {name:'B',salary:80000,active:false}]) → 100000",
      "starterCode": "",
      "solution": "function salaryBudget(employees) {\n  return employees\n    .filter(e => e.active)\n    .map(e => e.salary)\n    .reduce((total, salary) => total + salary, 0);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return salaryBudget;')(); const emps = [{name:'A',dept:'Eng',salary:100000,active:true},{name:'B',dept:'HR',salary:80000,active:false},{name:'C',dept:'Eng',salary:90000,active:true}]; return [ { pass: fn(emps) === 190000, description: 'active salaries total 190000', got: fn(emps) }, { pass: fn([]) === 0, description: 'empty → 0', got: fn([]) }, { pass: fn([{salary:50000,active:false}]) === 0, description: 'all inactive → 0', got: fn([{salary:50000,active:false}]) } ]; }",
      "hint": "This problem can be broken into three distinct steps: which employees count, what value from each, and how to combine those values. Each step corresponds to an array method.",
      "resources": [
        {
          "label": "MDN: Array iteration methods",
          "url": "/docs/mdn/array-iteration.html",
          "description": "Complete overview of map, filter, reduce"
        }
      ],
      "hints": [
        "The `filter` method will be helpful here.",
        "This problem can be broken into three distinct steps: which employees count, what value from each, and how to combine those values. Each step corresponds to an array method.",
        "Key method(s): `filter`, `map`, `reduce`. The accumulator should track the running result through each iteration. The function should return an array."
      ]
    },
    {
      "id": 16,
      "title": "Semantic Page Structure",
      "type": "html",
      "tier": 1,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "semantics",
        "structure",
        "beginner"
      ],
      "description": "Build a properly structured HTML page using semantic elements.",
      "instructions": "Create an HTML page with:\n- A `<header>` containing an `<h1>` with the text \"My Page\"\n- A `<main>` containing a `<p>` with any text\n- A `<footer>` containing a `<p>` with the text \"Footer\"\n\nUse proper semantic HTML5 structure.",
      "starterCode": "<!-- Build your semantic HTML page here -->\n",
      "solution": "<header>\n  <h1>My Page</h1>\n</header>\n<main>\n  <p>Welcome to my page.</p>\n</main>\n<footer>\n  <p>Footer</p>\n</footer>",
      "testRunner": "",
      "testCases": [
        {
          "query": "header",
          "assertion": "exists",
          "description": "<header> element exists"
        },
        {
          "query": "header h1",
          "assertion": "exists",
          "description": "<h1> inside <header> exists"
        },
        {
          "query": "header h1",
          "assertion": "textContains",
          "value": "My Page",
          "description": "<h1> contains \"My Page\""
        },
        {
          "query": "main",
          "assertion": "exists",
          "description": "<main> element exists"
        },
        {
          "query": "main p",
          "assertion": "exists",
          "description": "<p> inside <main> exists"
        },
        {
          "query": "footer",
          "assertion": "exists",
          "description": "<footer> element exists"
        },
        {
          "query": "footer p",
          "assertion": "textContains",
          "value": "Footer",
          "description": "<footer> contains \"Footer\""
        }
      ],
      "hint": "HTML5 semantic elements communicate the role of each section to both browsers and screen readers. Each major section of a page has a corresponding element name that describes its purpose.",
      "resources": [
        {
          "label": "MDN: HTML5 semantic elements",
          "url": "/docs/mdn/semantic-elements.html",
          "description": "header, main, footer, nav, article, section"
        }
      ],
      "hints": [
        "What are the three major landmark elements that define the top, body, and bottom of a page?",
        "HTML5 semantic elements communicate the role of each section to both browsers and screen readers. Each major section of a page has a corresponding element name that describes its purpose.",
        "Key elements: `<header>`, `<h1>`, `<main>`, `<footer>`."
      ]
    },
    {
      "id": 17,
      "title": "Build a Form",
      "type": "html",
      "tier": 2,
      "category": [
        "html",
        "forms"
      ],
      "tags": [
        "html",
        "forms",
        "inputs",
        "labels",
        "beginner"
      ],
      "description": "Create an accessible HTML form with labeled inputs.",
      "instructions": "Build a login form with:\n- A `<form>` with `id=\"login-form\"`\n- A text input with `id=\"username\"` and a `<label>` that references it\n- A password input with `id=\"password\"` and a `<label>` that references it\n- A submit button with text \"Log In\"\n\nAll labels must use the `for` attribute.",
      "starterCode": "<!-- Build your login form -->\n",
      "solution": "<form id=\"login-form\">\n  <label for=\"username\">Username</label>\n  <input type=\"text\" id=\"username\" name=\"username\">\n  <label for=\"password\">Password</label>\n  <input type=\"password\" id=\"password\" name=\"password\">\n  <button type=\"submit\">Log In</button>\n</form>",
      "testRunner": "",
      "testCases": [
        {
          "query": "form",
          "assertion": "hasId",
          "value": "login-form",
          "description": "form has id=\"login-form\""
        },
        {
          "query": "input#username",
          "assertion": "exists",
          "description": "input with id=\"username\" exists"
        },
        {
          "query": "input[type=\"password\"]#password",
          "assertion": "exists",
          "description": "password input with id=\"password\" exists"
        },
        {
          "query": "label[for=\"username\"]",
          "assertion": "exists",
          "description": "label for username (using for attribute)"
        },
        {
          "query": "label[for=\"password\"]",
          "assertion": "exists",
          "description": "label for password (using for attribute)"
        },
        {
          "query": "button[type=\"submit\"], input[type=\"submit\"]",
          "assertion": "exists",
          "description": "submit button exists"
        },
        {
          "query": "button[type=\"submit\"]",
          "assertion": "textContains",
          "value": "Log In",
          "description": "submit button says \"Log In\""
        }
      ],
      "hint": "The `for` attribute on a `<label>` connects it to an input by matching the input's `id`. This is what makes forms accessible — clicking the label focuses the correct input.",
      "resources": [
        {
          "label": "MDN: HTML forms",
          "url": "/docs/mdn/forms.html",
          "description": "Creating accessible web forms"
        },
        {
          "label": "MDN: <label>",
          "url": "/docs/mdn/label.html",
          "description": "Associating labels with form controls"
        }
      ],
      "hints": [
        "What elements does a form need to be both functional and accessible — and how do labels connect to their inputs?",
        "The `for` attribute on a `<label>` connects it to an input by matching the input's `id`. This is what makes forms accessible — clicking the label focuses the correct input.",
        "Key elements: `<form>`, `<label>`, `<input>`, `<button>`. Important attributes: `for`, `type`, `name`."
      ]
    },
    {
      "id": 18,
      "title": "Style a Card",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "box-model"
      ],
      "tags": [
        "css",
        "box-model",
        "border-radius",
        "padding",
        "beginner"
      ],
      "description": "Apply box model properties to style a card component.",
      "instructions": "Style the `.card` element so it has:\n- `padding` of `24px`\n- A `border-radius` of `8px`\n- A `background-color` of `#1e293b`\n- A `border` of `1px solid #334155`\n- `max-width` of `400px`",
      "starterCode": "/* Style the .card element */\n\n",
      "solution": ".card {\n  padding: 24px;\n  border-radius: 8px;\n  background-color: #1e293b;\n  border: 1px solid #334155;\n  max-width: 400px;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"card\"><h2>Card Title</h2><p>Card content goes here.</p></div>",
      "testCases": [
        {
          "query": ".card",
          "assertion": "equals",
          "property": "padding",
          "value": "24px",
          "description": "padding is 24px"
        },
        {
          "query": ".card",
          "assertion": "equals",
          "property": "border-radius",
          "value": "8px",
          "description": "border-radius is 8px"
        },
        {
          "query": ".card",
          "assertion": "equals",
          "property": "background-color",
          "value": "rgb(30, 41, 59)",
          "description": "background-color is #1e293b"
        },
        {
          "query": ".card",
          "assertion": "equals",
          "property": "max-width",
          "value": "400px",
          "description": "max-width is 400px"
        }
      ],
      "hint": "The box model properties control how space is distributed around and within an element. Padding adds space inside the border, border-radius rounds the corners, and background-color fills the interior.",
      "resources": [
        {
          "label": "MDN: Box model",
          "url": "/docs/mdn/box-model.html",
          "description": "Understanding padding, border, and margin"
        },
        {
          "label": "MDN: border-radius",
          "url": "/docs/mdn/border-radius.html",
          "description": "Rounding element corners"
        }
      ],
      "hints": [
        "The `border-radius` property is central to this exercise.",
        "The box model properties control how space is distributed around and within an element. Padding adds space inside the border, border-radius rounds the corners, and background-color fills the interior.",
        "Key properties: `border-radius`, `background-color`, `border`, `max-width`."
      ]
    },
    {
      "id": 19,
      "title": "Flexbox Nav",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "flexbox"
      ],
      "tags": [
        "css",
        "flexbox",
        "navigation",
        "layout",
        "intermediate"
      ],
      "description": "Use Flexbox to lay out a horizontal navigation bar.",
      "instructions": "Style the `.nav` element so that:\n- It uses `display: flex`\n- Items are spaced with `justify-content: space-between`\n- Items are vertically centered with `align-items: center`\n- It has `padding` of `0 24px`\n- It has a `height` of `60px`",
      "starterCode": "/* Style the .nav using flexbox */\n\n",
      "solution": ".nav {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0 24px;\n  height: 60px;\n}",
      "testRunner": "",
      "providedHtml": "<nav class=\"nav\"><a href=\"#\">Home</a><a href=\"#\">About</a><a href=\"#\">Contact</a></nav>",
      "testCases": [
        {
          "query": ".nav",
          "assertion": "equals",
          "property": "display",
          "value": "flex",
          "description": "display is flex"
        },
        {
          "query": ".nav",
          "assertion": "equals",
          "property": "justify-content",
          "value": "space-between",
          "description": "justify-content is space-between"
        },
        {
          "query": ".nav",
          "assertion": "equals",
          "property": "align-items",
          "value": "center",
          "description": "align-items is center"
        },
        {
          "query": ".nav",
          "assertion": "equals",
          "property": "height",
          "value": "60px",
          "description": "height is 60px"
        }
      ],
      "hint": "Flexbox controls how children are arranged inside a container. justify-content handles distribution along the main axis (horizontal by default), while align-items handles alignment along the cross axis.",
      "resources": [
        {
          "label": "MDN: Flexbox",
          "url": "/docs/mdn/flexbox.html",
          "description": "Complete guide to CSS Flexbox"
        },
        {
          "label": "MDN: justify-content",
          "url": "/docs/mdn/justify-content.html",
          "description": "Distributing space between flex items"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "Flexbox controls how children are arranged inside a container. justify-content handles distribution along the main axis (horizontal by default), while align-items handles alignment along the cross axis.",
        "Key properties: `display`, `justify-content`, `align-items`, `height`."
      ]
    },
    {
      "id": 20,
      "title": "Profile Card",
      "type": "html-css",
      "tier": 3,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "css",
        "flexbox",
        "semantics",
        "intermediate"
      ],
      "description": "Build and style a profile card with HTML and CSS together.",
      "instructions": "Build a profile card with:\n- A `.profile-card` container\n- An `<img>` with class `avatar` (can use a placeholder src)\n- An `<h2>` with class `name` containing any name\n- A `<p>` with class `bio` containing any text\n\nStyle it so `.profile-card` uses flexbox (column direction), centered items, and has a `gap` of `12px`.",
      "starterCode": "<!-- HTML -->\n\n<!-- CSS is written in the second editor panel -->\n",
      "solution": "<div class=\"profile-card\">\n  <img class=\"avatar\" src=\"/placeholder.jpg\" alt=\"Profile\">\n  <h2 class=\"name\">Alex Rivera</h2>\n  <p class=\"bio\">Full-stack developer and lifelong learner.</p>\n</div>\n\n/* CSS */\n.profile-card {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 12px;\n}",
      "testRunner": "",
      "testCases": [
        {
          "query": ".profile-card",
          "assertion": "exists",
          "description": ".profile-card element exists"
        },
        {
          "query": ".profile-card img.avatar",
          "assertion": "exists",
          "description": "img.avatar inside .profile-card"
        },
        {
          "query": ".profile-card h2.name",
          "assertion": "exists",
          "description": "h2.name inside .profile-card"
        },
        {
          "query": ".profile-card p.bio",
          "assertion": "exists",
          "description": "p.bio inside .profile-card"
        },
        {
          "query": ".profile-card",
          "assertion": "equals",
          "property": "display",
          "value": "flex",
          "description": ".profile-card uses display: flex"
        },
        {
          "query": ".profile-card",
          "assertion": "equals",
          "property": "flex-direction",
          "value": "column",
          "description": "flex-direction is column"
        },
        {
          "query": ".profile-card",
          "assertion": "equals",
          "property": "align-items",
          "value": "center",
          "description": "align-items is center"
        }
      ],
      "hint": "When writing HTML and CSS together, plan the HTML structure first — which elements need which class names — then write CSS that targets those class names. Flexbox column layout stacks children vertically.",
      "resources": [
        {
          "label": "MDN: Flexbox",
          "url": "/docs/mdn/flexbox.html",
          "description": "Controlling layout with Flexbox"
        },
        {
          "label": "MDN: CSS gap",
          "url": "/docs/mdn/gap.html",
          "description": "Spacing between flex or grid children"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "When writing HTML and CSS together, plan the HTML structure first — which elements need which class names — then write CSS that targets those class names. Flexbox column layout stacks children vertically.",
        "HTML: Key elements: `<img>`, `<h2>`. Important attributes: `src`, `alt`. CSS: Key properties: `display`, `flex-direction`, `align-items`, `gap`."
      ]
    },
    {
      "id": 279,
      "title": "createValidator",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "scope"
      ],
      "tags": [
        "closure",
        "validation",
        "module-pattern",
        "higher-order",
        "tier4"
      ],
      "description": "Build a configurable validator factory using closures — define rules, then validate objects.",
      "instructions": "Build a factory function that returns a validator object with private rule storage.\n\n**createValidator()** — returns an object with:\n\n- `addRule(field, testFn, errorMsg)` — registers a validation rule. `testFn` receives the field value and returns `true` if valid.\n- `validate(obj)` — runs all rules against the object. Returns `{ valid: boolean, errors: string[] }`. An empty errors array means valid.\n- `getRules()` — returns the number of registered rules.\n\n```js\nconst v = createValidator();\nv.addRule('name', val => typeof val === 'string' && val.length > 0, 'Name is required');\nv.addRule('age', val => typeof val === 'number' && val >= 18, 'Must be 18+');\nv.addRule('email', val => val.includes('@'), 'Invalid email');\n\nv.getRules(); // 3\n\nv.validate({ name: 'Alex', age: 25, email: 'alex@test.com' });\n// { valid: true, errors: [] }\n\nv.validate({ name: '', age: 16, email: 'bad' });\n// { valid: false, errors: ['Name is required', 'Must be 18+', 'Invalid email'] }\n\nv.validate({ name: 'Alex', age: 25 });\n// { valid: false, errors: ['Invalid email'] }  — missing field fails the test\n```",
      "starterCode": "function createValidator() {\n  // private rule storage\n\n  return {\n    addRule(field, testFn, errorMsg) {\n      // your code here\n    },\n\n    validate(obj) {\n      // your code here\n    },\n\n    getRules() {\n      // your code here\n    },\n  };\n}",
      "solution": "function createValidator() {\n  const rules = [];\n\n  return {\n    addRule(field, testFn, errorMsg) {\n      rules.push({ field, testFn, errorMsg });\n    },\n\n    validate(obj) {\n      const errors = [];\n      for (const rule of rules) {\n        if (!rule.testFn(obj[rule.field])) {\n          errors.push(rule.errorMsg);\n        }\n      }\n      return { valid: errors.length === 0, errors };\n    },\n\n    getRules() {\n      return rules.length;\n    },\n  };\n}",
      "testRunner": "(code) => {\n  const createValidator = new Function(code + '; return createValidator;')();\n  const v = createValidator();\n  v.addRule('name', val => typeof val === 'string' && val.length > 0, 'Name is required');\n  v.addRule('age', val => typeof val === 'number' && val >= 18, 'Must be 18+');\n  v.addRule('email', val => val && val.includes('@'), 'Invalid email');\n\n  const good = v.validate({ name: 'Alex', age: 25, email: 'a@b.com' });\n  const bad = v.validate({ name: '', age: 16, email: 'bad' });\n  const missing = v.validate({ name: 'Alex', age: 25 });\n\n  return [\n    { pass: v.getRules() === 3, description: 'getRules() returns 3 after adding 3 rules', got: v.getRules() },\n    { pass: good.valid === true, description: 'Valid object returns { valid: true }', got: good.valid },\n    { pass: good.errors.length === 0, description: 'Valid object has empty errors array', got: good.errors.length },\n    { pass: bad.valid === false, description: 'Invalid object returns { valid: false }', got: bad.valid },\n    { pass: bad.errors.length === 3, description: 'All 3 rules fail for bad input', got: bad.errors.length },\n    { pass: bad.errors[0] === 'Name is required', description: 'First error is name rule', got: bad.errors[0] },\n    { pass: missing.valid === false && missing.errors.includes('Invalid email'), description: 'Missing field fails validation', got: missing.errors.join(', ') },\n  ];\n}",
      "hint": "Store rules in a closure-scoped array. Each rule is an object with { field, testFn, errorMsg }. validate() iterates all rules, calling testFn(obj[field]) and collecting error messages when false.",
      "resources": [
        {
          "label": "MDN: Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ],
      "hints": [
        "Start by thinking about closures and input validation.",
        "Store rules in a closure-scoped array. Each rule is an object with { field, testFn, errorMsg }. validate() iterates all rules, calling testFn(obj[field]) and collecting error messages when false.",
        "Key method(s): `testFn`. Use a loop to iterate, then return the accumulated result. The function should return an object."
      ]
    },
    {
      "id": 280,
      "title": "createStateMachine",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "scope"
      ],
      "tags": [
        "closure",
        "state-machine",
        "design-pattern",
        "module-pattern",
        "tier4"
      ],
      "description": "Implement a finite state machine with transitions, guards, and history tracking.",
      "instructions": "Build a state machine factory.\n\n**createStateMachine(initialState, transitions)** where `transitions` maps each state to its valid actions:\n```js\nconst sm = createStateMachine('idle', {\n  idle:    { START: 'running' },\n  running: { PAUSE: 'paused', STOP: 'idle' },\n  paused:  { RESUME: 'running', STOP: 'idle' },\n});\n```\n\nReturns an object with:\n- `getState()` — returns current state string\n- `send(action)` — transitions to new state if valid, returns new state. Returns `false` for invalid transitions.\n- `canSend(action)` — returns `true` if the action is valid from the current state\n- `getHistory()` — returns array of `{ from, action, to }` objects\n\n```js\nsm.getState();        // 'idle'\nsm.canSend('START');  // true\nsm.canSend('PAUSE');  // false (not valid from 'idle')\nsm.send('START');     // 'running'\nsm.send('PAUSE');     // 'paused'\nsm.send('STOP');      // 'idle'\nsm.send('PAUSE');     // false (can't PAUSE from idle)\nsm.getHistory();\n// [\n//   { from: 'idle', action: 'START', to: 'running' },\n//   { from: 'running', action: 'PAUSE', to: 'paused' },\n//   { from: 'paused', action: 'STOP', to: 'idle' },\n// ]\n```",
      "starterCode": "function createStateMachine(initialState, transitions) {\n  // private state\n\n  return {\n    getState() {\n      // your code here\n    },\n\n    send(action) {\n      // your code here\n    },\n\n    canSend(action) {\n      // your code here\n    },\n\n    getHistory() {\n      // your code here\n    },\n  };\n}",
      "solution": "function createStateMachine(initialState, transitions) {\n  let current = initialState;\n  const history = [];\n\n  return {\n    getState() {\n      return current;\n    },\n\n    send(action) {\n      const stateTransitions = transitions[current];\n      if (!stateTransitions || !stateTransitions[action]) return false;\n      const from = current;\n      current = stateTransitions[action];\n      history.push({ from, action, to: current });\n      return current;\n    },\n\n    canSend(action) {\n      const stateTransitions = transitions[current];\n      return !!(stateTransitions && stateTransitions[action]);\n    },\n\n    getHistory() {\n      return [...history];\n    },\n  };\n}",
      "testRunner": "(code) => {\n  const createStateMachine = new Function(code + '; return createStateMachine;')();\n  const sm = createStateMachine('idle', {\n    idle: { START: 'running' },\n    running: { PAUSE: 'paused', STOP: 'idle' },\n    paused: { RESUME: 'running', STOP: 'idle' },\n  });\n\n  return [\n    { pass: sm.getState() === 'idle', description: 'Initial state is idle', got: sm.getState() },\n    { pass: sm.canSend('START') === true, description: 'canSend START from idle', got: sm.canSend('START') },\n    { pass: sm.canSend('PAUSE') === false, description: 'cannot PAUSE from idle', got: sm.canSend('PAUSE') },\n    { pass: sm.send('START') === 'running', description: 'send START → running', got: sm.send('START') || sm.getState() },\n    { pass: (() => { const s = createStateMachine('idle', { idle: { GO: 'active' }, active: { STOP: 'idle' } }); s.send('GO'); s.send('STOP'); return s.getState() === 'idle'; })(), description: 'Transitions work through multiple states', got: (() => { const s = createStateMachine('idle', { idle: { GO: 'active' }, active: { STOP: 'idle' } }); s.send('GO'); s.send('STOP'); return s.getState(); })() },\n    { pass: (() => { const s = createStateMachine('idle', { idle: { GO: 'active' } }); return s.send('INVALID') === false; })(), description: 'Invalid action returns false', got: (() => { const s = createStateMachine('idle', { idle: { GO: 'active' } }); return s.send('INVALID'); })() },\n    { pass: (() => { const s = createStateMachine('idle', { idle: { GO: 'active' }, active: {} }); s.send('GO'); const h = s.getHistory(); return h.length === 1 && h[0].from === 'idle' && h[0].action === 'GO' && h[0].to === 'active'; })(), description: 'getHistory tracks transitions', got: (() => { const s = createStateMachine('idle', { idle: { GO: 'active' }, active: {} }); s.send('GO'); return JSON.stringify(s.getHistory()); })() },\n  ];\n}",
      "hint": "Store `current` state and `history` array in closure scope. send() looks up transitions[current][action] — if it exists, update current and push to history. canSend() just checks if the lookup exists.",
      "resources": [
        {
          "label": "State Machine Pattern",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/State_machine"
        }
      ],
      "hints": [
        "How does the machine know which transitions are valid from the current state, and what happens if you attempt an invalid one?",
        "Store `current` state and `history` array in closure scope. send() looks up transitions[current][action] — if it exists, update current and push to history. canSend() just checks if the lookup exists.",
        "The function should return a boolean."
      ]
    },
    {
      "id": 281,
      "title": "retryAsync",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "promises",
        "error-handling",
        "retry",
        "tier4"
      ],
      "description": "Write an async utility that retries a failing function up to N times with configurable delay.",
      "instructions": "Write an async function:\n\n**retryAsync(fn, options)** where:\n- `fn` is an async function (returns a Promise)\n- `options` has `{ maxRetries, delay, onRetry }`\n  - `maxRetries`: number of retry attempts (default 3)\n  - `delay`: ms to wait between retries (default 0)\n  - `onRetry`: optional callback `(error, attempt) => {}` called before each retry\n\nBehavior:\n1. Call `fn()`. If it succeeds, return the result.\n2. If it throws, wait `delay` ms, call `onRetry(error, attemptNumber)` if provided, then retry.\n3. After `maxRetries` failures, throw the last error.\n\n```js\nlet calls = 0;\nconst flaky = async () => {\n  calls++;\n  if (calls < 3) throw new Error('fail');\n  return 'success';\n};\n\nconst result = await retryAsync(flaky, { maxRetries: 5, delay: 10 });\n// result === 'success', calls === 3\n```",
      "starterCode": "async function retryAsync(fn, options = {}) {\n  const maxRetries = options.maxRetries ?? 3;\n  const delay = options.delay ?? 0;\n  const onRetry = options.onRetry ?? null;\n\n  // your code here\n}",
      "solution": "async function retryAsync(fn, options = {}) {\n  const maxRetries = options.maxRetries ?? 3;\n  const delay = options.delay ?? 0;\n  const onRetry = options.onRetry ?? null;\n\n  let lastError;\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (attempt < maxRetries) {\n        if (delay > 0) await new Promise(r => setTimeout(r, delay));\n        if (onRetry) onRetry(err, attempt + 1);\n      }\n    }\n  }\n  throw lastError;\n}",
      "testRunner": "(code) => {\n  const retryAsync = new Function(code + '; return retryAsync;')();\n  const results = [];\n\n  const test1 = (async () => {\n    const r = await retryAsync(async () => 'ok', { maxRetries: 3 });\n    return r === 'ok';\n  })();\n\n  const test2 = (async () => {\n    let c = 0;\n    const r = await retryAsync(async () => { c++; if (c < 3) throw new Error('x'); return 'done'; }, { maxRetries: 5 });\n    return r === 'done' && c === 3;\n  })();\n\n  const test3 = (async () => {\n    try {\n      await retryAsync(async () => { throw new Error('always'); }, { maxRetries: 2 });\n      return false;\n    } catch (e) {\n      return e.message === 'always';\n    }\n  })();\n\n  const test4 = (async () => {\n    const retries = [];\n    let c = 0;\n    await retryAsync(async () => { c++; if (c < 2) throw new Error('fail'); return 'ok'; }, { maxRetries: 3, onRetry: (err, attempt) => retries.push(attempt) });\n    return retries.length === 1 && retries[0] === 1;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Returns result on first success', got: r1 },\n    { pass: r2, description: 'Retries until success (3rd attempt)', got: r2 },\n    { pass: r3, description: 'Throws last error after maxRetries', got: r3 },\n    { pass: r4, description: 'Calls onRetry with attempt number', got: r4 },\n  ]);\n}",
      "hint": "Use a for loop from 0 to maxRetries. Inside: try calling fn(). On catch, if not the last attempt, wait using `await new Promise(r => setTimeout(r, delay))` then call onRetry. After the loop, throw the last error.",
      "resources": [
        {
          "label": "MDN: async/await",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises"
        }
      ],
      "hints": [
        "If the async function throws, how do you catch the error and try again — and how do you know when to stop retrying?",
        "Use a for loop from 0 to maxRetries. Inside: try calling fn(). On catch, if not the last attempt, wait using `await new Promise(r => setTimeout(r, delay))` then call onRetry. After the loop, throw the last error.",
        "Key method(s): `new Promise`. Use a loop to iterate, then return the accumulated result."
      ]
    },
    {
      "id": 282,
      "title": "promiseAll",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "implementation",
        "error-handling",
        "tier4"
      ],
      "description": "Implement your own Promise.all — resolve when all resolve, reject on first failure.",
      "instructions": "Write a function:\n\n**promiseAll(promises)** that takes an array of promises and returns a new Promise.\n\n- Resolves with an array of results (in original order) when ALL promises resolve\n- Rejects with the first error encountered\n- Empty array resolves immediately with `[]`\n- Results must maintain order even if promises resolve out of order\n\n```js\nconst result = await promiseAll([\n  Promise.resolve(1),\n  new Promise(r => setTimeout(() => r(2), 50)),\n  Promise.resolve(3),\n]);\n// [1, 2, 3]  — in order, even though middle one resolved last\n\ntry {\n  await promiseAll([\n    Promise.resolve(1),\n    Promise.reject(new Error('boom')),\n    Promise.resolve(3),\n  ]);\n} catch (e) {\n  // e.message === 'boom'\n}\n```",
      "starterCode": "function promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    // your code here\n  });\n}",
      "solution": "function promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    if (promises.length === 0) return resolve([]);\n    const results = new Array(promises.length);\n    let resolved = 0;\n    promises.forEach((p, i) => {\n      Promise.resolve(p).then(value => {\n        results[i] = value;\n        resolved++;\n        if (resolved === promises.length) resolve(results);\n      }).catch(reject);\n    });\n  });\n}",
      "testRunner": "(code) => {\n  const promiseAll = new Function(code + '; return promiseAll;')();\n\n  const test1 = promiseAll([]).then(r => r.length === 0);\n  const test2 = promiseAll([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]).then(r => JSON.stringify(r) === '[1,2,3]');\n  const test3 = promiseAll([\n    new Promise(r => setTimeout(() => r('slow'), 30)),\n    Promise.resolve('fast'),\n  ]).then(r => r[0] === 'slow' && r[1] === 'fast');\n  const test4 = promiseAll([Promise.resolve(1), Promise.reject(new Error('boom')), Promise.resolve(3)]).then(() => false).catch(e => e.message === 'boom');\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Empty array resolves with []', got: r1 },\n    { pass: r2, description: 'Resolves with [1,2,3] in order', got: r2 },\n    { pass: r3, description: 'Maintains order despite async timing', got: r3 },\n    { pass: r4, description: 'Rejects with first error', got: r4 },\n  ]);\n}",
      "hint": "Create a results array and a resolved counter. Use forEach with index to place each result at the right position. Increment counter on each .then() and resolve when counter === length. Any .catch() triggers reject immediately.",
      "resources": [
        {
          "label": "MDN: Promise",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
        }
      ],
      "hints": [
        "How do you wait for multiple promises to finish and collect all their results — and what should happen if one rejects?",
        "Create a results array and a resolved counter. Use forEach with index to place each result at the right position. Increment counter on each .then() and resolve when counter === length. Any .catch() triggers reject immediately.",
        "Key method(s): `forEach`, `resolve`, `then`."
      ]
    },
    {
      "id": 283,
      "title": "Observable",
      "type": "js",
      "tier": 4,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "oop",
        "design-pattern",
        "reactive",
        "callbacks",
        "tier4"
      ],
      "description": "Build an Observable class with subscribe/unsubscribe, value changes, and derived state via .map().",
      "instructions": "Create an **Observable** class:\n\n**Constructor:** takes an initial value\n\n**Methods:**\n- `get()` — returns current value\n- `set(value)` — updates value and notifies all subscribers with the new value\n- `subscribe(callback)` — registers a listener. Returns an **unsubscribe function**.\n- `map(transformFn)` — returns a NEW Observable whose value auto-updates when the source changes\n- `subscriberCount()` — returns number of active subscribers\n\n```js\nconst count = new Observable(0);\nconst logs = [];\n\nconst unsub = count.subscribe(val => logs.push(val));\ncount.set(1);     // logs: [1]\ncount.set(2);     // logs: [1, 2]\n\nconst doubled = count.map(x => x * 2);\ndoubled.get();    // 4 (2 * 2)\n\ncount.set(5);\ndoubled.get();    // 10 (5 * 2)\n\nunsub();          // unsubscribe\ncount.set(99);    // logs still [1, 2] — unsubscribed\ncount.subscriberCount(); // 1 (only the map's internal subscription)\n```",
      "starterCode": "class Observable {\n  constructor(initialValue) {\n    // your code here\n  }\n\n  get() {\n    // your code here\n  }\n\n  set(value) {\n    // your code here\n  }\n\n  subscribe(callback) {\n    // your code here — return an unsubscribe function\n  }\n\n  map(transformFn) {\n    // your code here — return a new Observable\n  }\n\n  subscriberCount() {\n    // your code here\n  }\n}",
      "solution": "class Observable {\n  constructor(initialValue) {\n    this._value = initialValue;\n    this._subscribers = new Set();\n  }\n\n  get() {\n    return this._value;\n  }\n\n  set(value) {\n    this._value = value;\n    for (const cb of this._subscribers) cb(value);\n  }\n\n  subscribe(callback) {\n    this._subscribers.add(callback);\n    return () => this._subscribers.delete(callback);\n  }\n\n  map(transformFn) {\n    const derived = new Observable(transformFn(this._value));\n    this.subscribe(val => derived.set(transformFn(val)));\n    return derived;\n  }\n\n  subscriberCount() {\n    return this._subscribers.size;\n  }\n}",
      "testRunner": "(code) => {\n  const Observable = new Function(code + '; return Observable;')();\n  const count = new Observable(0);\n  const logs = [];\n  const unsub = count.subscribe(val => logs.push(val));\n  count.set(1);\n  count.set(2);\n  const doubled = count.map(x => x * 2);\n\n  return [\n    { pass: count.get() === 2, description: 'get() returns current value', got: count.get() },\n    { pass: logs.length === 2 && logs[0] === 1 && logs[1] === 2, description: 'subscribe notified on set()', got: JSON.stringify(logs) },\n    { pass: doubled.get() === 4, description: 'map() derives value (2*2=4)', got: doubled.get() },\n    { pass: (() => { count.set(5); return doubled.get() === 10; })(), description: 'Derived updates when source changes (5*2=10)', got: doubled.get() },\n    { pass: (() => { unsub(); const before = logs.length; count.set(99); return logs.length === before; })(), description: 'Unsubscribe stops notifications', got: logs.length },\n    { pass: count.subscriberCount() === 1, description: 'subscriberCount is 1 (map internal sub)', got: count.subscriberCount() },\n  ];\n}",
      "hint": "Use a Set for subscribers (easy add/delete). subscribe() returns a function that calls Set.delete(). map() creates a new Observable and subscribes to the source, updating the derived value through the transform function.",
      "resources": [
        {
          "label": "MDN: Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        }
      ],
      "hints": [
        "When the value changes, every subscriber needs to be notified — how do you store and call all those callback functions?",
        "Use a Set for subscribers (easy add/delete). subscribe() returns a function that calls Set.delete(). map() creates a new Observable and subscribes to the source, updating the derived value through the transform function.",
        "Key method(s): `add`, `delete`, `subscribe`. Use a loop to iterate, then return the accumulated result."
      ]
    },
    {
      "id": 284,
      "title": "LinkedList",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "class",
        "data-structure",
        "linked-list",
        "algorithms",
        "tier4"
      ],
      "description": "Implement a singly linked list with append, remove, find, and in-place reverse.",
      "instructions": "Build two classes:\n\n**Node(value)** — `this.value`, `this.next = null`\n\n**LinkedList()** — `this.head = null`, `this.size = 0`\n\n**Methods:**\n- `append(value)` — add to end\n- `prepend(value)` — add to beginning\n- `getAt(index)` — return value at index, or `null` if out of bounds\n- `removeAt(index)` — remove node at index, return removed value, or `null`\n- `find(value)` — return index of first match, or `-1`\n- `reverse()` — reverse the list in place\n- `toArray()` — return array of all values\n- `toString()` — return values joined with `' -> '`\n\n```js\nconst list = new LinkedList();\nlist.append(1);\nlist.append(2);\nlist.append(3);\nlist.prepend(0);\nlist.toString();   // '0 -> 1 -> 2 -> 3'\nlist.getAt(2);     // 2\nlist.find(3);      // 3 (index)\nlist.removeAt(1);  // 1 (removed value)\nlist.toString();   // '0 -> 2 -> 3'\nlist.reverse();\nlist.toString();   // '3 -> 2 -> 0'\n```",
      "starterCode": "class Node {\n  constructor(value) {\n    // your code here\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    // your code here\n  }\n\n  append(value) {\n    // your code here\n  }\n\n  prepend(value) {\n    // your code here\n  }\n\n  getAt(index) {\n    // your code here\n  }\n\n  removeAt(index) {\n    // your code here\n  }\n\n  find(value) {\n    // your code here\n  }\n\n  reverse() {\n    // your code here\n  }\n\n  toArray() {\n    // your code here\n  }\n\n  toString() {\n    // your code here\n  }\n}",
      "solution": "class Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.size = 0;\n  }\n\n  append(value) {\n    const node = new Node(value);\n    if (!this.head) { this.head = node; }\n    else {\n      let curr = this.head;\n      while (curr.next) curr = curr.next;\n      curr.next = node;\n    }\n    this.size++;\n  }\n\n  prepend(value) {\n    const node = new Node(value);\n    node.next = this.head;\n    this.head = node;\n    this.size++;\n  }\n\n  getAt(index) {\n    if (index < 0 || index >= this.size) return null;\n    let curr = this.head;\n    for (let i = 0; i < index; i++) curr = curr.next;\n    return curr.value;\n  }\n\n  removeAt(index) {\n    if (index < 0 || index >= this.size) return null;\n    let removed;\n    if (index === 0) {\n      removed = this.head.value;\n      this.head = this.head.next;\n    } else {\n      let curr = this.head;\n      for (let i = 0; i < index - 1; i++) curr = curr.next;\n      removed = curr.next.value;\n      curr.next = curr.next.next;\n    }\n    this.size--;\n    return removed;\n  }\n\n  find(value) {\n    let curr = this.head;\n    let idx = 0;\n    while (curr) {\n      if (curr.value === value) return idx;\n      curr = curr.next;\n      idx++;\n    }\n    return -1;\n  }\n\n  reverse() {\n    let prev = null;\n    let curr = this.head;\n    while (curr) {\n      const next = curr.next;\n      curr.next = prev;\n      prev = curr;\n      curr = next;\n    }\n    this.head = prev;\n  }\n\n  toArray() {\n    const arr = [];\n    let curr = this.head;\n    while (curr) { arr.push(curr.value); curr = curr.next; }\n    return arr;\n  }\n\n  toString() {\n    return this.toArray().join(' -> ');\n  }\n}",
      "testRunner": "(code) => {\n  const { Node, LinkedList } = new Function(code + '; return { Node, LinkedList };')();\n  const list = new LinkedList();\n  list.append(1); list.append(2); list.append(3); list.prepend(0);\n\n  return [\n    { pass: list.toString() === '0 -> 1 -> 2 -> 3', description: 'append/prepend builds list', got: list.toString() },\n    { pass: list.size === 4, description: 'size tracks count', got: list.size },\n    { pass: list.getAt(2) === 2, description: 'getAt(2) returns 2', got: list.getAt(2) },\n    { pass: list.getAt(10) === null, description: 'getAt out of bounds returns null', got: list.getAt(10) },\n    { pass: list.find(3) === 3, description: 'find(3) returns index 3', got: list.find(3) },\n    { pass: list.find(99) === -1, description: 'find missing returns -1', got: list.find(99) },\n    { pass: (() => { const l = new LinkedList(); l.append(1); l.append(2); l.append(3); const r = l.removeAt(1); return r === 2 && l.toString() === '1 -> 3'; })(), description: 'removeAt(1) removes middle node', got: (() => { const l = new LinkedList(); l.append(1); l.append(2); l.append(3); l.removeAt(1); return l.toString(); })() },\n    { pass: (() => { const l = new LinkedList(); l.append(1); l.append(2); l.append(3); l.reverse(); return l.toString() === '3 -> 2 -> 1'; })(), description: 'reverse() reverses in place', got: (() => { const l = new LinkedList(); l.append(1); l.append(2); l.append(3); l.reverse(); return l.toString(); })() },\n  ];\n}",
      "hint": "For reverse(), use three pointers: prev, curr, next. In each step: save next, point curr.next to prev, advance prev to curr, advance curr to next. When done, set head to prev.",
      "resources": [
        {
          "label": "Linked List Visualization",
          "url": "https://visualgo.net/en/list"
        }
      ],
      "hints": [
        "Unlike an array, a linked list connects nodes with pointers — how do you traverse from head to tail to find or insert a node?",
        "For reverse(), use three pointers: prev, curr, next. In each step: save next, point curr.next to prev, advance prev to curr, advance curr to next. When done, set head to prev.",
        "Key method(s): `toArray`, `join`, `new Node`. Use a loop to iterate, then return the accumulated result. The function should return a string."
      ]
    },
    {
      "id": 285,
      "title": "deepClone",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "recursion",
        "objects",
        "arrays",
        "deep-copy",
        "type-checking",
        "tier4"
      ],
      "description": "Write a deep clone function handling objects, arrays, dates, and nested structures.",
      "instructions": "Write a function:\n\n**deepClone(value)** that produces a fully independent copy.\n\nMust handle:\n- **Primitives** (string, number, boolean, null, undefined) — return as-is\n- **Plain objects** — recurse into all keys\n- **Arrays** — recurse into all elements\n- **Date instances** — create new Date with same time\n- **Nested structures** — any depth\n\nThe clone must be fully independent — mutating the clone must never affect the original.\n\n```js\nconst original = {\n  name: 'Alex',\n  scores: [1, 2, 3],\n  nested: { a: { b: 'deep' } },\n  date: new Date('2024-01-01'),\n};\n\nconst clone = deepClone(original);\nclone.scores.push(4);\nclone.nested.a.b = 'changed';\n\noriginal.scores;      // [1, 2, 3] — unchanged\noriginal.nested.a.b;  // 'deep' — unchanged\nclone.date instanceof Date; // true\nclone.date.getTime() === original.date.getTime(); // true\nclone.date !== original.date; // true — different object\n```",
      "starterCode": "function deepClone(value) {\n  // your code here\n}",
      "solution": "function deepClone(value) {\n  if (value === null || typeof value !== 'object') return value;\n  if (value instanceof Date) return new Date(value.getTime());\n  if (Array.isArray(value)) return value.map(item => deepClone(item));\n  const result = {};\n  for (const key in value) {\n    if (value.hasOwnProperty(key)) {\n      result[key] = deepClone(value[key]);\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => {\n  const deepClone = new Function(code + '; return deepClone;')();\n  const orig = { name: 'Alex', scores: [1, 2, 3], nested: { a: { b: 'deep' } }, date: new Date('2024-01-01') };\n  const clone = deepClone(orig);\n  clone.scores.push(4);\n  clone.nested.a.b = 'changed';\n\n  return [\n    { pass: deepClone(42) === 42, description: 'Primitives returned as-is', got: deepClone(42) },\n    { pass: deepClone(null) === null, description: 'null returned as-is', got: deepClone(null) },\n    { pass: clone.name === 'Alex', description: 'Clones primitive properties', got: clone.name },\n    { pass: orig.scores.length === 3, description: 'Original array unchanged after clone mutation', got: orig.scores.length },\n    { pass: orig.nested.a.b === 'deep', description: 'Original nested object unchanged', got: orig.nested.a.b },\n    { pass: clone.date instanceof Date && clone.date.getTime() === orig.date.getTime(), description: 'Date cloned with same time', got: clone.date instanceof Date },\n    { pass: clone.date !== orig.date, description: 'Date is a different instance', got: clone.date !== orig.date },\n    { pass: (() => { const a = deepClone([1, [2, [3]]]); a[1][1][0] = 99; return a[1][1][0] === 99; })(), description: 'Deeply nested arrays cloned', got: true },\n  ];\n}",
      "hint": "Check types in order: null first, then Date (instanceof), then Array (Array.isArray), then plain object (typeof === \"object\"). Recurse for arrays (use .map(deepClone)) and objects (iterate keys).",
      "resources": [
        {
          "label": "MDN: typeof",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"
        }
      ],
      "hints": [
        "The `isArray` method will be helpful here.",
        "Check types in order: null first, then Date (instanceof), then Array (Array.isArray), then plain object (typeof === \"object\"). Recurse for arrays (use .map(deepClone)) and objects (iterate keys).",
        "Key method(s): `getTime`, `isArray`, `map`. The function calls itself recursively. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 286,
      "title": "createRouter",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "scope"
      ],
      "tags": [
        "closure",
        "module-pattern",
        "strings",
        "pattern-matching",
        "tier4"
      ],
      "description": "Build a URL router that matches path patterns with :param extraction and calls handlers.",
      "instructions": "Build a router factory:\n\n**createRouter()** returns:\n- `addRoute(pattern, handler)` — registers a route. Patterns use `:param` for dynamic segments.\n- `navigate(path)` — finds the first matching route, extracts params, calls `handler(params)` and returns its result. Returns `'404 Not Found'` if no match.\n\n```js\nconst router = createRouter();\nrouter.addRoute('/about', () => 'About Page');\nrouter.addRoute('/users/:id', (params) => 'User ' + params.id);\nrouter.addRoute('/posts/:postId/comments/:commentId', (params) => \n  'Post ' + params.postId + ' Comment ' + params.commentId\n);\n\nrouter.navigate('/about');                    // 'About Page'\nrouter.navigate('/users/42');                 // 'User 42'\nrouter.navigate('/posts/10/comments/5');      // 'Post 10 Comment 5'\nrouter.navigate('/unknown');                  // '404 Not Found'\n```",
      "starterCode": "function createRouter() {\n  // private route storage\n\n  return {\n    addRoute(pattern, handler) {\n      // your code here\n    },\n\n    navigate(path) {\n      // your code here\n    },\n  };\n}",
      "solution": "function createRouter() {\n  const routes = [];\n\n  return {\n    addRoute(pattern, handler) {\n      routes.push({ pattern, handler });\n    },\n\n    navigate(path) {\n      const pathParts = path.split('/').filter(Boolean);\n      for (const route of routes) {\n        const patternParts = route.pattern.split('/').filter(Boolean);\n        if (patternParts.length !== pathParts.length) continue;\n        const params = {};\n        let match = true;\n        for (let i = 0; i < patternParts.length; i++) {\n          if (patternParts[i].startsWith(':')) {\n            params[patternParts[i].slice(1)] = pathParts[i];\n          } else if (patternParts[i] !== pathParts[i]) {\n            match = false;\n            break;\n          }\n        }\n        if (match) return route.handler(params);\n      }\n      return '404 Not Found';\n    },\n  };\n}",
      "testRunner": "(code) => {\n  const createRouter = new Function(code + '; return createRouter;')();\n  const router = createRouter();\n  router.addRoute('/about', () => 'About Page');\n  router.addRoute('/users/:id', p => 'User ' + p.id);\n  router.addRoute('/posts/:postId/comments/:commentId', p => 'Post ' + p.postId + ' Comment ' + p.commentId);\n\n  return [\n    { pass: router.navigate('/about') === 'About Page', description: 'Static route matches', got: router.navigate('/about') },\n    { pass: router.navigate('/users/42') === 'User 42', description: 'Single param extracted', got: router.navigate('/users/42') },\n    { pass: router.navigate('/users/abc') === 'User abc', description: 'Params are strings', got: router.navigate('/users/abc') },\n    { pass: router.navigate('/posts/10/comments/5') === 'Post 10 Comment 5', description: 'Multiple params extracted', got: router.navigate('/posts/10/comments/5') },\n    { pass: router.navigate('/unknown') === '404 Not Found', description: 'Unmatched returns 404', got: router.navigate('/unknown') },\n    { pass: router.navigate('/users') === '404 Not Found', description: 'Wrong segment count returns 404', got: router.navigate('/users') },\n  ];\n}",
      "hint": "Split both pattern and path by \"/\". If segment counts differ, skip. For each segment pair: if the pattern starts with \":\", extract the param. Otherwise, require exact match. If all segments match, call the handler with the params object.",
      "resources": [
        {
          "label": "MDN: String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        }
      ],
      "hints": [
        "Consider how `split` works.",
        "Split both pattern and path by \"/\". If segment counts differ, skip. For each segment pair: if the pattern starts with \":\", extract the param. Otherwise, require exact match. If all segments match, call the handler with the params object.",
        "Key method(s): `split`, `filter`, `startsWith`. Use a loop to iterate, then return the accumulated result. The function should return an object."
      ]
    },
    {
      "id": 287,
      "title": "Dataset: Music Library",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "reduce",
        "objects",
        "higher-order",
        "dataset",
        "tier4"
      ],
      "description": "Transform a music library dataset: group by genre, compute artist stats, summarize by decade.",
      "instructions": "You have a dataset of albums:\n```js\nconst albums = [\n  { title: 'Abbey Road', artist: 'The Beatles', year: 1969, genres: ['rock', 'pop'], tracks: [{ name: 'Come Together', durationSec: 259 }, { name: 'Here Comes the Sun', durationSec: 185 }] },\n  { title: 'Thriller', artist: 'Michael Jackson', year: 1982, genres: ['pop', 'funk'], tracks: [{ name: 'Thriller', durationSec: 358 }, { name: 'Beat It', durationSec: 258 }] },\n  { title: 'Let It Be', artist: 'The Beatles', year: 1970, genres: ['rock'], tracks: [{ name: 'Let It Be', durationSec: 243 }, { name: 'Get Back', durationSec: 190 }] },\n  { title: 'Bad', artist: 'Michael Jackson', year: 1987, genres: ['pop', 'rock'], tracks: [{ name: 'Bad', durationSec: 247 }, { name: 'Smooth Criminal', durationSec: 258 }, { name: 'The Way You Make Me Feel', durationSec: 300 }] },\n];\n```\n\nWrite three functions:\n\n**albumsByGenre(albums)** — groups album titles by genre (an album can appear in multiple genres).\n\n**artistStats(albums)** — returns object per artist with `{ albumCount, totalTracks, avgTrackDuration }`.\n\n**decadeSummary(albums)** — groups by decade string (\"1960s\", \"1980s\") with count and titles.",
      "starterCode": "function albumsByGenre(albums) {\n  // your code here\n}\n\nfunction artistStats(albums) {\n  // your code here\n}\n\nfunction decadeSummary(albums) {\n  // your code here\n}",
      "solution": "function albumsByGenre(albums) {\n  return albums.reduce((acc, album) => {\n    album.genres.forEach(genre => {\n      if (!acc[genre]) acc[genre] = [];\n      acc[genre].push(album.title);\n    });\n    return acc;\n  }, {});\n}\n\nfunction artistStats(albums) {\n  return albums.reduce((acc, album) => {\n    if (!acc[album.artist]) acc[album.artist] = { albumCount: 0, totalTracks: 0, totalDuration: 0 };\n    const stat = acc[album.artist];\n    stat.albumCount++;\n    stat.totalTracks += album.tracks.length;\n    stat.totalDuration += album.tracks.reduce((sum, t) => sum + t.durationSec, 0);\n    return acc;\n  }, {});\n  // Post-process to compute avg\n}\n\nfunction artistStats(albums) {\n  const raw = albums.reduce((acc, album) => {\n    if (!acc[album.artist]) acc[album.artist] = { albumCount: 0, totalTracks: 0, totalDuration: 0 };\n    const stat = acc[album.artist];\n    stat.albumCount++;\n    stat.totalTracks += album.tracks.length;\n    stat.totalDuration += album.tracks.reduce((sum, t) => sum + t.durationSec, 0);\n    return acc;\n  }, {});\n  const result = {};\n  for (const [artist, stat] of Object.entries(raw)) {\n    result[artist] = {\n      albumCount: stat.albumCount,\n      totalTracks: stat.totalTracks,\n      avgTrackDuration: Math.round(stat.totalDuration / stat.totalTracks),\n    };\n  }\n  return result;\n}\n\nfunction decadeSummary(albums) {\n  return albums.reduce((acc, album) => {\n    const decade = Math.floor(album.year / 10) * 10 + 's';\n    if (!acc[decade]) acc[decade] = { count: 0, titles: [] };\n    acc[decade].count++;\n    acc[decade].titles.push(album.title);\n    return acc;\n  }, {});\n}",
      "testRunner": "(code) => {\n  const { albumsByGenre, artistStats, decadeSummary } = new Function(code + '; return { albumsByGenre, artistStats, decadeSummary };')();\n  const albums = [\n    { title: 'Abbey Road', artist: 'The Beatles', year: 1969, genres: ['rock', 'pop'], tracks: [{ name: 'Come Together', durationSec: 259 }, { name: 'Here Comes the Sun', durationSec: 185 }] },\n    { title: 'Thriller', artist: 'Michael Jackson', year: 1982, genres: ['pop', 'funk'], tracks: [{ name: 'Thriller', durationSec: 358 }, { name: 'Beat It', durationSec: 258 }] },\n    { title: 'Let It Be', artist: 'The Beatles', year: 1970, genres: ['rock'], tracks: [{ name: 'Let It Be', durationSec: 243 }, { name: 'Get Back', durationSec: 190 }] },\n    { title: 'Bad', artist: 'Michael Jackson', year: 1987, genres: ['pop', 'rock'], tracks: [{ name: 'Bad', durationSec: 247 }, { name: 'Smooth Criminal', durationSec: 258 }, { name: 'The Way You Make Me Feel', durationSec: 300 }] },\n  ];\n\n  const byGenre = albumsByGenre(albums);\n  const stats = artistStats(albums);\n  const decades = decadeSummary(albums);\n\n  return [\n    { pass: byGenre.rock && byGenre.rock.length === 3, description: 'albumsByGenre: rock has 3 albums', got: byGenre.rock?.length },\n    { pass: byGenre.pop && byGenre.pop.length === 3, description: 'albumsByGenre: pop has 3 albums', got: byGenre.pop?.length },\n    { pass: byGenre.funk && byGenre.funk.length === 1, description: 'albumsByGenre: funk has 1 album', got: byGenre.funk?.length },\n    { pass: stats['The Beatles'] && stats['The Beatles'].albumCount === 2, description: 'artistStats: Beatles have 2 albums', got: stats['The Beatles']?.albumCount },\n    { pass: stats['The Beatles'] && stats['The Beatles'].totalTracks === 4, description: 'artistStats: Beatles have 4 tracks', got: stats['The Beatles']?.totalTracks },\n    { pass: stats['Michael Jackson'] && stats['Michael Jackson'].avgTrackDuration === Math.round((358+258+247+258+300)/5), description: 'artistStats: MJ avg duration correct', got: stats['Michael Jackson']?.avgTrackDuration },\n    { pass: decades['1960s'] && decades['1960s'].count === 1, description: 'decadeSummary: 1960s has 1 album', got: decades['1960s']?.count },\n    { pass: decades['1980s'] && decades['1980s'].count === 2, description: 'decadeSummary: 1980s has 2 albums', got: decades['1980s']?.count },\n  ];\n}",
      "hint": "albumsByGenre: reduce with nested forEach over genres (many-to-many). artistStats: reduce to accumulate counts/durations, then a second pass to compute averages. decadeSummary: Math.floor(year/10)*10 gives the decade number.",
      "resources": [
        {
          "label": "MDN: Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        }
      ],
      "hints": [
        "What array method removes and returns the last element from an array?",
        "albumsByGenre: reduce with nested forEach over genres (many-to-many). artistStats: reduce to accumulate counts/durations, then a second pass to compute averages. decadeSummary: Math.floor(year/10)*10 gives the decade number.",
        "Key method(s): `reduce`, `forEach`, `entries`. Use a loop to iterate, then return the accumulated result."
      ]
    },
    {
      "id": 288,
      "title": "Responsive Dashboard Layout",
      "type": "html-css",
      "tier": 4,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "html",
        "css",
        "grid",
        "flexbox",
        "responsive",
        "layout",
        "tier4"
      ],
      "description": "Build a responsive dashboard with CSS Grid areas, Flexbox nav, and a media query breakpoint.",
      "instructions": "Build a dashboard layout that adapts from mobile to desktop.\n\n**Required HTML structure:**\n- A `.dashboard` container with 4 children:\n  - `.sidebar` — vertical navigation with at least 3 `<a>` links\n  - `.header` — page title bar with an `<h1>`\n  - `.main-content` — primary content area\n  - `.stats-panel` — secondary panel\n\n**Required CSS:**\n1. `.dashboard` uses CSS Grid with `grid-template-areas`\n2. Mobile (default): single column — areas stack vertically: header, sidebar, main, stats\n3. Desktop (min-width: 768px): two-column layout:\n   - sidebar takes left column, full height\n   - header spans top-right\n   - main-content fills center-right\n   - stats-panel fills bottom-right\n4. `.sidebar` uses Flexbox with `flex-direction: column`\n5. Use at least one CSS custom property (variable) for spacing or color\n6. Add a visible border on `.dashboard` children for visual debugging",
      "starterCode": "",
      "solution": "<div class=\"dashboard\">\n  <nav class=\"sidebar\">\n    <a href=\"#\">Home</a>\n    <a href=\"#\">Analytics</a>\n    <a href=\"#\">Settings</a>\n  </nav>\n  <header class=\"header\">\n    <h1>Dashboard</h1>\n  </header>\n  <main class=\"main-content\">\n    <p>Main content area</p>\n  </main>\n  <aside class=\"stats-panel\">\n    <p>Statistics panel</p>\n  </aside>\n</div>\n\n<style>\n  :root {\n    --spacing: 16px;\n    --border-color: #334155;\n  }\n\n  .dashboard {\n    display: grid;\n    grid-template-areas:\n      \"header\"\n      \"sidebar\"\n      \"main\"\n      \"stats\";\n    gap: var(--spacing);\n    min-height: 100vh;\n  }\n\n  .sidebar {\n    grid-area: sidebar;\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n    padding: var(--spacing);\n    border: 1px solid var(--border-color);\n  }\n\n  .header {\n    grid-area: header;\n    padding: var(--spacing);\n    border: 1px solid var(--border-color);\n  }\n\n  .main-content {\n    grid-area: main;\n    padding: var(--spacing);\n    border: 1px solid var(--border-color);\n  }\n\n  .stats-panel {\n    grid-area: stats;\n    padding: var(--spacing);\n    border: 1px solid var(--border-color);\n  }\n\n  @media (min-width: 768px) {\n    .dashboard {\n      grid-template-columns: 200px 1fr;\n      grid-template-areas:\n        \"sidebar header\"\n        \"sidebar main\"\n        \"sidebar stats\";\n    }\n  }\n</style>",
      "testRunner": "",
      "testCases": [
        {
          "query": ".dashboard",
          "assertion": "exists",
          "description": ".dashboard container exists"
        },
        {
          "query": ".sidebar",
          "assertion": "exists",
          "description": ".sidebar exists"
        },
        {
          "query": ".header",
          "assertion": "exists",
          "description": ".header exists"
        },
        {
          "query": ".main-content",
          "assertion": "exists",
          "description": ".main-content exists"
        },
        {
          "query": ".stats-panel",
          "assertion": "exists",
          "description": ".stats-panel exists"
        },
        {
          "query": ".dashboard",
          "assertion": "equals",
          "property": "display",
          "value": "grid",
          "description": ".dashboard uses CSS Grid"
        },
        {
          "query": ".sidebar",
          "assertion": "equals",
          "property": "display",
          "value": "flex",
          "description": ".sidebar uses Flexbox"
        },
        {
          "query": ".sidebar",
          "assertion": "equals",
          "property": "flex-direction",
          "value": "column",
          "description": ".sidebar flex-direction is column"
        },
        {
          "query": ".sidebar a",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "Sidebar has at least 3 links"
        },
        {
          "query": ".header h1",
          "assertion": "exists",
          "description": "Header contains an h1"
        },
        {
          "query": ".dashboard",
          "assertion": "sourceMatch",
          "value": "grid-template-areas",
          "description": "Uses grid-template-areas"
        },
        {
          "query": ".dashboard",
          "assertion": "sourceMatch",
          "value": "--",
          "description": "Uses CSS custom properties"
        }
      ],
      "hint": "Use grid-template-areas to name regions (\"header\", \"sidebar\", \"main\", \"stats\"). On mobile: all areas in one column. In the @media query, switch to two columns with the sidebar spanning all rows on the left.",
      "resources": [
        {
          "label": "MDN: CSS Grid Layout",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "Use grid-template-areas to name regions (\"header\", \"sidebar\", \"main\", \"stats\"). On mobile: all areas in one column. In the @media query, switch to two columns with the sidebar spanning all rows on the left.",
        "HTML: Key elements: `<nav>`, `<a>`, `<header>`, `<h1>`. Important attributes: `href`. CSS: Key properties: `--spacing`, `--border-color`, `display`, `grid-template-areas`."
      ]
    },
    {
      "id": 289,
      "title": "throttle",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "higher-order"
      ],
      "tags": [
        "functions",
        "higher-order",
        "closure",
        "timing",
        "tier4"
      ],
      "description": "Implement a throttle function that limits how often a function can fire.",
      "instructions": "Write a function:\n\n**throttle(fn, delay)** that returns a throttled version of `fn`.\n\n- First call executes immediately\n- Subsequent calls within the `delay` window are ignored\n- After the delay passes, the next call goes through\n- The throttled function preserves `this` context and arguments\n\n```js\nlet count = 0;\nconst inc = throttle(() => count++, 100);\n\ninc(); // count → 1 (immediate)\ninc(); // ignored (within 100ms)\ninc(); // ignored\n// wait 100ms...\ninc(); // count → 2 (delay passed)\n```",
      "starterCode": "function throttle(fn, delay) {\n  // your code here — return a throttled function\n}",
      "solution": "function throttle(fn, delay) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= delay) {\n      lastCall = now;\n      return fn.apply(this, args);\n    }\n  };\n}",
      "testRunner": "(code) => {\n  const throttle = new Function(code + '; return throttle;')();\n  let count = 0;\n  const inc = throttle(() => ++count, 50);\n\n  inc(); // immediate\n  const afterFirst = count;\n  inc(); // should be throttled\n  inc(); // should be throttled\n  const afterThrottled = count;\n\n  return [\n    { pass: afterFirst === 1, description: 'First call executes immediately', got: afterFirst },\n    { pass: afterThrottled === 1, description: 'Subsequent calls within delay are ignored', got: afterThrottled },\n    { pass: (() => { let val = ''; const fn = throttle(function(x) { val = x; }, 50); fn('hello'); return val === 'hello'; })(), description: 'Arguments are passed through', got: (() => { let val = ''; const fn = throttle(function(x) { val = x; }, 50); fn('hello'); return val; })() },\n    { pass: (() => { let ctx = null; const obj = { name: 'test', fn: throttle(function() { ctx = this.name; }, 50) }; obj.fn(); return ctx === 'test'; })(), description: 'Preserves this context', got: (() => { let ctx = null; const obj = { name: 'test', fn: throttle(function() { ctx = this.name; }, 50) }; obj.fn(); return ctx; })() },\n  ];\n}",
      "hint": "Track the timestamp of the last call. On each invocation, check if Date.now() - lastCall >= delay. If yes, call fn and update lastCall. Use fn.apply(this, args) to preserve context.",
      "resources": [
        {
          "label": "MDN: Function.prototype.apply()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ],
      "hints": [
        "Start by thinking about function composition and higher-order functions.",
        "Track the timestamp of the last call. On each invocation, check if Date.now() - lastCall >= delay. If yes, call fn and update lastCall. Use fn.apply(this, args) to preserve context.",
        "Key method(s): `now`, `apply`."
      ]
    },
    {
      "id": 290,
      "title": "Iterable Range",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "es6",
        "iterator",
        "symbol",
        "protocol",
        "class",
        "tier4"
      ],
      "description": "Build a Range class implementing the iterator protocol — usable with for...of and spread.",
      "instructions": "Create a **Range** class:\n\n**Constructor:** `(start, end, step = 1)`\n\n**Properties/Methods:**\n- `[Symbol.iterator]()` — makes Range iterable. Produces values from start to end (inclusive), stepping by step.\n- `toArray()` — returns all values as an array\n- `includes(value)` — returns true if value is in the range\n- `get length` — returns the number of values in the range\n\n```js\nconst r = new Range(1, 5);\n[...r];           // [1, 2, 3, 4, 5]\nr.toArray();      // [1, 2, 3, 4, 5]\nr.includes(3);    // true\nr.includes(6);    // false\nr.length;         // 5\n\nconst evens = new Range(0, 10, 2);\n[...evens];       // [0, 2, 4, 6, 8, 10]\nevens.length;     // 6\n\nfor (const n of new Range(3, 1, -1)) {\n  console.log(n); // 3, 2, 1\n}\n```",
      "starterCode": "class Range {\n  constructor(start, end, step = 1) {\n    // your code here\n  }\n\n  [Symbol.iterator]() {\n    // your code here — return { next() { ... } }\n  }\n\n  toArray() {\n    // your code here\n  }\n\n  includes(value) {\n    // your code here\n  }\n\n  get length() {\n    // your code here\n  }\n}",
      "solution": "class Range {\n  constructor(start, end, step = 1) {\n    this.start = start;\n    this.end = end;\n    this.step = step;\n  }\n\n  [Symbol.iterator]() {\n    let current = this.start;\n    const end = this.end;\n    const step = this.step;\n    return {\n      next() {\n        if ((step > 0 && current <= end) || (step < 0 && current >= end)) {\n          const value = current;\n          current += step;\n          return { value, done: false };\n        }\n        return { done: true };\n      },\n    };\n  }\n\n  toArray() {\n    return [...this];\n  }\n\n  includes(value) {\n    if (this.step > 0) {\n      return value >= this.start && value <= this.end && (value - this.start) % this.step === 0;\n    }\n    return value <= this.start && value >= this.end && (this.start - value) % Math.abs(this.step) === 0;\n  }\n\n  get length() {\n    return Math.max(0, Math.floor((this.end - this.start) / this.step) + 1);\n  }\n}",
      "testRunner": "(code) => {\n  const Range = new Function(code + '; return Range;')();\n  const r = new Range(1, 5);\n  const evens = new Range(0, 10, 2);\n  const desc = new Range(3, 1, -1);\n\n  return [\n    { pass: JSON.stringify([...r]) === '[1,2,3,4,5]', description: 'Spread: [1,2,3,4,5]', got: JSON.stringify([...r]) },\n    { pass: r.length === 5, description: 'length is 5', got: r.length },\n    { pass: r.includes(3) && !r.includes(6), description: 'includes works', got: r.includes(3) + ', ' + r.includes(6) },\n    { pass: JSON.stringify([...evens]) === '[0,2,4,6,8,10]', description: 'Step 2: [0,2,4,6,8,10]', got: JSON.stringify([...evens]) },\n    { pass: evens.length === 6, description: 'Step 2 length is 6', got: evens.length },\n    { pass: JSON.stringify([...desc]) === '[3,2,1]', description: 'Descending: [3,2,1]', got: JSON.stringify([...desc]) },\n    { pass: JSON.stringify(r.toArray()) === '[1,2,3,4,5]', description: 'toArray returns same as spread', got: JSON.stringify(r.toArray()) },\n  ];\n}",
      "hint": "[Symbol.iterator]() returns an object with a next() method. next() returns { value, done }. Track a `current` variable in the closure. Check direction (step > 0 or < 0) to know when to stop.",
      "resources": [
        {
          "label": "MDN: Iteration Protocols",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"
        }
      ],
      "hints": [
        "The `Math.abs` method will be helpful here.",
        "[Symbol.iterator]() returns an object with a next() method. next() returns { value, done }. Track a `current` variable in the closure. Check direction (step > 0 or < 0) to know when to stop.",
        "Key method(s): `abs`, `max`, `floor`. The function should return an array."
      ]
    },
    {
      "id": 291,
      "title": "Task Management System: Task + Column + Board + User",
      "type": "js",
      "tier": 5,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "oop",
        "tier5",
        "composition",
        "multi-class",
        "state-machine",
        "kanban"
      ],
      "description": "Build a Kanban task system with 4 classes — WIP limits, status transitions, and cross-class stats.",
      "instructions": "Build a Kanban-style task management system with four classes.\n\n**Task(title, priority):**\n- Properties: `title`, `priority` (\"low\"/\"medium\"/\"high\"), `status` (starts \"todo\"), `assignee` (null)\n- `assign(user)` — sets assignee to user.name\n\n**Column(name, limit):**\n- `addTask(task)` — adds task if under WIP limit, returns true/false\n- `removeTask(title)` — removes and returns task, or null\n- `get count` — number of tasks\n- `getByPriority(priority)` — returns filtered tasks\n\n**Board(name):**\n- `addColumn(column)` — adds a column\n- `moveTask(title, fromCol, toCol)` — moves task between columns. If toCol is \"Done\", set task.status to \"done\". Returns true/false.\n- `get allTasks` — flat array of all tasks across all columns\n- `getTasksByUser(name)` — returns all tasks assigned to user\n- `get completionRate` — % of tasks with status \"done\" (0-100, rounded)\n\n**User(name):**\n- `get taskCount` — counts tasks assigned to this user across all columns on a board\n\n```js\nconst board = new Board('Sprint 1');\nconst todo = new Column('Todo', 5);\nconst done = new Column('Done', 10);\nboard.addColumn(todo);\nboard.addColumn(done);\n\nconst task = new Task('Fix bug', 'high');\ntodo.addTask(task);  // true\nboard.moveTask('Fix bug', 'Todo', 'Done'); // true, task.status → 'done'\nboard.completionRate; // 100\n```",
      "starterCode": "",
      "solution": "class Task {\n  constructor(title, priority) {\n    this.title = title;\n    this.priority = priority;\n    this.status = 'todo';\n    this.assignee = null;\n  }\n\n  assign(user) {\n    this.assignee = user.name;\n  }\n}\n\nclass Column {\n  constructor(name, limit) {\n    this.name = name;\n    this.limit = limit;\n    this.tasks = [];\n  }\n\n  addTask(task) {\n    if (this.tasks.length >= this.limit) return false;\n    this.tasks.push(task);\n    return true;\n  }\n\n  removeTask(title) {\n    const idx = this.tasks.findIndex(t => t.title === title);\n    if (idx === -1) return null;\n    return this.tasks.splice(idx, 1)[0];\n  }\n\n  get count() {\n    return this.tasks.length;\n  }\n\n  getByPriority(priority) {\n    return this.tasks.filter(t => t.priority === priority);\n  }\n}\n\nclass Board {\n  constructor(name) {\n    this.name = name;\n    this.columns = [];\n  }\n\n  addColumn(column) {\n    this.columns.push(column);\n  }\n\n  moveTask(title, fromCol, toCol) {\n    const from = this.columns.find(c => c.name === fromCol);\n    const to = this.columns.find(c => c.name === toCol);\n    if (!from || !to) return false;\n    const task = from.removeTask(title);\n    if (!task) return false;\n    if (!to.addTask(task)) {\n      from.addTask(task);\n      return false;\n    }\n    if (toCol === 'Done') task.status = 'done';\n    return true;\n  }\n\n  get allTasks() {\n    return this.columns.flatMap(c => c.tasks);\n  }\n\n  getTasksByUser(name) {\n    return this.allTasks.filter(t => t.assignee === name);\n  }\n\n  get completionRate() {\n    const all = this.allTasks;\n    if (all.length === 0) return 0;\n    const done = all.filter(t => t.status === 'done').length;\n    return Math.round((done / all.length) * 100);\n  }\n}\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n\n  get taskCount() {\n    return 0; // needs board reference — simplified\n  }\n}",
      "testRunner": "(code) => {\n  const { Task, Column, Board, User } = new Function(code + '; return { Task, Column, Board, User };')();\n\n  const board = new Board('Sprint 1');\n  const todo = new Column('Todo', 3);\n  const inProgress = new Column('In Progress', 2);\n  const done = new Column('Done', 10);\n  board.addColumn(todo);\n  board.addColumn(inProgress);\n  board.addColumn(done);\n\n  const t1 = new Task('Fix bug', 'high');\n  const t2 = new Task('Add feature', 'medium');\n  const t3 = new Task('Write docs', 'low');\n  const t4 = new Task('Overflow', 'low');\n  const user = new User('Alex');\n  t1.assign(user);\n  t2.assign(user);\n\n  todo.addTask(t1);\n  todo.addTask(t2);\n  todo.addTask(t3);\n  const overflow = todo.addTask(t4);\n\n  return [\n    { pass: t1.status === 'todo' && t1.priority === 'high', description: 'Task has status and priority', got: t1.status + '/' + t1.priority },\n    { pass: t1.assignee === 'Alex', description: 'Task.assign sets assignee', got: t1.assignee },\n    { pass: todo.count === 3, description: 'Column tracks count', got: todo.count },\n    { pass: overflow === false, description: 'Column rejects over WIP limit', got: overflow },\n    { pass: todo.getByPriority('high').length === 1, description: 'getByPriority filters', got: todo.getByPriority('high').length },\n    { pass: board.moveTask('Fix bug', 'Todo', 'Done') === true, description: 'moveTask succeeds', got: true },\n    { pass: t1.status === 'done', description: 'Moving to Done sets status', got: t1.status },\n    { pass: board.allTasks.length === 3, description: 'allTasks returns all tasks', got: board.allTasks.length },\n    { pass: board.getTasksByUser('Alex').length === 2, description: 'getTasksByUser finds assigned tasks', got: board.getTasksByUser('Alex').length },\n    { pass: board.completionRate === Math.round((1/3) * 100), description: 'completionRate computes correctly', got: board.completionRate },\n    { pass: board.moveTask('Ghost', 'Todo', 'Done') === false, description: 'moveTask returns false for missing task', got: false },\n  ];\n}",
      "hint": "Task is a plain data class. Column manages an array with a capacity limit. Board owns columns and delegates to them — moveTask removes from source and adds to destination. Use flatMap for allTasks.",
      "resources": [
        {
          "label": "MDN: Array",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
          "description": "JavaScript Array reference"
        },
        {
          "label": "MDN: Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter",
          "description": "The filter method"
        },
        {
          "label": "MDN: Object",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
          "description": "JavaScript Object reference"
        }
      ],
      "hints": [
        "Consider how `splice` works.",
        "Task is a plain data class. Column manages an array with a capacity limit. Board owns columns and delegates to them — moveTask removes from source and adds to destination. Use flatMap for allTasks.",
        "Key method(s): `findIndex`, `splice`, `filter`. Filter elements that match your condition. The function should return a boolean."
      ]
    },
    {
      "id": 292,
      "title": "Event Scheduler: Event + Calendar + Attendee + Venue",
      "type": "js",
      "tier": 5,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "oop",
        "tier5",
        "composition",
        "multi-class",
        "scheduling"
      ],
      "description": "Build a scheduling system with time-overlap detection, venue capacity, and cascade cancellation.",
      "instructions": "Build four classes for event scheduling.\n\n**Venue(name, capacity):**\n- `book(event)` — stores event. Returns false if time overlaps existing booking.\n- `isAvailable(date, startHour, endHour)` — checks for conflicts\n- `cancelBooking(eventName)` — removes booking\n\n**Attendee(name):**\n- `rsvp(event)` — adds to personal schedule. Returns false if personal conflict.\n- `cancel(eventName)` — removes from schedule\n- `get schedule` — sorted array of events by date then startHour\n\n**Event(name, date, startHour, endHour, venue):**\n- `addAttendee(attendee)` — adds if venue not full. Returns true/false.\n- `removeAttendee(name)` — removes attendee\n- `get isFull` — attendees.length >= venue.capacity\n- `get duration` — endHour - startHour\n- `get attendeeCount`\n\n**Calendar(name):**\n- `addEvent(event)` — stores event\n- `cancelEvent(eventName)` — removes event, cancels venue booking, removes from all attendees\n- `getEventsOnDate(date)` — filters by date\n- `getEventsByVenue(venueName)` — filters by venue\n\nTime overlap: events on the same date at the same venue overlap if their hour ranges intersect (e.g., [10,12] and [11,14] overlap).\n\n```js\nconst venue = new Venue('Room A', 2);\nconst e1 = new Event('Standup', '2024-01-15', 10, 11, venue);\nvenue.book(e1);              // true\nvenue.isAvailable('2024-01-15', 10, 12); // false (overlaps)\nvenue.isAvailable('2024-01-15', 11, 13); // true (after e1)\n```",
      "starterCode": "",
      "solution": "class Venue {\n  constructor(name, capacity) {\n    this.name = name;\n    this.capacity = capacity;\n    this.bookings = [];\n  }\n\n  isAvailable(date, startHour, endHour) {\n    return !this.bookings.some(b => b.date === date && b.startHour < endHour && b.endHour > startHour);\n  }\n\n  book(event) {\n    if (!this.isAvailable(event.date, event.startHour, event.endHour)) return false;\n    this.bookings.push(event);\n    return true;\n  }\n\n  cancelBooking(eventName) {\n    this.bookings = this.bookings.filter(b => b.name !== eventName);\n  }\n}\n\nclass Attendee {\n  constructor(name) {\n    this.name = name;\n    this._events = [];\n  }\n\n  rsvp(event) {\n    const conflict = this._events.some(e => e.date === event.date && e.startHour < event.endHour && e.endHour > event.startHour);\n    if (conflict) return false;\n    this._events.push(event);\n    return true;\n  }\n\n  cancel(eventName) {\n    this._events = this._events.filter(e => e.name !== eventName);\n  }\n\n  get schedule() {\n    return [...this._events].sort((a, b) => a.date < b.date ? -1 : a.date > b.date ? 1 : a.startHour - b.startHour);\n  }\n}\n\nclass Event {\n  constructor(name, date, startHour, endHour, venue) {\n    this.name = name;\n    this.date = date;\n    this.startHour = startHour;\n    this.endHour = endHour;\n    this.venue = venue;\n    this.attendees = [];\n  }\n\n  addAttendee(attendee) {\n    if (this.isFull) return false;\n    this.attendees.push(attendee);\n    return true;\n  }\n\n  removeAttendee(name) {\n    this.attendees = this.attendees.filter(a => a.name !== name);\n  }\n\n  get isFull() {\n    return this.attendees.length >= this.venue.capacity;\n  }\n\n  get duration() {\n    return this.endHour - this.startHour;\n  }\n\n  get attendeeCount() {\n    return this.attendees.length;\n  }\n}\n\nclass Calendar {\n  constructor(name) {\n    this.name = name;\n    this.events = [];\n  }\n\n  addEvent(event) {\n    this.events.push(event);\n  }\n\n  cancelEvent(eventName) {\n    const event = this.events.find(e => e.name === eventName);\n    if (!event) return;\n    event.venue.cancelBooking(eventName);\n    event.attendees.forEach(a => a.cancel(eventName));\n    this.events = this.events.filter(e => e.name !== eventName);\n  }\n\n  getEventsOnDate(date) {\n    return this.events.filter(e => e.date === date);\n  }\n\n  getEventsByVenue(venueName) {\n    return this.events.filter(e => e.venue.name === venueName);\n  }\n}",
      "testRunner": "(code) => {\n  const { Venue, Attendee, Event, Calendar } = new Function(code + '; return { Venue, Attendee, Event, Calendar };')();\n\n  const venue = new Venue('Room A', 2);\n  const e1 = new Event('Standup', '2024-01-15', 10, 11, venue);\n  const e2 = new Event('Workshop', '2024-01-15', 11, 13, venue);\n  const e3 = new Event('Conflict', '2024-01-15', 10, 12, venue);\n  venue.book(e1);\n  venue.book(e2);\n\n  const alice = new Attendee('Alice');\n  const bob = new Attendee('Bob');\n  e1.addAttendee(alice);\n  e1.addAttendee(bob);\n  alice.rsvp(e1);\n\n  const cal = new Calendar('Q1');\n  cal.addEvent(e1);\n  cal.addEvent(e2);\n\n  return [\n    { pass: venue.isAvailable('2024-01-15', 10, 11) === false, description: 'Venue detects overlap', got: false },\n    { pass: venue.isAvailable('2024-01-15', 13, 14) === true, description: 'Venue allows non-overlapping', got: true },\n    { pass: venue.book(e3) === false, description: 'Venue rejects overlapping booking', got: false },\n    { pass: e1.attendeeCount === 2, description: 'Event tracks attendees', got: e1.attendeeCount },\n    { pass: e1.isFull === true, description: 'Event.isFull when at capacity', got: e1.isFull },\n    { pass: e1.duration === 1, description: 'Event.duration computed', got: e1.duration },\n    { pass: alice.rsvp(e2) === true, description: 'Attendee RSVP non-conflicting', got: true },\n    { pass: alice.schedule.length === 2, description: 'Attendee schedule has 2 events', got: alice.schedule.length },\n    { pass: cal.getEventsOnDate('2024-01-15').length === 2, description: 'Calendar filters by date', got: cal.getEventsOnDate('2024-01-15').length },\n    { pass: (() => { cal.cancelEvent('Standup'); return cal.events.length === 1 && venue.bookings.length === 1; })(), description: 'cancelEvent cascades to venue', got: (() => { return cal.events.length + '/' + venue.bookings.length; })() },\n  ];\n}",
      "hint": "Overlap detection: two time ranges [s1,e1] and [s2,e2] overlap if s1 < e2 AND e1 > s2. cancelEvent must cascade: remove from venue bookings AND from each attendee's schedule.",
      "resources": [
        {
          "label": "MDN: Array",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
          "description": "JavaScript Array reference"
        },
        {
          "label": "MDN: Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter",
          "description": "The filter method"
        },
        {
          "label": "MDN: Functions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",
          "description": "JavaScript functions guide"
        }
      ],
      "hints": [
        "When a book is checked out, what changes on the book and on the library — and what should happen if it is already checked out?",
        "Overlap detection: two time ranges [s1,e1] and [s2,e2] overlap if s1 < e2 AND e1 > s2. cancelEvent must cascade: remove from venue bookings AND from each attendee's schedule.",
        "Key method(s): `some`, `isAvailable`, `filter`. Filter elements that match your condition. The function should return a boolean."
      ]
    },
    {
      "id": 293,
      "title": "Data Pipeline Builder",
      "type": "js",
      "tier": 5,
      "category": [
        "functions",
        "higher-order"
      ],
      "tags": [
        "functions",
        "higher-order",
        "tier5",
        "composition",
        "data-transformation",
        "functional"
      ],
      "description": "Build a lazy data pipeline with chainable map, filter, groupBy, sortBy, take, and execute.",
      "instructions": "Build a **Pipeline** class with lazy evaluation.\n\n**Pipeline.from(data)** — static factory, sets source data\n\n**Chainable methods** (each returns the Pipeline for chaining, does NOT execute yet):\n- `.map(fn)` — transform each element\n- `.filter(fn)` — keep elements where fn returns true\n- `.sortBy(fn)` — sort by comparator\n- `.take(n)` — limit to first N results\n- `.groupBy(fn)` — group into object (fn returns the group key)\n\n**Terminal methods:**\n- `.execute()` — runs the pipeline and returns results\n- `.count()` — runs pipeline and returns count\n- `.sum(key)` — runs pipeline and sums a numeric property\n\nSteps are stored and only run on terminal methods.\n\n```js\nconst data = [\n  { name: 'Alice', age: 30, dept: 'Eng' },\n  { name: 'Bob', age: 25, dept: 'Eng' },\n  { name: 'Carol', age: 35, dept: 'Sales' },\n];\n\nPipeline.from(data)\n  .filter(p => p.dept === 'Eng')\n  .map(p => p.name)\n  .execute(); // ['Alice', 'Bob']\n\nPipeline.from(data)\n  .sortBy((a, b) => b.age - a.age)\n  .take(2)\n  .execute(); // [Carol(35), Alice(30)]\n\nPipeline.from(data)\n  .groupBy(p => p.dept)\n  .execute(); // { Eng: [Alice, Bob], Sales: [Carol] }\n\nPipeline.from(data)\n  .filter(p => p.dept === 'Eng')\n  .sum('age'); // 55\n```",
      "starterCode": "class Pipeline {\n  constructor(data) {\n    this._data = data;\n    this._steps = [];\n  }\n\n  static from(data) {\n    return new Pipeline(data);\n  }\n\n  // Add chainable methods: map, filter, sortBy, take, groupBy\n  // Add terminal methods: execute, count, sum\n}",
      "solution": "class Pipeline {\n  constructor(data) {\n    this._data = data;\n    this._steps = [];\n  }\n\n  static from(data) {\n    return new Pipeline([...data]);\n  }\n\n  map(fn) {\n    this._steps.push({ type: 'map', fn });\n    return this;\n  }\n\n  filter(fn) {\n    this._steps.push({ type: 'filter', fn });\n    return this;\n  }\n\n  sortBy(fn) {\n    this._steps.push({ type: 'sortBy', fn });\n    return this;\n  }\n\n  take(n) {\n    this._steps.push({ type: 'take', n });\n    return this;\n  }\n\n  groupBy(fn) {\n    this._steps.push({ type: 'groupBy', fn });\n    return this;\n  }\n\n  execute() {\n    let result = [...this._data];\n    for (const step of this._steps) {\n      switch (step.type) {\n        case 'map': result = result.map(step.fn); break;\n        case 'filter': result = result.filter(step.fn); break;\n        case 'sortBy': result = [...result].sort(step.fn); break;\n        case 'take': result = result.slice(0, step.n); break;\n        case 'groupBy': {\n          const groups = {};\n          for (const item of result) {\n            const key = step.fn(item);\n            if (!groups[key]) groups[key] = [];\n            groups[key].push(item);\n          }\n          return groups;\n        }\n      }\n    }\n    return result;\n  }\n\n  count() {\n    const result = this.execute();\n    return Array.isArray(result) ? result.length : Object.keys(result).length;\n  }\n\n  sum(key) {\n    const result = this.execute();\n    return result.reduce((s, item) => s + (item[key] || 0), 0);\n  }\n}",
      "testRunner": "(code) => {\n  const Pipeline = new Function(code + '; return Pipeline;')();\n  const data = [\n    { name: 'Alice', age: 30, dept: 'Eng' },\n    { name: 'Bob', age: 25, dept: 'Eng' },\n    { name: 'Carol', age: 35, dept: 'Sales' },\n    { name: 'Dave', age: 28, dept: 'Sales' },\n  ];\n\n  const names = Pipeline.from(data).filter(p => p.dept === 'Eng').map(p => p.name).execute();\n  const top2 = Pipeline.from(data).sortBy((a, b) => b.age - a.age).take(2).execute();\n  const groups = Pipeline.from(data).groupBy(p => p.dept).execute();\n  const engAgeSum = Pipeline.from(data).filter(p => p.dept === 'Eng').sum('age');\n  const cnt = Pipeline.from(data).filter(p => p.age > 27).count();\n\n  return [\n    { pass: JSON.stringify(names) === JSON.stringify(['Alice', 'Bob']), description: 'filter + map pipeline', got: JSON.stringify(names) },\n    { pass: top2.length === 2 && top2[0].name === 'Carol', description: 'sortBy + take pipeline', got: top2.map(p => p.name).join(', ') },\n    { pass: groups.Eng && groups.Eng.length === 2, description: 'groupBy: Eng has 2', got: groups.Eng?.length },\n    { pass: groups.Sales && groups.Sales.length === 2, description: 'groupBy: Sales has 2', got: groups.Sales?.length },\n    { pass: engAgeSum === 55, description: 'sum(\"age\") after filter = 55', got: engAgeSum },\n    { pass: cnt === 3, description: 'count after filter = 3', got: cnt },\n    { pass: (() => { const d = [{ v: 1 }, { v: 2 }]; Pipeline.from(d).map(x => x.v * 10).execute(); return d[0].v === 1; })(), description: 'Pipeline does not mutate source', got: true },\n  ];\n}",
      "hint": "Store each method call as a step object { type, fn/n }. execute() iterates steps in order, applying each transformation to the running result. groupBy is special — it returns an object instead of an array, so it should be the last array step.",
      "resources": [
        {
          "label": "MDN: Array",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
          "description": "JavaScript Array reference"
        },
        {
          "label": "MDN: Array.prototype.sort()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort",
          "description": "The sort method"
        },
        {
          "label": "MDN: Object",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
          "description": "JavaScript Object reference"
        }
      ],
      "hints": [
        "`map` is a key tool for this exercise.",
        "Store each method call as a step object { type, fn/n }. execute() iterates steps in order, applying each transformation to the running result. groupBy is special — it returns an object instead of an array, so it should be the last array step.",
        "Key method(s): `map`, `filter`, `sort`. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 294,
      "title": "E-Commerce System: Product + Cart + Order + Discount + Store",
      "type": "js",
      "tier": 5,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "oop",
        "tier5",
        "composition",
        "multi-class",
        "e-commerce"
      ],
      "description": "Build a 5-class e-commerce system with inventory, discounts, cart checkout, and order processing.",
      "instructions": "Build five classes:\n\n**Product(name, price, stock):**\n- `reduceStock(qty)` — decrements stock. Returns false if insufficient.\n- `restock(qty)` — adds to stock\n- `get isAvailable` — stock > 0\n\n**Discount(code, type, value):**\n- `type`: \"percent\" or \"fixed\"\n- `apply(subtotal)` — returns discounted total. Percent: `subtotal * (1 - value/100)`. Fixed: `subtotal - value`. Never below 0.\n\n**Cart(owner):**\n- `addItem(product, qty)` — validates stock availability. Returns true/false.\n- `removeItem(productName)` — removes item\n- `get subtotal` — sum of price * qty for all items\n- `applyDiscount(discount)` — stores discount\n- `get total` — subtotal after discount\n- `get itemCount` — total number of items\n\n**Order(cart):**\n- `process()` — reduces stock for each item, marks status \"processed\", returns total. Returns false if already processed.\n- `cancel()` — restores stock, marks \"cancelled\"\n- `get status` — \"pending\"/\"processed\"/\"cancelled\"\n- `get receipt` — formatted string: \"Order for [owner]: [items list]. Total: $[total]\"\n\n**Store(name):**\n- `addProduct(product)`\n- `createCart(owner)` — returns a new Cart\n- `checkout(cart)` — creates and processes an Order, returns it\n- `get revenue` — sum of all processed order totals\n- `get orderCount` — number of processed orders",
      "starterCode": "class Product {\n  constructor(name, price, stock) {\n    // your code here\n  }\n}\n\nclass Discount {\n  constructor(code, type, value) {\n    // your code here\n  }\n}\n\nclass Cart {\n  constructor(owner) {\n    // your code here\n  }\n}\n\nclass Order {\n  constructor(cart) {\n    // your code here\n  }\n}\n\nclass Store {\n  constructor(name) {\n    // your code here\n  }\n}",
      "solution": "class Product {\n  constructor(name, price, stock) {\n    this.name = name;\n    this.price = price;\n    this.stock = stock;\n  }\n  reduceStock(qty) {\n    if (this.stock < qty) return false;\n    this.stock -= qty;\n    return true;\n  }\n  restock(qty) { this.stock += qty; }\n  get isAvailable() { return this.stock > 0; }\n}\n\nclass Discount {\n  constructor(code, type, value) {\n    this.code = code;\n    this.type = type;\n    this.value = value;\n  }\n  apply(subtotal) {\n    if (this.type === 'percent') return Math.max(0, subtotal * (1 - this.value / 100));\n    return Math.max(0, subtotal - this.value);\n  }\n}\n\nclass Cart {\n  constructor(owner) {\n    this.owner = owner;\n    this.items = [];\n    this._discount = null;\n  }\n  addItem(product, qty) {\n    if (product.stock < qty) return false;\n    this.items.push({ product, qty });\n    return true;\n  }\n  removeItem(productName) {\n    this.items = this.items.filter(i => i.product.name !== productName);\n  }\n  get subtotal() {\n    return this.items.reduce((sum, i) => sum + i.product.price * i.qty, 0);\n  }\n  applyDiscount(discount) { this._discount = discount; }\n  get total() {\n    const sub = this.subtotal;\n    return this._discount ? this._discount.apply(sub) : sub;\n  }\n  get itemCount() {\n    return this.items.reduce((sum, i) => sum + i.qty, 0);\n  }\n}\n\nclass Order {\n  constructor(cart) {\n    this.cart = cart;\n    this._status = 'pending';\n    this._total = cart.total;\n    this._items = cart.items.map(i => ({ name: i.product.name, qty: i.qty, price: i.product.price }));\n  }\n  process() {\n    if (this._status !== 'pending') return false;\n    for (const item of this.cart.items) {\n      if (!item.product.reduceStock(item.qty)) return false;\n    }\n    this._status = 'processed';\n    return this._total;\n  }\n  cancel() {\n    if (this._status !== 'processed') return false;\n    for (const item of this.cart.items) {\n      item.product.restock(item.qty);\n    }\n    this._status = 'cancelled';\n    return true;\n  }\n  get status() { return this._status; }\n  get receipt() {\n    const items = this._items.map(i => i.qty + 'x ' + i.name).join(', ');\n    return 'Order for ' + this.cart.owner + ': ' + items + '. Total: $' + this._total.toFixed(2);\n  }\n}\n\nclass Store {\n  constructor(name) {\n    this.name = name;\n    this.products = [];\n    this.orders = [];\n  }\n  addProduct(product) { this.products.push(product); }\n  createCart(owner) { return new Cart(owner); }\n  checkout(cart) {\n    const order = new Order(cart);\n    const result = order.process();\n    if (result !== false) this.orders.push(order);\n    return order;\n  }\n  get revenue() {\n    return this.orders.filter(o => o.status === 'processed').reduce((sum, o) => sum + o._total, 0);\n  }\n  get orderCount() {\n    return this.orders.filter(o => o.status === 'processed').length;\n  }\n}",
      "testRunner": "(code) => {\n  const { Product, Discount, Cart, Order, Store } = new Function(code + '; return { Product, Discount, Cart, Order, Store };')();\n\n  const store = new Store('ShopJS');\n  const laptop = new Product('Laptop', 999.99, 5);\n  const mouse = new Product('Mouse', 29.99, 10);\n  store.addProduct(laptop);\n  store.addProduct(mouse);\n\n  const cart = store.createCart('Alex');\n  cart.addItem(laptop, 1);\n  cart.addItem(mouse, 2);\n  const discount = new Discount('SAVE10', 'percent', 10);\n  cart.applyDiscount(discount);\n\n  const order = store.checkout(cart);\n\n  return [\n    { pass: laptop.isAvailable === true, description: 'Product.isAvailable', got: laptop.isAvailable },\n    { pass: cart.itemCount === 3, description: 'Cart.itemCount = 3', got: cart.itemCount },\n    { pass: Math.abs(cart.subtotal - 1059.97) < 0.01, description: 'Cart.subtotal correct', got: cart.subtotal },\n    { pass: Math.abs(cart.total - 953.973) < 0.01, description: 'Cart.total with 10% discount', got: cart.total },\n    { pass: discount.apply(100) === 90, description: 'Discount: 10% of 100 = 90', got: discount.apply(100) },\n    { pass: new Discount('FLAT', 'fixed', 50).apply(30) === 0, description: 'Discount: fixed never below 0', got: new Discount('FLAT', 'fixed', 50).apply(30) },\n    { pass: order.status === 'processed', description: 'Order processed', got: order.status },\n    { pass: laptop.stock === 4, description: 'Stock reduced after checkout', got: laptop.stock },\n    { pass: store.orderCount === 1, description: 'Store tracks orders', got: store.orderCount },\n    { pass: Math.abs(store.revenue - cart.total) < 0.01, description: 'Store.revenue matches order total', got: store.revenue },\n    { pass: order.receipt.includes('Alex') && order.receipt.includes('Laptop'), description: 'Receipt includes owner and items', got: order.receipt },\n    { pass: (() => { const o2 = new Order(store.createCart('Bob')); return o2.process() !== false; })(), description: 'Empty cart order processes', got: true },\n  ];\n}",
      "hint": "Product manages its own stock. Cart stores { product, qty } pairs. Order snapshots the cart data at creation time. Store.checkout creates an Order and calls process(). Revenue sums processed order totals.",
      "resources": [
        {
          "label": "MDN: String",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
          "description": "JavaScript String reference"
        },
        {
          "label": "MDN: Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce",
          "description": "The reduce method"
        },
        {
          "label": "MDN: Functions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",
          "description": "JavaScript functions guide"
        }
      ],
      "hints": [
        "When an order is placed, what needs to happen to the menu item's availability and the order's total?",
        "Product manages its own stock. Cart stores { product, qty } pairs. Order snapshots the cart data at creation time. Store.checkout creates an Order and calls process(). Revenue sums processed order totals.",
        "Key method(s): `max`, `filter`, `reduce`. Use a loop to iterate, then return the accumulated result. The function should return a boolean."
      ]
    },
    {
      "id": 295,
      "title": "Interactive Form Builder",
      "type": "html-css",
      "tier": 5,
      "category": [
        "html",
        "forms"
      ],
      "tags": [
        "html",
        "css",
        "forms",
        "grid",
        "flexbox",
        "accessibility",
        "responsive",
        "tier5"
      ],
      "description": "Build a complete, accessible, responsive multi-section form with CSS-only validation states.",
      "instructions": "Build a multi-section form layout from scratch.\n\n**Required structure:**\n- A `.form-container` wrapper\n- A `.form-progress` bar with 3 steps (`.step` elements, at least one with `.active` class)\n- Three `.form-section` groups, each with a `<fieldset>` and `<legend>`\n- Each section has at least 2 labeled inputs (use `<label for=\"...\">` + `<input id=\"...\">`)\n- At least one input has `required` attribute\n- A `.form-actions` footer with a `.btn-primary` button\n\n**Required CSS:**\n1. Use CSS Grid or Flexbox for form layout\n2. CSS custom properties for at least 2 values (colors, spacing)\n3. Style `:focus` state with a visible ring/outline\n4. Style inputs with `border` and `padding`\n5. `.btn-primary` has distinct background color and hover state\n6. `.form-progress .step.active` has a highlighted style\n\nFocus on accessibility: proper label associations, fieldset/legend grouping, focus visibility.",
      "starterCode": "",
      "solution": "<div class=\"form-container\">\n  <div class=\"form-progress\">\n    <span class=\"step active\">1. Personal</span>\n    <span class=\"step\">2. Address</span>\n    <span class=\"step\">3. Preferences</span>\n  </div>\n\n  <form>\n    <div class=\"form-section\">\n      <fieldset>\n        <legend>Personal Info</legend>\n        <label for=\"name\">Full Name</label>\n        <input type=\"text\" id=\"name\" required>\n        <label for=\"email\">Email</label>\n        <input type=\"email\" id=\"email\" required>\n      </fieldset>\n    </div>\n\n    <div class=\"form-section\">\n      <fieldset>\n        <legend>Address</legend>\n        <label for=\"street\">Street</label>\n        <input type=\"text\" id=\"street\">\n        <label for=\"city\">City</label>\n        <input type=\"text\" id=\"city\">\n      </fieldset>\n    </div>\n\n    <div class=\"form-section\">\n      <fieldset>\n        <legend>Preferences</legend>\n        <label for=\"color\">Favorite Color</label>\n        <input type=\"text\" id=\"color\">\n        <label for=\"lang\">Language</label>\n        <input type=\"text\" id=\"lang\">\n      </fieldset>\n    </div>\n\n    <div class=\"form-actions\">\n      <button type=\"submit\" class=\"btn-primary\">Submit</button>\n    </div>\n  </form>\n</div>\n\n<style>\n  :root {\n    --primary: #818cf8;\n    --spacing: 16px;\n  }\n\n  .form-container {\n    max-width: 600px;\n    display: flex;\n    flex-direction: column;\n    gap: var(--spacing);\n  }\n\n  .form-progress {\n    display: flex;\n    gap: 8px;\n  }\n\n  .form-progress .step {\n    padding: 8px 16px;\n    border: 1px solid #334155;\n    border-radius: 4px;\n    font-size: 14px;\n  }\n\n  .form-progress .step.active {\n    background-color: var(--primary);\n    color: white;\n    border-color: var(--primary);\n  }\n\n  fieldset {\n    border: 1px solid #334155;\n    border-radius: 8px;\n    padding: var(--spacing);\n  }\n\n  legend {\n    font-weight: bold;\n    padding: 0 8px;\n  }\n\n  label {\n    display: block;\n    margin-top: 12px;\n    margin-bottom: 4px;\n    font-size: 14px;\n  }\n\n  input {\n    width: 100%;\n    padding: 8px 12px;\n    border: 1px solid #334155;\n    border-radius: 4px;\n    box-sizing: border-box;\n  }\n\n  input:focus {\n    outline: 2px solid var(--primary);\n    outline-offset: 2px;\n  }\n\n  .form-actions {\n    margin-top: var(--spacing);\n  }\n\n  .btn-primary {\n    background-color: var(--primary);\n    color: white;\n    padding: 10px 24px;\n    border: none;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 16px;\n  }\n\n  .btn-primary:hover {\n    opacity: 0.9;\n  }\n</style>",
      "testRunner": "",
      "testCases": [
        {
          "query": ".form-container",
          "assertion": "exists",
          "description": ".form-container exists"
        },
        {
          "query": ".form-progress",
          "assertion": "exists",
          "description": ".form-progress exists"
        },
        {
          "query": ".form-progress .step",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "Progress has at least 3 steps"
        },
        {
          "query": ".form-progress .step.active",
          "assertion": "exists",
          "description": "At least one step is active"
        },
        {
          "query": ".form-section",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "3 form sections"
        },
        {
          "query": "fieldset",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "Uses fieldset elements"
        },
        {
          "query": "legend",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "Fieldsets have legends"
        },
        {
          "query": "label[for]",
          "assertion": "countAtLeast",
          "value": 4,
          "description": "At least 4 labeled inputs"
        },
        {
          "query": "input[required]",
          "assertion": "countAtLeast",
          "value": 1,
          "description": "At least 1 required input"
        },
        {
          "query": ".btn-primary",
          "assertion": "exists",
          "description": ".btn-primary button exists"
        },
        {
          "query": ".form-container",
          "assertion": "sourceMatch",
          "value": "--",
          "description": "Uses CSS custom properties"
        }
      ],
      "hint": "Structure: form-container > form-progress + form (with sections + actions). Each section wraps a fieldset with legend. Use label[for] matching input[id]. CSS custom properties go in :root. Focus states use :focus pseudo-class.",
      "resources": [
        {
          "label": "MDN: HTML Forms",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/Forms"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "Structure: form-container > form-progress + form (with sections + actions). Each section wraps a fieldset with legend. Use label[for] matching input[id]. CSS custom properties go in :root. Focus states use :focus pseudo-class.",
        "Key properties: `--primary`, `--spacing`, `max-width`, `display`. Consider selectors like `input:focus`, `.btn-primary:hover`."
      ]
    },
    {
      "id": 296,
      "title": "Async Task Queue: Task + Queue + Worker + Scheduler",
      "type": "js",
      "tier": 5,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "promises",
        "class",
        "tier5",
        "composition",
        "multi-class",
        "queue"
      ],
      "description": "Build an async processing system with priority queue, concurrent workers, and scheduling.",
      "instructions": "Build four classes for async task processing.\n\n**Task(name, fn, priority):**\n- `fn` is an async function. Properties: `status` (\"pending\"/\"running\"/\"completed\"/\"failed\"), `result`, `error`\n\n**Queue():**\n- `enqueue(task)` — inserts by priority (higher number = higher priority)\n- `dequeue()` — removes and returns highest priority task\n- `get size`\n- `get isEmpty`\n\n**Worker(name):**\n- `async process(task)` — runs task.fn(), updates task status/result/error\n- `get isIdle` — true when not processing\n- `get tasksProcessed` — count\n\n**Scheduler(concurrency):**\n- `addTask(name, fn, priority)` — creates Task and enqueues\n- `async start()` — processes all queued tasks using up to `concurrency` workers simultaneously\n- `get stats` — returns `{ completed, failed, pending }`\n\n```js\nconst scheduler = new Scheduler(2);\nscheduler.addTask('fast', async () => 'done', 1);\nscheduler.addTask('slow', async () => {\n  await new Promise(r => setTimeout(r, 50));\n  return 'slow-done';\n}, 2);\nscheduler.addTask('fail', async () => { throw new Error('oops'); }, 1);\n\nawait scheduler.start();\nscheduler.stats; // { completed: 2, failed: 1, pending: 0 }\n```",
      "starterCode": "",
      "solution": "class Task {\n  constructor(name, fn, priority) {\n    this.name = name;\n    this.fn = fn;\n    this.priority = priority;\n    this.status = 'pending';\n    this.result = null;\n    this.error = null;\n  }\n}\n\nclass Queue {\n  constructor() {\n    this._items = [];\n  }\n  enqueue(task) {\n    this._items.push(task);\n    this._items.sort((a, b) => b.priority - a.priority);\n  }\n  dequeue() {\n    return this._items.shift() || null;\n  }\n  get size() { return this._items.length; }\n  get isEmpty() { return this._items.length === 0; }\n}\n\nclass Worker {\n  constructor(name) {\n    this.name = name;\n    this._idle = true;\n    this._processed = 0;\n  }\n  async process(task) {\n    this._idle = false;\n    task.status = 'running';\n    try {\n      task.result = await task.fn();\n      task.status = 'completed';\n    } catch (err) {\n      task.error = err;\n      task.status = 'failed';\n    }\n    this._processed++;\n    this._idle = true;\n  }\n  get isIdle() { return this._idle; }\n  get tasksProcessed() { return this._processed; }\n}\n\nclass Scheduler {\n  constructor(concurrency) {\n    this.concurrency = concurrency;\n    this.queue = new Queue();\n    this.workers = [];\n    this.allTasks = [];\n    for (let i = 0; i < concurrency; i++) {\n      this.workers.push(new Worker('Worker-' + i));\n    }\n  }\n  addTask(name, fn, priority) {\n    const task = new Task(name, fn, priority);\n    this.queue.enqueue(task);\n    this.allTasks.push(task);\n  }\n  async start() {\n    const running = [];\n    while (!this.queue.isEmpty || running.length > 0) {\n      while (running.length < this.concurrency && !this.queue.isEmpty) {\n        const task = this.queue.dequeue();\n        const worker = this.workers.find(w => w.isIdle);\n        if (worker && task) {\n          const p = worker.process(task).then(() => {\n            running.splice(running.indexOf(p), 1);\n          });\n          running.push(p);\n        }\n      }\n      if (running.length > 0) await Promise.race(running);\n    }\n  }\n  get stats() {\n    return {\n      completed: this.allTasks.filter(t => t.status === 'completed').length,\n      failed: this.allTasks.filter(t => t.status === 'failed').length,\n      pending: this.allTasks.filter(t => t.status === 'pending').length,\n    };\n  }\n}",
      "testRunner": "(code) => {\n  const { Task, Queue, Worker, Scheduler } = new Function(code + '; return { Task, Queue, Worker, Scheduler };')();\n\n  // Test Queue\n  const q = new Queue();\n  const t1 = new Task('low', async () => 1, 1);\n  const t2 = new Task('high', async () => 2, 5);\n  q.enqueue(t1);\n  q.enqueue(t2);\n  const dequeued = q.dequeue();\n\n  // Test Worker\n  const workerTest = (async () => {\n    const w = new Worker('W1');\n    const task = new Task('test', async () => 'result', 1);\n    await w.process(task);\n    return task.status === 'completed' && task.result === 'result' && w.tasksProcessed === 1;\n  })();\n\n  // Test Worker error handling\n  const workerErrTest = (async () => {\n    const w = new Worker('W2');\n    const task = new Task('fail', async () => { throw new Error('oops'); }, 1);\n    await w.process(task);\n    return task.status === 'failed' && task.error.message === 'oops';\n  })();\n\n  // Test Scheduler\n  const schedulerTest = (async () => {\n    const s = new Scheduler(2);\n    s.addTask('a', async () => 'a', 1);\n    s.addTask('b', async () => 'b', 2);\n    s.addTask('c', async () => { throw new Error('c'); }, 1);\n    await s.start();\n    const stats = s.stats;\n    return stats.completed === 2 && stats.failed === 1 && stats.pending === 0;\n  })();\n\n  return Promise.all([workerTest, workerErrTest, schedulerTest]).then(([wr, we, sr]) => [\n    { pass: dequeued.name === 'high', description: 'Queue dequeues highest priority first', got: dequeued.name },\n    { pass: q.size === 1, description: 'Queue size after dequeue', got: q.size },\n    { pass: wr, description: 'Worker processes task and sets status/result', got: wr },\n    { pass: we, description: 'Worker handles errors and sets failed status', got: we },\n    { pass: sr, description: 'Scheduler processes all tasks with stats', got: sr },\n    { pass: t1.status === 'pending', description: 'Unprocessed task stays pending', got: t1.status },\n  ]);\n}",
      "hint": "Queue sorts by priority on enqueue. Worker wraps task.fn() in try/catch. Scheduler uses a while loop: fill workers up to concurrency, then await Promise.race(running) to wait for one to finish before filling again.",
      "resources": [
        {
          "label": "MDN: Object",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
          "description": "JavaScript Object reference"
        },
        {
          "label": "MDN: Functions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",
          "description": "JavaScript functions guide"
        },
        {
          "label": "MDN: Classes",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",
          "description": "JavaScript classes reference"
        }
      ],
      "hints": [
        "Consider how `sort` works.",
        "Queue sorts by priority on enqueue. Worker wraps task.fn() in try/catch. Scheduler uses a while loop: fill workers up to concurrency, then await Promise.race(running) to wait for one to finish before filling again.",
        "Key method(s): `sort`, `shift`, `fn`. Use a loop to iterate, then return the accumulated result. The function should return an object."
      ]
    },
    {
      "id": 297,
      "title": "Bubble Sort",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "sorting"
      ],
      "tags": [
        "sorting",
        "algorithms",
        "nested-loops",
        "tier2"
      ],
      "description": "Implement the bubble sort algorithm to sort an array of numbers in ascending order.",
      "instructions": "Write a function called `bubbleSort` that takes an array of numbers and returns a new sorted array in ascending order using the bubble sort algorithm.\n\nBubble sort works by repeatedly stepping through the list, comparing adjacent elements, and swapping them if they are in the wrong order. This pass through the list is repeated until the list is sorted.\n\nExamples:\n  bubbleSort([3, 1, 2])        → [1, 2, 3]\n  bubbleSort([5, 3, 8, 4, 2])  → [2, 3, 4, 5, 8]\n  bubbleSort([])               → []\n  bubbleSort([1])              → [1]",
      "starterCode": "function bubbleSort(arr) {\n\n}",
      "solution": "function bubbleSort(arr) {\n  const result = [...arr];\n  for (let i = 0; i < result.length; i++) {\n    for (let j = 0; j < result.length - 1 - i; j++) {\n      if (result[j] > result[j + 1]) {\n        const temp = result[j];\n        result[j] = result[j + 1];\n        result[j + 1] = temp;\n      }\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return bubbleSort;')();\n  return [\n    { pass: JSON.stringify(fn([3, 1, 2])) === '[1,2,3]', description: 'bubbleSort([3,1,2]) → [1,2,3]', got: JSON.stringify(fn([3, 1, 2])) },\n    { pass: JSON.stringify(fn([5, 3, 8, 4, 2])) === '[2,3,4,5,8]', description: 'bubbleSort([5,3,8,4,2]) → [2,3,4,5,8]', got: JSON.stringify(fn([5, 3, 8, 4, 2])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'bubbleSort([]) → []', got: JSON.stringify(fn([])) },\n    { pass: JSON.stringify(fn([1])) === '[1]', description: 'bubbleSort([1]) → [1]', got: JSON.stringify(fn([1])) },\n    { pass: JSON.stringify(fn([1, 2, 3])) === '[1,2,3]', description: 'already sorted [1,2,3] → [1,2,3]', got: JSON.stringify(fn([1, 2, 3])) },\n    { pass: (() => { const orig = [3,1,2]; fn(orig); return JSON.stringify(orig) === '[3,1,2]'; })(), description: 'does not mutate the original array', got: 'checked' },\n  ];\n}",
      "hint": "Make a copy of the array first. Use two nested loops: the outer loop runs n times, the inner loop compares adjacent elements and swaps them if out of order. After each outer pass, the largest unsorted element \"bubbles\" to the end.",
      "resources": [
        {
          "label": "Visualgo: Sorting",
          "url": "https://visualgo.net/en/sorting"
        },
        {
          "label": "Wikipedia: Bubble Sort",
          "url": "https://en.wikipedia.org/wiki/Bubble_sort"
        }
      ],
      "hints": [
        "If you compare each pair of adjacent elements and swap when they are out of order, what happens after one full pass through the array?",
        "Make a copy of the array first. Use two nested loops: the outer loop runs n times, the inner loop compares adjacent elements and swaps them if out of order. After each outer pass, the largest unsorted element \"bubbles\" to the end.",
        "Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 298,
      "title": "Selection Sort",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "sorting"
      ],
      "tags": [
        "sorting",
        "algorithms",
        "nested-loops",
        "tier2"
      ],
      "description": "Implement the selection sort algorithm to sort an array of numbers in ascending order.",
      "instructions": "Write a function called `selectionSort` that takes an array of numbers and returns a new sorted array in ascending order using the selection sort algorithm.\n\nSelection sort works by finding the minimum element from the unsorted part and placing it at the beginning. It maintains two sub-arrays: the sorted portion (left) and the unsorted portion (right).\n\nExamples:\n  selectionSort([64, 25, 12, 22, 11]) → [11, 12, 22, 25, 64]\n  selectionSort([3, 1, 2])             → [1, 2, 3]\n  selectionSort([])                    → []\n  selectionSort([1])                   → [1]",
      "starterCode": "function selectionSort(arr) {\n\n}",
      "solution": "function selectionSort(arr) {\n  const result = [...arr];\n  for (let i = 0; i < result.length; i++) {\n    let minIdx = i;\n    for (let j = i + 1; j < result.length; j++) {\n      if (result[j] < result[minIdx]) {\n        minIdx = j;\n      }\n    }\n    if (minIdx !== i) {\n      const temp = result[i];\n      result[i] = result[minIdx];\n      result[minIdx] = temp;\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return selectionSort;')();\n  return [\n    { pass: JSON.stringify(fn([64, 25, 12, 22, 11])) === '[11,12,22,25,64]', description: 'selectionSort([64,25,12,22,11]) → [11,12,22,25,64]', got: JSON.stringify(fn([64, 25, 12, 22, 11])) },\n    { pass: JSON.stringify(fn([3, 1, 2])) === '[1,2,3]', description: 'selectionSort([3,1,2]) → [1,2,3]', got: JSON.stringify(fn([3, 1, 2])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'selectionSort([]) → []', got: JSON.stringify(fn([])) },\n    { pass: JSON.stringify(fn([1])) === '[1]', description: 'selectionSort([1]) → [1]', got: JSON.stringify(fn([1])) },\n    { pass: JSON.stringify(fn([5, 5, 5])) === '[5,5,5]', description: 'handles duplicates [5,5,5] → [5,5,5]', got: JSON.stringify(fn([5, 5, 5])) },\n  ];\n}",
      "hint": "Copy the array. For each position i, scan the rest of the array to find the minimum value. Swap it into position i. Repeat for the next position.",
      "resources": [
        {
          "label": "Visualgo: Sorting",
          "url": "https://visualgo.net/en/sorting"
        },
        {
          "label": "Wikipedia: Selection Sort",
          "url": "https://en.wikipedia.org/wiki/Selection_sort"
        }
      ],
      "hints": [
        "What if you found the smallest element first and placed it at position 0, then found the next smallest for position 1, and so on?",
        "Copy the array. For each position i, scan the rest of the array to find the minimum value. Swap it into position i. Repeat for the next position.",
        "Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 299,
      "title": "Sort by Custom Comparator",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "sorting"
      ],
      "tags": [
        "sorting",
        "callbacks",
        "higher-order",
        "tier2"
      ],
      "description": "Sort an array using a custom comparison function, without mutating the original.",
      "instructions": "Write a function called `sortBy` that takes an array and a comparator function, and returns a new sorted array.\n\nThe comparator function works like Array.sort's compare function: it receives two elements (a, b) and returns a negative number if a should come first, positive if b should come first, or 0 if equal.\n\nExamples:\n  sortBy([3, 1, 2], (a, b) => a - b)  → [1, 2, 3]  (ascending)\n  sortBy(['hello', 'hi', 'hey'], (a, b) => a.length - b.length) → ['hi', 'hey', 'hello']\n  sortBy([{ age: 30 }, { age: 20 }], (a, b) => a.age - b.age) → [{ age: 20 }, { age: 30 }]\n  sortBy([], (a, b) => a - b) → []",
      "starterCode": "function sortBy(arr, compareFn) {\n\n}",
      "solution": "function sortBy(arr, compareFn) {\n  return arr.slice().sort(compareFn);\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return sortBy;')();\n  return [\n    { pass: JSON.stringify(fn([3, 1, 2], (a, b) => a - b)) === '[1,2,3]', description: 'sort numbers ascending', got: JSON.stringify(fn([3, 1, 2], (a, b) => a - b)) },\n    { pass: JSON.stringify(fn(['hello', 'hi', 'hey'], (a, b) => a.length - b.length)) === '[\"hi\",\"hey\",\"hello\"]', description: 'sort strings by length', got: JSON.stringify(fn(['hello', 'hi', 'hey'], (a, b) => a.length - b.length)) },\n    { pass: JSON.stringify(fn([{ age: 30 }, { age: 20 }], (a, b) => a.age - b.age)) === '[{\"age\":20},{\"age\":30}]', description: 'sort objects by property', got: JSON.stringify(fn([{ age: 30 }, { age: 20 }], (a, b) => a.age - b.age)) },\n    { pass: JSON.stringify(fn([], (a, b) => a - b)) === '[]', description: 'empty array → []', got: JSON.stringify(fn([], (a, b) => a - b)) },\n    { pass: (() => { const orig = [3,1,2]; fn(orig, (a,b) => a-b); return JSON.stringify(orig) === '[3,1,2]'; })(), description: 'does not mutate original array', got: 'checked' },\n  ];\n}",
      "hint": "Use arr.slice() to create a copy of the array, then call .sort() on the copy with the provided comparator function.",
      "resources": [
        {
          "label": "MDN: Array.prototype.sort()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"
        }
      ],
      "hints": [
        "How does a comparator function tell `sort` whether element A should come before or after element B?",
        "Use arr.slice() to create a copy of the array, then call .sort() on the copy with the provided comparator function.",
        "Key method(s): `slice`, `sort`."
      ]
    },
    {
      "id": 300,
      "title": "Merge Sort",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "sorting"
      ],
      "tags": [
        "sorting",
        "algorithms",
        "recursion",
        "divide-and-conquer",
        "tier3"
      ],
      "description": "Implement the merge sort algorithm — a divide-and-conquer approach to sorting.",
      "instructions": "Write a function called `mergeSort` that takes an array of numbers and returns a new sorted array in ascending order using the merge sort algorithm.\n\nMerge sort works by:\n1. Splitting the array in half recursively until you have single-element arrays\n2. Merging the sorted halves back together\n\nYou may want to write a helper function `merge(left, right)` that merges two sorted arrays into one sorted array.\n\nExamples:\n  mergeSort([38, 27, 43, 3, 9, 82, 10]) → [3, 9, 10, 27, 38, 43, 82]\n  mergeSort([5, 3, 8, 4, 2])             → [2, 3, 4, 5, 8]\n  mergeSort([])                          → []\n  mergeSort([1])                         → [1]\n  mergeSort([2, 1])                      → [1, 2]",
      "starterCode": "function mergeSort(arr) {\n  // Base case: arrays of length 0 or 1 are already sorted\n\n  // Split the array in half\n\n  // Recursively sort each half\n\n  // Merge the two sorted halves\n}",
      "solution": "function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i]);\n      i++;\n    } else {\n      result.push(right[j]);\n      j++;\n    }\n  }\n  return result.concat(left.slice(i)).concat(right.slice(j));\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return mergeSort;')();\n  return [\n    { pass: JSON.stringify(fn([38, 27, 43, 3, 9, 82, 10])) === '[3,9,10,27,38,43,82]', description: 'mergeSort([38,27,43,3,9,82,10]) → sorted', got: JSON.stringify(fn([38, 27, 43, 3, 9, 82, 10])) },\n    { pass: JSON.stringify(fn([5, 3, 8, 4, 2])) === '[2,3,4,5,8]', description: 'mergeSort([5,3,8,4,2]) → [2,3,4,5,8]', got: JSON.stringify(fn([5, 3, 8, 4, 2])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'mergeSort([]) → []', got: JSON.stringify(fn([])) },\n    { pass: JSON.stringify(fn([1])) === '[1]', description: 'mergeSort([1]) → [1]', got: JSON.stringify(fn([1])) },\n    { pass: JSON.stringify(fn([2, 1])) === '[1,2]', description: 'mergeSort([2,1]) → [1,2]', got: JSON.stringify(fn([2, 1])) },\n    { pass: JSON.stringify(fn([5, 5, 3, 3, 1])) === '[1,3,3,5,5]', description: 'handles duplicates', got: JSON.stringify(fn([5, 5, 3, 3, 1])) },\n  ];\n}",
      "hint": "Split the problem into two parts: (1) a mergeSort function that recursively splits, and (2) a merge helper that combines two sorted arrays element by element using two pointers.",
      "resources": [
        {
          "label": "Visualgo: Sorting",
          "url": "https://visualgo.net/en/sorting"
        },
        {
          "label": "Wikipedia: Merge Sort",
          "url": "https://en.wikipedia.org/wiki/Merge_sort"
        }
      ],
      "hints": [
        "The `slice` method will be helpful here.",
        "Split the problem into two parts: (1) a mergeSort function that recursively splits, and (2) a merge helper that combines two sorted arrays element by element using two pointers.",
        "Key method(s): `floor`, `slice`, `concat`. The function calls itself recursively."
      ]
    },
    {
      "id": 301,
      "title": "Quick Sort",
      "type": "js",
      "tier": 4,
      "category": [
        "algorithms",
        "sorting"
      ],
      "tags": [
        "sorting",
        "algorithms",
        "recursion",
        "divide-and-conquer",
        "tier4"
      ],
      "description": "Implement the quick sort algorithm — pick a pivot, partition, and recursively sort.",
      "instructions": "Write a function called `quickSort` that takes an array of numbers and returns a new sorted array in ascending order using the quick sort algorithm.\n\nQuick sort works by:\n1. Choosing a pivot element (e.g., the last element)\n2. Partitioning the array into elements less than the pivot and elements greater than the pivot\n3. Recursively sorting the partitions\n4. Combining: [...left, pivot, ...right]\n\nExamples:\n  quickSort([10, 7, 8, 9, 1, 5]) → [1, 5, 7, 8, 9, 10]\n  quickSort([3, 1, 2])            → [1, 2, 3]\n  quickSort([])                   → []\n  quickSort([1])                  → [1]",
      "starterCode": "function quickSort(arr) {\n  // your code here\n}",
      "solution": "function quickSort(arr) {\n  if (arr.length <= 1) return arr;\n\n  const pivot = arr[arr.length - 1];\n  const left = [];\n  const right = [];\n\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] < pivot) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n\n  return [...quickSort(left), pivot, ...quickSort(right)];\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return quickSort;')();\n  return [\n    { pass: JSON.stringify(fn([10, 7, 8, 9, 1, 5])) === '[1,5,7,8,9,10]', description: 'quickSort([10,7,8,9,1,5]) → sorted', got: JSON.stringify(fn([10, 7, 8, 9, 1, 5])) },\n    { pass: JSON.stringify(fn([3, 1, 2])) === '[1,2,3]', description: 'quickSort([3,1,2]) → [1,2,3]', got: JSON.stringify(fn([3, 1, 2])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'quickSort([]) → []', got: JSON.stringify(fn([])) },\n    { pass: JSON.stringify(fn([1])) === '[1]', description: 'quickSort([1]) → [1]', got: JSON.stringify(fn([1])) },\n    { pass: JSON.stringify(fn([4, 2, 7, 1, 9, 3, 6, 5, 8])) === '[1,2,3,4,5,6,7,8,9]', description: 'sorts a larger array correctly', got: JSON.stringify(fn([4, 2, 7, 1, 9, 3, 6, 5, 8])) },\n    { pass: JSON.stringify(fn([3, 3, 3, 1, 1])) === '[1,1,3,3,3]', description: 'handles duplicates', got: JSON.stringify(fn([3, 3, 3, 1, 1])) },\n  ];\n}",
      "hint": "Base case: arrays with 0 or 1 elements are sorted. Pick the last element as pivot. Loop through the rest, pushing elements less than pivot into a left array and the rest into a right array. Return [...quickSort(left), pivot, ...quickSort(right)].",
      "resources": [
        {
          "label": "Visualgo: Sorting",
          "url": "https://visualgo.net/en/sorting"
        },
        {
          "label": "Wikipedia: Quick Sort",
          "url": "https://en.wikipedia.org/wiki/Quicksort"
        }
      ],
      "hints": [
        "If you pick one element as a \"pivot\" and partition the rest into smaller-than and larger-than groups, what do you do with each group next?",
        "Base case: arrays with 0 or 1 elements are sorted. Pick the last element as pivot. Loop through the rest, pushing elements less than pivot into a left array and the rest into a right array. Return [...quickSort(left), pivot, ...quickSort(right)].",
        "Key method(s): `quickSort`. The function calls itself recursively. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 302,
      "title": "Binary Search",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "searching"
      ],
      "tags": [
        "searching",
        "algorithms",
        "binary-search",
        "tier2"
      ],
      "description": "Implement binary search on a sorted array — return the index of the target or -1 if not found.",
      "instructions": "Write a function called `binarySearch` that takes a sorted array of numbers and a target value, and returns the index of the target in the array. If the target is not found, return -1.\n\nBinary search works by repeatedly dividing the search interval in half:\n1. Compare the target with the middle element\n2. If the target matches, return the index\n3. If the target is less, search the left half\n4. If the target is greater, search the right half\n\nExamples:\n  binarySearch([1, 3, 5, 7, 9, 11], 7)   → 3\n  binarySearch([1, 3, 5, 7, 9, 11], 4)   → -1\n  binarySearch([1, 3, 5, 7, 9, 11], 1)   → 0\n  binarySearch([1, 3, 5, 7, 9, 11], 11)  → 5\n  binarySearch([], 5)                    → -1",
      "starterCode": "function binarySearch(arr, target) {\n\n}",
      "solution": "function binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return binarySearch;')();\n  return [\n    { pass: fn([1, 3, 5, 7, 9, 11], 7) === 3, description: 'finds 7 at index 3', got: fn([1, 3, 5, 7, 9, 11], 7) },\n    { pass: fn([1, 3, 5, 7, 9, 11], 4) === -1, description: 'returns -1 when not found', got: fn([1, 3, 5, 7, 9, 11], 4) },\n    { pass: fn([1, 3, 5, 7, 9, 11], 1) === 0, description: 'finds first element at index 0', got: fn([1, 3, 5, 7, 9, 11], 1) },\n    { pass: fn([1, 3, 5, 7, 9, 11], 11) === 5, description: 'finds last element at index 5', got: fn([1, 3, 5, 7, 9, 11], 11) },\n    { pass: fn([], 5) === -1, description: 'empty array returns -1', got: fn([], 5) },\n    { pass: fn([42], 42) === 0, description: 'single element found', got: fn([42], 42) },\n  ];\n}",
      "hint": "Use two pointers (left and right). While left <= right, find the middle index. Compare arr[mid] to target: if equal, return mid. If target is larger, move left to mid + 1. If smaller, move right to mid - 1.",
      "resources": [
        {
          "label": "Wikipedia: Binary Search",
          "url": "https://en.wikipedia.org/wiki/Binary_search_algorithm"
        },
        {
          "label": "MDN: Math.floor()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor"
        }
      ],
      "hints": [
        "If the array is sorted, do you need to check every element, or can you eliminate half the possibilities at each step?",
        "Use two pointers (left and right). While left <= right, find the middle index. Compare arr[mid] to target: if equal, return mid. If target is larger, move left to mid + 1. If smaller, move right to mid - 1.",
        "Key method(s): `floor`, `Math.floor`."
      ]
    },
    {
      "id": 303,
      "title": "Binary Search — First Occurrence",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "searching"
      ],
      "tags": [
        "searching",
        "algorithms",
        "binary-search",
        "tier3"
      ],
      "description": "Find the first occurrence of a target in a sorted array with duplicates.",
      "instructions": "Write a function called `firstOccurrence` that takes a sorted array (which may contain duplicates) and a target value. Return the index of the FIRST occurrence of the target, or -1 if not found.\n\nThis is a modification of binary search: when you find the target, instead of returning immediately, continue searching left to see if there is an earlier occurrence.\n\nExamples:\n  firstOccurrence([1, 2, 2, 2, 3, 4], 2) → 1\n  firstOccurrence([1, 1, 1, 1], 1)        → 0\n  firstOccurrence([1, 2, 3, 4, 5], 3)     → 2\n  firstOccurrence([1, 2, 3, 4, 5], 6)     → -1\n  firstOccurrence([], 1)                  → -1",
      "starterCode": "function firstOccurrence(arr, target) {\n  // Modified binary search: when you find target,\n  // keep searching left for an earlier occurrence\n}",
      "solution": "function firstOccurrence(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  let result = -1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      result = mid;\n      right = mid - 1;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return firstOccurrence;')();\n  return [\n    { pass: fn([1, 2, 2, 2, 3, 4], 2) === 1, description: 'first of [1,2,2,2,3,4] target 2 → index 1', got: fn([1, 2, 2, 2, 3, 4], 2) },\n    { pass: fn([1, 1, 1, 1], 1) === 0, description: 'all same [1,1,1,1] target 1 → index 0', got: fn([1, 1, 1, 1], 1) },\n    { pass: fn([1, 2, 3, 4, 5], 3) === 2, description: 'no duplicates, target 3 → index 2', got: fn([1, 2, 3, 4, 5], 3) },\n    { pass: fn([1, 2, 3, 4, 5], 6) === -1, description: 'not found → -1', got: fn([1, 2, 3, 4, 5], 6) },\n    { pass: fn([], 1) === -1, description: 'empty array → -1', got: fn([], 1) },\n    { pass: fn([2, 2, 2, 2, 2], 2) === 0, description: 'all duplicates → index 0', got: fn([2, 2, 2, 2, 2], 2) },\n  ];\n}",
      "hint": "Use a standard binary search, but instead of returning immediately when you find the target, save the index in a result variable and continue searching left (set right = mid - 1) to find an earlier occurrence.",
      "resources": [
        {
          "label": "Wikipedia: Binary Search",
          "url": "https://en.wikipedia.org/wiki/Binary_search_algorithm"
        }
      ],
      "hints": [
        "`Math.floor` is a key tool for this exercise.",
        "Use a standard binary search, but instead of returning immediately when you find the target, save the index in a result variable and continue searching left (set right = mid - 1) to find an earlier occurrence.",
        "Key method(s): `floor`, `Math.floor`."
      ]
    },
    {
      "id": 304,
      "title": "Search in Rotated Sorted Array",
      "type": "js",
      "tier": 4,
      "category": [
        "algorithms",
        "searching"
      ],
      "tags": [
        "searching",
        "algorithms",
        "binary-search",
        "tier4"
      ],
      "description": "Search for a target in a sorted array that has been rotated at some pivot.",
      "instructions": "Write a function called `searchRotated` that takes a rotated sorted array and a target value, and returns the index of the target or -1 if not found.\n\nA rotated sorted array is a sorted array that has been shifted: e.g., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2].\n\nYou must solve this in O(log n) time using a modified binary search.\n\nKey insight: at any mid point, at least one half of the array is still sorted. Determine which half is sorted, then check if the target falls within that sorted half.\n\nExamples:\n  searchRotated([4, 5, 6, 7, 0, 1, 2], 0) → 4\n  searchRotated([4, 5, 6, 7, 0, 1, 2], 3) → -1\n  searchRotated([1], 1)                    → 0\n  searchRotated([2, 1], 1)                 → 1",
      "starterCode": "function searchRotated(nums, target) {\n  // your code here\n}",
      "solution": "function searchRotated(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n\n  return -1;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return searchRotated;')();\n  return [\n    { pass: fn([4, 5, 6, 7, 0, 1, 2], 0) === 4, description: 'find 0 in [4,5,6,7,0,1,2] → index 4', got: fn([4, 5, 6, 7, 0, 1, 2], 0) },\n    { pass: fn([4, 5, 6, 7, 0, 1, 2], 3) === -1, description: '3 not found → -1', got: fn([4, 5, 6, 7, 0, 1, 2], 3) },\n    { pass: fn([1], 1) === 0, description: 'single element found → 0', got: fn([1], 1) },\n    { pass: fn([2, 1], 1) === 1, description: '[2,1] find 1 → index 1', got: fn([2, 1], 1) },\n    { pass: fn([4, 5, 6, 7, 0, 1, 2], 5) === 1, description: 'find 5 in left sorted half → index 1', got: fn([4, 5, 6, 7, 0, 1, 2], 5) },\n    { pass: fn([], 1) === -1, description: 'empty array → -1', got: fn([], 1) },\n  ];\n}",
      "hint": "At each step, check which half is sorted by comparing nums[left] to nums[mid]. If the left half is sorted and target is within [left, mid), search left. Otherwise search right. Same logic applies if the right half is sorted.",
      "resources": [
        {
          "label": "LeetCode: Search in Rotated Sorted Array",
          "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
        }
      ],
      "hints": [
        "In a rotated sorted array, one half is always still sorted — how can you figure out which half to search?",
        "At each step, check which half is sorted by comparing nums[left] to nums[mid]. If the left half is sorted and target is within [left, mid), search left. Otherwise search right. Same logic applies if the right half is sorted.",
        "Key method(s): `floor`, `Math.floor`."
      ]
    },
    {
      "id": 305,
      "title": "Sum of Nested Array",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "arrays",
        "tier2"
      ],
      "description": "Recursively sum all numbers in a deeply nested array structure.",
      "instructions": "Write a function called `sumNested` that takes an array which may contain numbers and/or nested arrays, and returns the sum of all numbers at any depth.\n\nExamples:\n  sumNested([1, [2, [3]], 4])  → 10\n  sumNested([1, 2, 3])         → 6\n  sumNested([[[[5]]]])         → 5\n  sumNested([])                → 0\n  sumNested([1, [2, 3], [4, [5, 6]]]) → 21",
      "starterCode": "function sumNested(arr) {\n\n}",
      "solution": "function sumNested(arr) {\n  let sum = 0;\n  for (const item of arr) {\n    if (Array.isArray(item)) {\n      sum += sumNested(item);\n    } else {\n      sum += item;\n    }\n  }\n  return sum;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return sumNested;')();\n  return [\n    { pass: fn([1, [2, [3]], 4]) === 10, description: 'sumNested([1,[2,[3]],4]) → 10', got: fn([1, [2, [3]], 4]) },\n    { pass: fn([1, 2, 3]) === 6, description: 'flat array [1,2,3] → 6', got: fn([1, 2, 3]) },\n    { pass: fn([[[[5]]]]) === 5, description: 'deeply nested [[[[5]]]] → 5', got: fn([[[[5]]]]) },\n    { pass: fn([]) === 0, description: 'empty array → 0', got: fn([]) },\n    { pass: fn([1, [2, 3], [4, [5, 6]]]) === 21, description: 'mixed nesting → 21', got: fn([1, [2, 3], [4, [5, 6]]]) },\n  ];\n}",
      "hint": "Loop through each element. If it is an array (Array.isArray), recursively call sumNested on it and add the result. If it is a number, add it directly to the sum.",
      "resources": [
        {
          "label": "MDN: Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        },
        {
          "label": "MDN: Recursion",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Recursion"
        }
      ],
      "hints": [
        "The `isArray` method will be helpful here.",
        "Loop through each element. If it is an array (Array.isArray), recursively call sumNested on it and add the result. If it is a number, add it directly to the sum.",
        "Key method(s): `isArray`, `Array.isArray`. The function calls itself recursively. Use a loop to iterate, then return the accumulated result. The function should return a number."
      ]
    },
    {
      "id": 306,
      "title": "Fibonacci",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "math",
        "dynamic-programming",
        "tier2"
      ],
      "description": "Return the nth Fibonacci number (0-indexed).",
      "instructions": "Write a function called `fibonacci` that takes a non-negative integer n and returns the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\n- fib(0) = 0\n- fib(1) = 1\n- fib(n) = fib(n-1) + fib(n-2)\n\nYou can use either a recursive or iterative approach.\n\nExamples:\n  fibonacci(0)  → 0\n  fibonacci(1)  → 1\n  fibonacci(6)  → 8\n  fibonacci(10) → 55",
      "starterCode": "function fibonacci(n) {\n\n}",
      "solution": "function fibonacci(n) {\n  if (n <= 0) return 0;\n  if (n === 1) return 1;\n  let prev = 0;\n  let curr = 1;\n  for (let i = 2; i <= n; i++) {\n    const next = prev + curr;\n    prev = curr;\n    curr = next;\n  }\n  return curr;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return fibonacci;')();\n  return [\n    { pass: fn(0) === 0, description: 'fibonacci(0) → 0', got: fn(0) },\n    { pass: fn(1) === 1, description: 'fibonacci(1) → 1', got: fn(1) },\n    { pass: fn(6) === 8, description: 'fibonacci(6) → 8', got: fn(6) },\n    { pass: fn(10) === 55, description: 'fibonacci(10) → 55', got: fn(10) },\n    { pass: fn(2) === 1, description: 'fibonacci(2) → 1', got: fn(2) },\n    { pass: fn(7) === 13, description: 'fibonacci(7) → 13', got: fn(7) },\n  ];\n}",
      "hint": "Iterative approach: start with prev=0, curr=1. Loop from 2 to n, each time computing next = prev + curr, then shift prev=curr and curr=next. Return curr.",
      "resources": [
        {
          "label": "Wikipedia: Fibonacci Number",
          "url": "https://en.wikipedia.org/wiki/Fibonacci_number"
        }
      ],
      "hints": [
        "What are the two simplest Fibonacci values you know without computing, and how does each subsequent value relate to the previous two?",
        "Iterative approach: start with prev=0, curr=1. Loop from 2 to n, each time computing next = prev + curr, then shift prev=curr and curr=next. Return curr.",
        "Use a loop to iterate, then return the accumulated result. The function should return a number."
      ]
    },
    {
      "id": 307,
      "title": "Power (Recursive)",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "math",
        "tier3"
      ],
      "description": "Calculate base raised to an exponent using recursion.",
      "instructions": "Write a function called `power` that takes a base and an exponent (non-negative integer) and returns the result using recursion.\n\nBase case: any number to the power of 0 is 1.\nRecursive case: base * power(base, exp - 1)\n\nExamples:\n  power(2, 3)  → 8\n  power(5, 0)  → 1\n  power(3, 4)  → 81\n  power(10, 1) → 10",
      "starterCode": "function power(base, exp) {\n  // Base case: any number to the power of 0 is 1\n  // Recursive case: base * power(base, exp - 1)\n}",
      "solution": "function power(base, exp) {\n  if (exp === 0) return 1;\n  return base * power(base, exp - 1);\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return power;')();\n  return [\n    { pass: fn(2, 3) === 8, description: 'power(2, 3) → 8', got: fn(2, 3) },\n    { pass: fn(5, 0) === 1, description: 'power(5, 0) → 1', got: fn(5, 0) },\n    { pass: fn(3, 4) === 81, description: 'power(3, 4) → 81', got: fn(3, 4) },\n    { pass: fn(10, 1) === 10, description: 'power(10, 1) → 10', got: fn(10, 1) },\n    { pass: fn(1, 100) === 1, description: 'power(1, 100) → 1', got: fn(1, 100) },\n    { pass: fn(2, 10) === 1024, description: 'power(2, 10) → 1024', got: fn(2, 10) },\n  ];\n}",
      "hint": "Base case: if exp is 0, return 1. Otherwise, return base multiplied by the result of power(base, exp - 1). This reduces the exponent by 1 each time until it reaches 0.",
      "resources": [
        {
          "label": "MDN: Recursion",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Recursion"
        }
      ],
      "hints": [
        "What does raising a number to the power of 0 give you, and how can you express x^n in terms of x^(n-1)?",
        "Base case: if exp is 0, return 1. Otherwise, return base multiplied by the result of power(base, exp - 1). This reduces the exponent by 1 each time until it reaches 0.",
        "The function calls itself recursively. The function should return a number."
      ]
    },
    {
      "id": 308,
      "title": "Permutations",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "backtracking",
        "arrays",
        "tier3"
      ],
      "description": "Generate all possible orderings (permutations) of an array.",
      "instructions": "Write a function called `permutations` that takes an array of distinct elements and returns an array of all possible orderings (permutations).\n\nFor each element, combine it with all permutations of the remaining elements.\n\nExamples:\n  permutations([1, 2, 3]) → [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  (6 permutations)\n  permutations([1, 2])    → [[1,2],[2,1]]\n  permutations([1])       → [[1]]\n  permutations([])        → [[]]",
      "starterCode": "function permutations(arr) {\n  // Build all orderings of the input array\n  // Hint: for each element, combine it with permutations of the rest\n}",
      "solution": "function permutations(arr) {\n  if (arr.length === 0) return [[]];\n  if (arr.length === 1) return [[arr[0]]];\n\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const current = arr[i];\n    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];\n    const perms = permutations(rest);\n    for (const perm of perms) {\n      result.push([current, ...perm]);\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return permutations;')();\n  const r3 = fn([1, 2, 3]);\n  const r2 = fn([1, 2]);\n  const r1 = fn([1]);\n  const r0 = fn([]);\n  return [\n    { pass: r3.length === 6, description: 'permutations([1,2,3]) has 6 results', got: r3.length },\n    { pass: r3.some(p => JSON.stringify(p) === '[1,2,3]') && r3.some(p => JSON.stringify(p) === '[3,2,1]'), description: 'includes [1,2,3] and [3,2,1]', got: 'checked' },\n    { pass: JSON.stringify(r2.sort()) === '[[1,2],[2,1]]', description: 'permutations([1,2]) → [[1,2],[2,1]]', got: JSON.stringify(r2.sort()) },\n    { pass: JSON.stringify(r1) === '[[1]]', description: 'permutations([1]) → [[1]]', got: JSON.stringify(r1) },\n    { pass: JSON.stringify(r0) === '[[]]', description: 'permutations([]) → [[]]', got: JSON.stringify(r0) },\n  ];\n}",
      "hint": "Base case: empty array returns [[]]. For each element at index i, take it out of the array, recursively find all permutations of the remaining elements, then prepend the current element to each of those permutations.",
      "resources": [
        {
          "label": "Wikipedia: Permutation",
          "url": "https://en.wikipedia.org/wiki/Permutation"
        }
      ],
      "hints": [
        "`slice` is a key tool for this exercise.",
        "Base case: empty array returns [[]]. For each element at index i, take it out of the array, recursively find all permutations of the remaining elements, then prepend the current element to each of those permutations.",
        "Key method(s): `slice`. The function calls itself recursively. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 309,
      "title": "Generate Parentheses",
      "type": "js",
      "tier": 4,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "backtracking",
        "strings",
        "tier4"
      ],
      "description": "Generate all valid combinations of n pairs of parentheses.",
      "instructions": "Write a function called `generateParens` that takes a number n and returns an array of all valid combinations of n pairs of parentheses.\n\nUse backtracking: track how many open and close parentheses have been used. You can add an open paren if open < n, and a close paren if close < open.\n\nExamples:\n  generateParens(1) → [\"()\"]\n  generateParens(2) → [\"(())\", \"()()\"]\n  generateParens(3) → [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n  generateParens(0) → [\"\"]",
      "starterCode": "function generateParens(n) {\n  // your code here\n}",
      "solution": "function generateParens(n) {\n  const result = [];\n\n  function backtrack(current, open, close) {\n    if (current.length === 2 * n) {\n      result.push(current);\n      return;\n    }\n    if (open < n) {\n      backtrack(current + '(', open + 1, close);\n    }\n    if (close < open) {\n      backtrack(current + ')', open, close + 1);\n    }\n  }\n\n  backtrack('', 0, 0);\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return generateParens;')();\n  const r1 = fn(1);\n  const r2 = fn(2);\n  const r3 = fn(3);\n  const r0 = fn(0);\n  return [\n    { pass: JSON.stringify(r1) === '[\"()\"]', description: 'generateParens(1) → [\"()\"]', got: JSON.stringify(r1) },\n    { pass: r2.length === 2 && r2.includes('(())') && r2.includes('()()'), description: 'generateParens(2) → [\"(())\", \"()()\"]', got: JSON.stringify(r2) },\n    { pass: r3.length === 5, description: 'generateParens(3) has 5 combinations', got: r3.length },\n    { pass: r3.includes('((()))') && r3.includes('()()()'), description: 'generateParens(3) includes ((()))\" and \"()()()\"', got: JSON.stringify(r3) },\n    { pass: JSON.stringify(r0) === '[\"\"]', description: 'generateParens(0) → [\"\"]', got: JSON.stringify(r0) },\n  ];\n}",
      "hint": "Use a recursive helper function backtrack(current, openCount, closeCount). Base case: when current.length === 2*n, push to result. You can add \"(\" if openCount < n. You can add \")\" if closeCount < openCount.",
      "resources": [
        {
          "label": "LeetCode: Generate Parentheses",
          "url": "https://leetcode.com/problems/generate-parentheses/"
        }
      ],
      "hints": [
        "Start by thinking about recursive thinking and backtracking.",
        "Use a recursive helper function backtrack(current, openCount, closeCount). Base case: when current.length === 2*n, push to result. You can add \"(\" if openCount < n. You can add \")\" if closeCount < openCount.",
        "The function should return an array."
      ]
    },
    {
      "id": 310,
      "title": "Two Sum",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "hash-map",
        "algorithms",
        "arrays",
        "tier2"
      ],
      "description": "Find two numbers in an array that add up to a target and return their indices.",
      "instructions": "Write a function called `twoSum` that takes an array of numbers and a target sum. Return an array of the two indices whose values add up to the target.\n\nAssume exactly one solution exists. Use a hash map (object or Map) for O(n) time complexity.\n\nExamples:\n  twoSum([2, 7, 11, 15], 9)  → [0, 1]  (2 + 7 = 9)\n  twoSum([3, 2, 4], 6)       → [1, 2]  (2 + 4 = 6)\n  twoSum([3, 3], 6)          → [0, 1]  (3 + 3 = 6)",
      "starterCode": "function twoSum(nums, target) {\n\n}",
      "solution": "function twoSum(nums, target) {\n  const map = {};\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.hasOwnProperty(complement)) {\n      return [map[complement], i];\n    }\n    map[nums[i]] = i;\n  }\n  return [];\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return twoSum;')();\n  return [\n    { pass: JSON.stringify(fn([2, 7, 11, 15], 9)) === '[0,1]', description: 'twoSum([2,7,11,15], 9) → [0,1]', got: JSON.stringify(fn([2, 7, 11, 15], 9)) },\n    { pass: JSON.stringify(fn([3, 2, 4], 6)) === '[1,2]', description: 'twoSum([3,2,4], 6) → [1,2]', got: JSON.stringify(fn([3, 2, 4], 6)) },\n    { pass: JSON.stringify(fn([3, 3], 6)) === '[0,1]', description: 'twoSum([3,3], 6) → [0,1]', got: JSON.stringify(fn([3, 3], 6)) },\n    { pass: JSON.stringify(fn([1, 5, 3, 7], 8)) === '[1,2]' || JSON.stringify(fn([1, 5, 3, 7], 8)) === '[0,3]', description: 'twoSum([1,5,3,7], 8) → valid pair', got: JSON.stringify(fn([1, 5, 3, 7], 8)) },\n  ];\n}",
      "hint": "As you iterate, for each number compute the complement (target - num). Check if the complement is already in your map. If yes, return [map[complement], currentIndex]. If not, store the current number and its index in the map.",
      "resources": [
        {
          "label": "LeetCode: Two Sum",
          "url": "https://leetcode.com/problems/two-sum/"
        }
      ],
      "hints": [
        "For each number, you need a specific complement to reach the target — is there a way to remember which numbers you have already seen?",
        "As you iterate, for each number compute the complement (target - num). Check if the complement is already in your map. If yes, return [map[complement], currentIndex]. If not, store the current number and its index in the map.",
        "Key method(s): `hasOwnProperty`. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 311,
      "title": "Valid Anagram",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "hash-map",
        "strings",
        "frequency-counter",
        "tier2"
      ],
      "description": "Determine if two strings are anagrams of each other.",
      "instructions": "Write a function called `isAnagram` that takes two strings and returns `true` if they are anagrams (contain the same characters with the same frequencies), `false` otherwise.\n\nExamples:\n  isAnagram(\"anagram\", \"nagaram\") → true\n  isAnagram(\"rat\", \"car\")         → false\n  isAnagram(\"\", \"\")               → true\n  isAnagram(\"a\", \"ab\")            → false",
      "starterCode": "function isAnagram(s, t) {\n\n}",
      "solution": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const freq = {};\n  for (const ch of s) {\n    freq[ch] = (freq[ch] || 0) + 1;\n  }\n  for (const ch of t) {\n    if (!freq[ch]) return false;\n    freq[ch]--;\n  }\n  return true;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return isAnagram;')();\n  return [\n    { pass: fn('anagram', 'nagaram') === true, description: '\"anagram\" / \"nagaram\" → true', got: fn('anagram', 'nagaram') },\n    { pass: fn('rat', 'car') === false, description: '\"rat\" / \"car\" → false', got: fn('rat', 'car') },\n    { pass: fn('', '') === true, description: 'empty strings → true', got: fn('', '') },\n    { pass: fn('a', 'ab') === false, description: 'different lengths → false', got: fn('a', 'ab') },\n    { pass: fn('listen', 'silent') === true, description: '\"listen\" / \"silent\" → true', got: fn('listen', 'silent') },\n  ];\n}",
      "hint": "First check if lengths differ — if so, return false. Build a frequency map from the first string. Then iterate over the second string, decrementing counts. If any character is missing or count goes below zero, they are not anagrams.",
      "resources": [
        {
          "label": "LeetCode: Valid Anagram",
          "url": "https://leetcode.com/problems/valid-anagram/"
        }
      ],
      "hints": [
        "Two strings are anagrams if they have exactly the same character counts — how would you compare the counts efficiently?",
        "First check if lengths differ — if so, return false. Build a frequency map from the first string. Then iterate over the second string, decrementing counts. If any character is missing or count goes below zero, they are not anagrams.",
        "Use a loop to iterate, then return the accumulated result. The function should return a boolean."
      ]
    },
    {
      "id": 312,
      "title": "Move Zeroes",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "two-pointer",
        "arrays",
        "tier2"
      ],
      "description": "Move all zeroes to the end of an array while maintaining the relative order of non-zero elements.",
      "instructions": "Write a function called `moveZeroes` that takes an array of numbers and returns a new array with all zeroes moved to the end, while maintaining the relative order of the non-zero elements.\n\nExamples:\n  moveZeroes([0, 1, 0, 3, 12]) → [1, 3, 12, 0, 0]\n  moveZeroes([0])              → [0]\n  moveZeroes([1, 2, 3])        → [1, 2, 3]\n  moveZeroes([0, 0, 1])        → [1, 0, 0]",
      "starterCode": "function moveZeroes(arr) {\n\n}",
      "solution": "function moveZeroes(arr) {\n  const nonZeroes = arr.filter(x => x !== 0);\n  const zeroes = new Array(arr.length - nonZeroes.length).fill(0);\n  return [...nonZeroes, ...zeroes];\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return moveZeroes;')();\n  return [\n    { pass: JSON.stringify(fn([0, 1, 0, 3, 12])) === '[1,3,12,0,0]', description: 'moveZeroes([0,1,0,3,12]) → [1,3,12,0,0]', got: JSON.stringify(fn([0, 1, 0, 3, 12])) },\n    { pass: JSON.stringify(fn([0])) === '[0]', description: 'moveZeroes([0]) → [0]', got: JSON.stringify(fn([0])) },\n    { pass: JSON.stringify(fn([1, 2, 3])) === '[1,2,3]', description: 'no zeroes → unchanged', got: JSON.stringify(fn([1, 2, 3])) },\n    { pass: JSON.stringify(fn([0, 0, 1])) === '[1,0,0]', description: 'moveZeroes([0,0,1]) → [1,0,0]', got: JSON.stringify(fn([0, 0, 1])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'empty array → []', got: JSON.stringify(fn([])) },\n  ];\n}",
      "hint": "One approach: filter out all non-zero elements, then pad the result with zeroes to match the original length. Or use a two-pointer technique: one pointer for the next non-zero position.",
      "resources": [
        {
          "label": "LeetCode: Move Zeroes",
          "url": "https://leetcode.com/problems/move-zeroes/"
        }
      ],
      "hints": [
        "What if you used two pointers — one at each end — and moved them toward each other based on a condition?",
        "One approach: filter out all non-zero elements, then pad the result with zeroes to match the original length. Or use a two-pointer technique: one pointer for the next non-zero position.",
        "Key method(s): `filter`, `fill`, `new Array`. Filter elements that match your condition. The function should return an array."
      ]
    },
    {
      "id": 313,
      "title": "Three Sum",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "two-pointer",
        "sorting",
        "arrays",
        "tier3"
      ],
      "description": "Find all unique triplets in an array that sum to zero.",
      "instructions": "Write a function called `threeSum` that takes an array of numbers and returns an array of all unique triplets [a, b, c] where a + b + c = 0.\n\nThe solution should not contain duplicate triplets. Sort each triplet in ascending order.\n\nHint: Sort the array first, then for each element, use a two-pointer approach on the remaining elements.\n\nExamples:\n  threeSum([-1, 0, 1, 2, -1, -4]) → [[-1, -1, 2], [-1, 0, 1]]\n  threeSum([0, 0, 0])              → [[0, 0, 0]]\n  threeSum([1, 2, -3])             → [[-3, 1, 2]]\n  threeSum([])                     → []",
      "starterCode": "function threeSum(nums) {\n  // Find all unique triplets that sum to zero\n  // Hint: sort first, then use two-pointer for each element\n}",
      "solution": "function threeSum(nums) {\n  const result = [];\n  nums.sort((a, b) => a - b);\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n    let left = i + 1;\n    let right = nums.length - 1;\n\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return threeSum;')();\n  const r1 = fn([-1, 0, 1, 2, -1, -4]);\n  const r2 = fn([0, 0, 0]);\n  const r3 = fn([1, 2, -3]);\n  const r4 = fn([]);\n  return [\n    { pass: r1.length === 2 && JSON.stringify(r1).includes('[-1,-1,2]') && JSON.stringify(r1).includes('[-1,0,1]'), description: 'threeSum([-1,0,1,2,-1,-4]) → [[-1,-1,2],[-1,0,1]]', got: JSON.stringify(r1) },\n    { pass: JSON.stringify(r2) === '[[0,0,0]]', description: 'threeSum([0,0,0]) → [[0,0,0]]', got: JSON.stringify(r2) },\n    { pass: r3.length === 1 && JSON.stringify(r3[0]) === '[-3,1,2]', description: 'threeSum([1,2,-3]) → [[-3,1,2]]', got: JSON.stringify(r3) },\n    { pass: JSON.stringify(r4) === '[]', description: 'threeSum([]) → []', got: JSON.stringify(r4) },\n    { pass: fn([1, 2, 3]).length === 0, description: 'no valid triplets → []', got: JSON.stringify(fn([1, 2, 3])) },\n  ];\n}",
      "hint": "Sort the array. Loop through each element as the first number. Skip duplicates. For the remaining elements, use two pointers (left and right). If the sum is 0, add the triplet and skip duplicates. If sum < 0, move left pointer right. If sum > 0, move right pointer left.",
      "resources": [
        {
          "label": "LeetCode: 3Sum",
          "url": "https://leetcode.com/problems/3sum/"
        }
      ],
      "hints": [
        "`sort` is a key tool for this exercise.",
        "Sort the array. Loop through each element as the first number. Skip duplicates. For the remaining elements, use two pointers (left and right). If the sum is 0, add the triplet and skip duplicates. If sum < 0, move left pointer right. If sum > 0, move right pointer left.",
        "Key method(s): `sort`. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 314,
      "title": "Sliding Window Maximum Sum",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "sliding-window",
        "arrays",
        "tier3"
      ],
      "description": "Find the maximum sum of k consecutive elements in an array.",
      "instructions": "Write a function called `maxSubarraySum` that takes an array of numbers and a window size k, and returns the maximum sum of any k consecutive elements.\n\nUse the sliding window technique: compute the sum of the first k elements, then slide the window by subtracting the element that leaves and adding the element that enters.\n\nReturn 0 if the array is empty or k is larger than the array.\n\nExamples:\n  maxSubarraySum([2, 1, 5, 1, 3, 2], 3) → 9  (5 + 1 + 3)\n  maxSubarraySum([1, 2, 3, 4, 5], 2)    → 9  (4 + 5)\n  maxSubarraySum([4], 1)                → 4\n  maxSubarraySum([], 3)                 → 0",
      "starterCode": "function maxSubarraySum(arr, k) {\n  // Find the maximum sum of k consecutive elements\n  // Hint: compute first window, then slide\n}",
      "solution": "function maxSubarraySum(arr, k) {\n  if (arr.length === 0 || k > arr.length) return 0;\n\n  let windowSum = 0;\n  for (let i = 0; i < k; i++) {\n    windowSum += arr[i];\n  }\n\n  let maxSum = windowSum;\n  for (let i = k; i < arr.length; i++) {\n    windowSum = windowSum + arr[i] - arr[i - k];\n    if (windowSum > maxSum) maxSum = windowSum;\n  }\n\n  return maxSum;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return maxSubarraySum;')();\n  return [\n    { pass: fn([2, 1, 5, 1, 3, 2], 3) === 9, description: 'maxSubarraySum([2,1,5,1,3,2], 3) → 9', got: fn([2, 1, 5, 1, 3, 2], 3) },\n    { pass: fn([1, 2, 3, 4, 5], 2) === 9, description: 'maxSubarraySum([1,2,3,4,5], 2) → 9', got: fn([1, 2, 3, 4, 5], 2) },\n    { pass: fn([4], 1) === 4, description: 'single element window → 4', got: fn([4], 1) },\n    { pass: fn([], 3) === 0, description: 'empty array → 0', got: fn([], 3) },\n    { pass: fn([1, 2], 5) === 0, description: 'k > array length → 0', got: fn([1, 2], 5) },\n    { pass: fn([3, 3, 3, 3], 2) === 6, description: 'all same values → 6', got: fn([3, 3, 3, 3], 2) },\n  ];\n}",
      "hint": "First compute the sum of the first k elements. Then slide the window: for each new position, add the new element entering the window and subtract the element leaving. Track the maximum sum seen.",
      "resources": [
        {
          "label": "Sliding Window Technique",
          "url": "https://www.geeksforgeeks.org/window-sliding-technique/"
        }
      ],
      "hints": [
        "Start by thinking about the sliding window pattern and array methods.",
        "First compute the sum of the first k elements. Then slide the window: for each new position, add the new element entering the window and subtract the element leaving. Track the maximum sum seen.",
        "Use a loop to iterate, then return the accumulated result. The function should return a number."
      ]
    },
    {
      "id": 315,
      "title": "Longest Substring Without Repeating Characters",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "sliding-window",
        "hash-map",
        "strings",
        "tier3"
      ],
      "description": "Find the length of the longest substring without any repeating characters.",
      "instructions": "Write a function called `lengthOfLongestSubstring` that takes a string and returns the length of the longest substring without repeating characters.\n\nUse a sliding window with a Set to track characters in the current window.\n\nExamples:\n  lengthOfLongestSubstring(\"abcabcbb\") → 3  (\"abc\")\n  lengthOfLongestSubstring(\"bbbbb\")    → 1  (\"b\")\n  lengthOfLongestSubstring(\"pwwkew\")   → 3  (\"wke\")\n  lengthOfLongestSubstring(\"\")         → 0\n  lengthOfLongestSubstring(\"abcdef\")   → 6",
      "starterCode": "function lengthOfLongestSubstring(s) {\n  // Use a sliding window with a Set to track characters\n}",
      "solution": "function lengthOfLongestSubstring(s) {\n  const seen = new Set();\n  let left = 0;\n  let maxLen = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    while (seen.has(s[right])) {\n      seen.delete(s[left]);\n      left++;\n    }\n    seen.add(s[right]);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n\n  return maxLen;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return lengthOfLongestSubstring;')();\n  return [\n    { pass: fn('abcabcbb') === 3, description: '\"abcabcbb\" → 3', got: fn('abcabcbb') },\n    { pass: fn('bbbbb') === 1, description: '\"bbbbb\" → 1', got: fn('bbbbb') },\n    { pass: fn('pwwkew') === 3, description: '\"pwwkew\" → 3', got: fn('pwwkew') },\n    { pass: fn('') === 0, description: 'empty string → 0', got: fn('') },\n    { pass: fn('abcdef') === 6, description: '\"abcdef\" → 6 (all unique)', got: fn('abcdef') },\n    { pass: fn('aab') === 2, description: '\"aab\" → 2', got: fn('aab') },\n  ];\n}",
      "hint": "Use two pointers (left and right) and a Set. Expand right pointer. If the character at right is already in the Set, shrink from the left until it is removed. Add the right character to the Set and update max length.",
      "resources": [
        {
          "label": "LeetCode: Longest Substring Without Repeating Characters",
          "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
        }
      ],
      "hints": [
        "The `Math.max` method will be helpful here.",
        "Use two pointers (left and right) and a Set. Expand right pointer. If the character at right is already in the Set, shrink from the left until it is removed. Add the right character to the Set and update max length.",
        "Key method(s): `has`, `delete`, `add`. Use a loop to iterate, then return the accumulated result. The function should return a boolean."
      ]
    },
    {
      "id": 316,
      "title": "Product of Array Except Self",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "arrays",
        "prefix-product",
        "tier3"
      ],
      "description": "Return an array where each element is the product of all other elements, without using division.",
      "instructions": "Write a function called `productExceptSelf` that takes an array of numbers and returns an array where each element at index i is the product of all numbers in the original array except the one at index i.\n\nYou must solve this WITHOUT using division.\n\nHint: Use two passes — one for prefix products (left to right) and one for suffix products (right to left).\n\nExamples:\n  productExceptSelf([1, 2, 3, 4])       → [24, 12, 8, 6]\n  productExceptSelf([2, 3])             → [3, 2]\n  productExceptSelf([-1, 1, 0, -3, 3]) → [0, 0, 9, 0, 0]",
      "starterCode": "function productExceptSelf(nums) {\n  // Build result without using division\n  // Hint: use prefix and suffix products\n}",
      "solution": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n).fill(1);\n\n  let prefix = 1;\n  for (let i = 0; i < n; i++) {\n    result[i] = prefix;\n    prefix *= nums[i];\n  }\n\n  let suffix = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= suffix;\n    suffix *= nums[i];\n  }\n\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return productExceptSelf;')();\n  return [\n    { pass: JSON.stringify(fn([1, 2, 3, 4])) === '[24,12,8,6]', description: 'productExceptSelf([1,2,3,4]) → [24,12,8,6]', got: JSON.stringify(fn([1, 2, 3, 4])) },\n    { pass: JSON.stringify(fn([2, 3])) === '[3,2]', description: 'productExceptSelf([2,3]) → [3,2]', got: JSON.stringify(fn([2, 3])) },\n    { pass: JSON.stringify(fn([-1, 1, 0, -3, 3])) === '[0,0,9,0,0]', description: 'handles zeroes and negatives', got: JSON.stringify(fn([-1, 1, 0, -3, 3])) },\n    { pass: JSON.stringify(fn([5])) === '[1]', description: 'single element → [1]', got: JSON.stringify(fn([5])) },\n  ];\n}",
      "hint": "Two passes: First, left-to-right, store the running product of everything BEFORE each index. Second, right-to-left, multiply each position by the running product of everything AFTER it.",
      "resources": [
        {
          "label": "LeetCode: Product of Array Except Self",
          "url": "https://leetcode.com/problems/product-of-array-except-self/"
        }
      ],
      "hints": [
        "For each position, you need the product of everything to its left times everything to its right — can you precompute those separately?",
        "Two passes: First, left-to-right, store the running product of everything BEFORE each index. Second, right-to-left, multiply each position by the running product of everything AFTER it.",
        "Key method(s): `fill`, `new Array`. Use a loop to iterate, then return the accumulated result."
      ]
    },
    {
      "id": 317,
      "title": "Container With Most Water",
      "type": "js",
      "tier": 4,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "two-pointer",
        "arrays",
        "greedy",
        "tier4"
      ],
      "description": "Find two lines that together with the x-axis form a container that holds the most water.",
      "instructions": "Write a function called `maxArea` that takes an array of non-negative integers representing heights of vertical lines. Find two lines that, together with the x-axis, form a container that holds the most water.\n\nThe area is calculated as: min(height[left], height[right]) * (right - left)\n\nUse the two-pointer technique: start with the widest container, then move the shorter wall inward.\n\nExamples:\n  maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]) → 49\n  maxArea([1, 1])                       → 1\n  maxArea([4, 3, 2, 1, 4])              → 16\n  maxArea([1, 2, 1])                    → 2",
      "starterCode": "function maxArea(height) {\n  // your code here\n}",
      "solution": "function maxArea(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let max = 0;\n\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    if (area > max) max = area;\n\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n\n  return max;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return maxArea;')();\n  return [\n    { pass: fn([1, 8, 6, 2, 5, 4, 8, 3, 7]) === 49, description: 'maxArea([1,8,6,2,5,4,8,3,7]) → 49', got: fn([1, 8, 6, 2, 5, 4, 8, 3, 7]) },\n    { pass: fn([1, 1]) === 1, description: 'maxArea([1,1]) → 1', got: fn([1, 1]) },\n    { pass: fn([4, 3, 2, 1, 4]) === 16, description: 'maxArea([4,3,2,1,4]) → 16', got: fn([4, 3, 2, 1, 4]) },\n    { pass: fn([1, 2, 1]) === 2, description: 'maxArea([1,2,1]) → 2', got: fn([1, 2, 1]) },\n    { pass: fn([2, 3, 4, 5, 18, 17, 6]) === 17, description: 'maxArea([2,3,4,5,18,17,6]) → 17', got: fn([2, 3, 4, 5, 18, 17, 6]) },\n  ];\n}",
      "hint": "Use two pointers starting at the edges. Calculate the area (min height * width). Move the pointer with the shorter height inward, since keeping the shorter one cannot improve the result. Track the maximum area.",
      "resources": [
        {
          "label": "LeetCode: Container With Most Water",
          "url": "https://leetcode.com/problems/container-with-most-water/"
        }
      ],
      "hints": [
        "If you start with pointers at both ends, which pointer should you move inward — the taller line or the shorter one — and why?",
        "Use two pointers starting at the edges. Calculate the area (min height * width). Move the pointer with the shorter height inward, since keeping the shorter one cannot improve the result. Track the maximum area.",
        "Key method(s): `min`, `Math.min`. The function should return a number."
      ]
    },
    {
      "id": 318,
      "title": "Rotate Array",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "rotation",
        "tier2"
      ],
      "description": "Rotate an array to the right by k positions, returning a new array.",
      "instructions": "Write a function called `rotateArray` that takes an array and a number k, and returns a new array rotated to the right by k positions.\n\nRotating right by 1 means the last element becomes the first. Handle cases where k is larger than the array length.\n\nExamples:\n  rotateArray([1, 2, 3, 4, 5], 2) → [4, 5, 1, 2, 3]\n  rotateArray([1, 2, 3], 1)        → [3, 1, 2]\n  rotateArray([1], 5)              → [1]\n  rotateArray([], 3)               → []",
      "starterCode": "function rotateArray(arr, k) {\n\n}",
      "solution": "function rotateArray(arr, k) {\n  if (arr.length === 0) return [];\n  const n = arr.length;\n  const shift = k % n;\n  return [...arr.slice(n - shift), ...arr.slice(0, n - shift)];\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return rotateArray;')();\n  return [\n    { pass: JSON.stringify(fn([1, 2, 3, 4, 5], 2)) === '[4,5,1,2,3]', description: 'rotateArray([1,2,3,4,5], 2) → [4,5,1,2,3]', got: JSON.stringify(fn([1, 2, 3, 4, 5], 2)) },\n    { pass: JSON.stringify(fn([1, 2, 3], 1)) === '[3,1,2]', description: 'rotateArray([1,2,3], 1) → [3,1,2]', got: JSON.stringify(fn([1, 2, 3], 1)) },\n    { pass: JSON.stringify(fn([1], 5)) === '[1]', description: 'single element → [1]', got: JSON.stringify(fn([1], 5)) },\n    { pass: JSON.stringify(fn([], 3)) === '[]', description: 'empty array → []', got: JSON.stringify(fn([], 3)) },\n    { pass: JSON.stringify(fn([1, 2, 3], 3)) === '[1,2,3]', description: 'k equals length → same array', got: JSON.stringify(fn([1, 2, 3], 3)) },\n    { pass: JSON.stringify(fn([1, 2, 3], 4)) === '[3,1,2]', description: 'k > length wraps around', got: JSON.stringify(fn([1, 2, 3], 4)) },\n  ];\n}",
      "hint": "Use k % arr.length to handle k larger than the array. Then slice the array into two parts: the last k elements and the first (length - k) elements. Concatenate them in reverse order.",
      "resources": [
        {
          "label": "LeetCode: Rotate Array",
          "url": "https://leetcode.com/problems/rotate-array/"
        }
      ],
      "hints": [
        "`slice` is a key tool for this exercise.",
        "Use k % arr.length to handle k larger than the array. Then slice the array into two parts: the last k elements and the first (length - k) elements. Concatenate them in reverse order.",
        "Key method(s): `slice`. The function should return an array."
      ]
    },
    {
      "id": 319,
      "title": "Spiral Matrix",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "matrix",
        "tier3"
      ],
      "description": "Traverse a 2D matrix in spiral order (clockwise) and return the elements as a flat array.",
      "instructions": "Write a function called `spiralOrder` that takes a 2D matrix (array of arrays) and returns the elements in spiral (clockwise) order.\n\nTraverse: right across the top row, down the right column, left across the bottom row, up the left column, then repeat inward.\n\nUse boundary variables (top, bottom, left, right) to track the current spiral layer.\n\nExamples:\n  spiralOrder([[1,2,3],[4,5,6],[7,8,9]]) → [1,2,3,6,9,8,7,4,5]\n  spiralOrder([[1,2],[3,4]])              → [1,2,4,3]\n  spiralOrder([[1]])                     → [1]\n  spiralOrder([])                        → []",
      "starterCode": "function spiralOrder(matrix) {\n  // Traverse the matrix in spiral order (clockwise)\n  // Hint: track top, bottom, left, right boundaries\n}",
      "solution": "function spiralOrder(matrix) {\n  if (matrix.length === 0) return [];\n  const result = [];\n  let top = 0;\n  let bottom = matrix.length - 1;\n  let left = 0;\n  let right = matrix[0].length - 1;\n\n  while (top <= bottom && left <= right) {\n    for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n    top++;\n\n    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n    right--;\n\n    if (top <= bottom) {\n      for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n      bottom--;\n    }\n\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n      left++;\n    }\n  }\n\n  return result;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return spiralOrder;')();\n  return [\n    { pass: JSON.stringify(fn([[1,2,3],[4,5,6],[7,8,9]])) === '[1,2,3,6,9,8,7,4,5]', description: '3x3 matrix spiral', got: JSON.stringify(fn([[1,2,3],[4,5,6],[7,8,9]])) },\n    { pass: JSON.stringify(fn([[1,2],[3,4]])) === '[1,2,4,3]', description: '2x2 matrix spiral', got: JSON.stringify(fn([[1,2],[3,4]])) },\n    { pass: JSON.stringify(fn([[1]])) === '[1]', description: '1x1 matrix → [1]', got: JSON.stringify(fn([[1]])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'empty matrix → []', got: JSON.stringify(fn([])) },\n    { pass: JSON.stringify(fn([[1,2,3,4]])) === '[1,2,3,4]', description: 'single row → [1,2,3,4]', got: JSON.stringify(fn([[1,2,3,4]])) },\n    { pass: JSON.stringify(fn([[1],[2],[3]])) === '[1,2,3]', description: 'single column → [1,2,3]', got: JSON.stringify(fn([[1],[2],[3]])) },\n  ];\n}",
      "hint": "Use four boundary variables: top, bottom, left, right. In a loop: traverse right along top row (then top++), down along right column (then right--), left along bottom row if top <= bottom (then bottom--), up along left column if left <= right (then left++).",
      "resources": [
        {
          "label": "LeetCode: Spiral Matrix",
          "url": "https://leetcode.com/problems/spiral-matrix/"
        }
      ],
      "hints": [
        "Start by thinking about array methods.",
        "Use four boundary variables: top, bottom, left, right. In a loop: traverse right along top row (then top++), down along right column (then right--), left along bottom row if top <= bottom (then bottom--), up along left column if left <= right (then left++).",
        "Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 320,
      "title": "Merge Intervals",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "sorting",
        "intervals",
        "tier3"
      ],
      "description": "Merge all overlapping intervals in a collection.",
      "instructions": "Write a function called `mergeIntervals` that takes an array of intervals (each an array [start, end]) and merges all overlapping intervals.\n\nReturn a new array of merged intervals sorted by start time.\n\nApproach: Sort by start time, then iterate. If the current interval overlaps with the previous one (current start <= previous end), merge them. Otherwise, start a new interval.\n\nExamples:\n  mergeIntervals([[1,3],[2,6],[8,10],[15,18]]) → [[1,6],[8,10],[15,18]]\n  mergeIntervals([[1,4],[4,5]])                → [[1,5]]\n  mergeIntervals([[1,4],[0,4]])                → [[0,4]]",
      "starterCode": "function mergeIntervals(intervals) {\n  // Sort by start, then merge overlapping intervals\n}",
      "solution": "function mergeIntervals(intervals) {\n  if (intervals.length === 0) return [];\n\n  intervals.sort((a, b) => a[0] - b[0]);\n  const merged = [intervals[0]];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const last = merged[merged.length - 1];\n    const current = intervals[i];\n\n    if (current[0] <= last[1]) {\n      last[1] = Math.max(last[1], current[1]);\n    } else {\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return mergeIntervals;')();\n  return [\n    { pass: JSON.stringify(fn([[1,3],[2,6],[8,10],[15,18]])) === '[[1,6],[8,10],[15,18]]', description: 'merges overlapping intervals', got: JSON.stringify(fn([[1,3],[2,6],[8,10],[15,18]])) },\n    { pass: JSON.stringify(fn([[1,4],[4,5]])) === '[[1,5]]', description: 'touching intervals merge [[1,4],[4,5]] → [[1,5]]', got: JSON.stringify(fn([[1,4],[4,5]])) },\n    { pass: JSON.stringify(fn([[1,4],[0,4]])) === '[[0,4]]', description: 'unsorted input [[1,4],[0,4]] → [[0,4]]', got: JSON.stringify(fn([[1,4],[0,4]])) },\n    { pass: JSON.stringify(fn([[1,4],[2,3]])) === '[[1,4]]', description: 'fully contained interval [[1,4],[2,3]] → [[1,4]]', got: JSON.stringify(fn([[1,4],[2,3]])) },\n    { pass: JSON.stringify(fn([])) === '[]', description: 'empty input → []', got: JSON.stringify(fn([])) },\n  ];\n}",
      "hint": "Sort intervals by start time. Initialize result with the first interval. For each subsequent interval, check if it overlaps with the last merged interval (current start <= last end). If yes, extend the end. If no, push a new interval.",
      "resources": [
        {
          "label": "LeetCode: Merge Intervals",
          "url": "https://leetcode.com/problems/merge-intervals/"
        }
      ],
      "hints": [
        "The `sort` method will be helpful here.",
        "Sort intervals by start time. Initialize result with the first interval. For each subsequent interval, check if it overlaps with the last merged interval (current start <= last end). If yes, extend the end. If no, push a new interval.",
        "Key method(s): `sort`, `max`, `Math.max`. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 321,
      "title": "String Compression",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "compression",
        "tier2"
      ],
      "description": "Compress a string by counting consecutive repeated characters. Only return compressed version if shorter.",
      "instructions": "Write a function called `compress` that takes a string and returns a compressed version where consecutive duplicate characters are replaced by the character followed by the count.\n\nOnly return the compressed string if it is shorter than the original. Otherwise, return the original string.\n\nExamples:\n  compress(\"aabcccccaaa\") → \"a2b1c5a3\"\n  compress(\"abc\")         → \"abc\" (compressed \"a1b1c1\" is not shorter)\n  compress(\"aabb\")        → \"aabb\" (compressed \"a2b2\" is same length)\n  compress(\"\")            → \"\"",
      "starterCode": "function compress(str) {\n\n}",
      "solution": "function compress(str) {\n  if (str.length === 0) return '';\n\n  let compressed = '';\n  let count = 1;\n\n  for (let i = 1; i <= str.length; i++) {\n    if (i < str.length && str[i] === str[i - 1]) {\n      count++;\n    } else {\n      compressed += str[i - 1] + count;\n      count = 1;\n    }\n  }\n\n  return compressed.length < str.length ? compressed : str;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return compress;')();\n  return [\n    { pass: fn('aabcccccaaa') === 'a2b1c5a3', description: '\"aabcccccaaa\" → \"a2b1c5a3\"', got: fn('aabcccccaaa') },\n    { pass: fn('abc') === 'abc', description: '\"abc\" → \"abc\" (not shorter)', got: fn('abc') },\n    { pass: fn('aabb') === 'aabb', description: '\"aabb\" → \"aabb\" (same length)', got: fn('aabb') },\n    { pass: fn('') === '', description: 'empty string → \"\"', got: fn('') },\n    { pass: fn('aaa') === 'a3', description: '\"aaa\" → \"a3\"', got: fn('aaa') },\n    { pass: fn('a') === 'a', description: 'single char → \"a\"', got: fn('a') },\n  ];\n}",
      "hint": "Iterate through the string, counting consecutive characters. When the character changes (or you reach the end), append the character and its count to a result string. At the end, return the shorter of the two strings.",
      "resources": [
        {
          "label": "Cracking the Coding Interview: String Compression",
          "url": "https://www.geeksforgeeks.org/run-length-encoding/"
        }
      ],
      "hints": [
        "As you walk through the string, how do you count consecutive identical characters and decide when to write the count?",
        "Iterate through the string, counting consecutive characters. When the character changes (or you reach the end), append the character and its count to a result string. At the end, return the shorter of the two strings.",
        "Use a loop to iterate, then return the accumulated result. The function should return a string."
      ]
    },
    {
      "id": 322,
      "title": "Longest Common Prefix",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "comparison",
        "tier2"
      ],
      "description": "Find the longest common prefix string amongst an array of strings.",
      "instructions": "Write a function called `longestCommonPrefix` that takes an array of strings and returns the longest common prefix.\n\nIf there is no common prefix, return an empty string.\n\nExamples:\n  longestCommonPrefix([\"flower\", \"flow\", \"flight\"]) → \"fl\"\n  longestCommonPrefix([\"dog\", \"racecar\", \"car\"])     → \"\"\n  longestCommonPrefix([\"a\"])                         → \"a\"\n  longestCommonPrefix([])                            → \"\"",
      "starterCode": "function longestCommonPrefix(strs) {\n\n}",
      "solution": "function longestCommonPrefix(strs) {\n  if (strs.length === 0) return '';\n\n  let prefix = strs[0];\n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.slice(0, -1);\n      if (prefix === '') return '';\n    }\n  }\n\n  return prefix;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return longestCommonPrefix;')();\n  return [\n    { pass: fn(['flower', 'flow', 'flight']) === 'fl', description: '[\"flower\",\"flow\",\"flight\"] → \"fl\"', got: fn(['flower', 'flow', 'flight']) },\n    { pass: fn(['dog', 'racecar', 'car']) === '', description: '[\"dog\",\"racecar\",\"car\"] → \"\"', got: fn(['dog', 'racecar', 'car']) },\n    { pass: fn(['a']) === 'a', description: '[\"a\"] → \"a\"', got: fn(['a']) },\n    { pass: fn([]) === '', description: '[] → \"\"', got: fn([]) },\n    { pass: fn(['abc', 'abc', 'abc']) === 'abc', description: 'all same → \"abc\"', got: fn(['abc', 'abc', 'abc']) },\n    { pass: fn(['', 'abc']) === '', description: 'empty string in array → \"\"', got: fn(['', 'abc']) },\n  ];\n}",
      "hint": "Start with the first string as the prefix. For each subsequent string, shorten the prefix from the end until it matches the beginning of that string. If the prefix becomes empty, return \"\".",
      "resources": [
        {
          "label": "LeetCode: Longest Common Prefix",
          "url": "https://leetcode.com/problems/longest-common-prefix/"
        }
      ],
      "hints": [
        "If you start with the first string as your guess and shorten it character by character, when do you stop?",
        "Start with the first string as the prefix. For each subsequent string, shorten the prefix from the end until it matches the beginning of that string. If the prefix becomes empty, return \"\".",
        "Key method(s): `indexOf`, `slice`. Use a loop to iterate, then return the accumulated result. The function should return a string."
      ]
    },
    {
      "id": 323,
      "title": "Is Subsequence",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "two-pointer",
        "tier2"
      ],
      "description": "Check if a string is a subsequence of another string.",
      "instructions": "Write a function called `isSubsequence` that takes two strings s and t, and returns `true` if s is a subsequence of t.\n\nA subsequence means the characters of s appear in t in the same order, but not necessarily consecutively.\n\nUse a two-pointer approach: one pointer for each string.\n\nExamples:\n  isSubsequence(\"ace\", \"abcde\")      → true  (a_c_e)\n  isSubsequence(\"aec\", \"abcde\")      → false\n  isSubsequence(\"\", \"anything\")      → true\n  isSubsequence(\"a\", \"a\")            → true\n  isSubsequence(\"abc\", \"ab\")         → false",
      "starterCode": "function isSubsequence(s, t) {\n\n}",
      "solution": "function isSubsequence(s, t) {\n  let si = 0;\n  let ti = 0;\n\n  while (si < s.length && ti < t.length) {\n    if (s[si] === t[ti]) {\n      si++;\n    }\n    ti++;\n  }\n\n  return si === s.length;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return isSubsequence;')();\n  return [\n    { pass: fn('ace', 'abcde') === true, description: '\"ace\" is subsequence of \"abcde\" → true', got: fn('ace', 'abcde') },\n    { pass: fn('aec', 'abcde') === false, description: '\"aec\" is NOT subsequence of \"abcde\" → false', got: fn('aec', 'abcde') },\n    { pass: fn('', 'anything') === true, description: 'empty string is always a subsequence → true', got: fn('', 'anything') },\n    { pass: fn('a', 'a') === true, description: '\"a\" is subsequence of \"a\" → true', got: fn('a', 'a') },\n    { pass: fn('abc', 'ab') === false, description: '\"abc\" longer than \"ab\" → false', got: fn('abc', 'ab') },\n    { pass: fn('b', 'abc') === true, description: '\"b\" is subsequence of \"abc\" → true', got: fn('b', 'abc') },\n  ];\n}",
      "hint": "Use two pointers: one for s (si) and one for t (ti). Walk through t. Whenever t[ti] matches s[si], advance si. Always advance ti. After the loop, check if si reached the end of s.",
      "resources": [
        {
          "label": "LeetCode: Is Subsequence",
          "url": "https://leetcode.com/problems/is-subsequence/"
        }
      ],
      "hints": [
        "If you use one pointer for each string and only advance the subsequence pointer on a match, when have you confirmed it's a subsequence?",
        "Use two pointers: one for s (si) and one for t (ti). Walk through t. Whenever t[ti] matches s[si], advance si. Always advance ti. After the loop, check if si reached the end of s.",
        "Break the problem into smaller steps and handle edge cases."
      ]
    },
    {
      "id": 324,
      "title": "Implement a Set",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "class",
        "data-structures",
        "set",
        "tier3"
      ],
      "description": "Build your own Set data structure with add, has, delete, size, and values methods.",
      "instructions": "Create a class called `MySet` that implements a basic Set data structure (without using the built-in Set).\n\nMethods:\n- `add(value)` — adds a value to the set (no duplicates)\n- `has(value)` — returns true if the value exists in the set\n- `delete(value)` — removes a value from the set, returns true if it existed\n- `size()` — returns the number of elements in the set\n- `values()` — returns an array of all values in the set\n\n```js\nconst s = new MySet();\ns.add(1);\ns.add(2);\ns.add(1);         // duplicate, ignored\ns.size();         // 2\ns.has(1);         // true\ns.has(3);         // false\ns.delete(1);      // true\ns.has(1);         // false\ns.size();         // 1\ns.values();       // [2]\n```",
      "starterCode": "class MySet {\n  constructor() {\n    // your code here\n  }\n\n  add(value) {\n    // your code here\n  }\n\n  has(value) {\n    // your code here\n  }\n\n  delete(value) {\n    // your code here\n  }\n\n  size() {\n    // your code here\n  }\n\n  values() {\n    // your code here\n  }\n}",
      "solution": "class MySet {\n  constructor() {\n    this._items = {};\n  }\n\n  add(value) {\n    this._items[value] = true;\n  }\n\n  has(value) {\n    return this._items.hasOwnProperty(value);\n  }\n\n  delete(value) {\n    if (this.has(value)) {\n      delete this._items[value];\n      return true;\n    }\n    return false;\n  }\n\n  size() {\n    return Object.keys(this._items).length;\n  }\n\n  values() {\n    return Object.keys(this._items);\n  }\n}",
      "testRunner": "(code) => {\n  const MySet = new Function(code + '; return MySet;')();\n  const s = new MySet();\n  s.add(1);\n  s.add(2);\n  s.add(1);\n  const sizeAfterAdd = s.size();\n  const has1 = s.has(1);\n  const has3 = s.has(3);\n  const del1 = s.delete(1);\n  const has1After = s.has(1);\n  const sizeAfterDel = s.size();\n  const del3 = s.delete(3);\n  return [\n    { pass: sizeAfterAdd === 2, description: 'size is 2 after adding 1, 2, 1 (duplicate ignored)', got: sizeAfterAdd },\n    { pass: has1 === true, description: 'has(1) → true', got: has1 },\n    { pass: has3 === false, description: 'has(3) → false', got: has3 },\n    { pass: del1 === true, description: 'delete(1) returns true', got: del1 },\n    { pass: has1After === false, description: 'has(1) → false after delete', got: has1After },\n    { pass: sizeAfterDel === 1, description: 'size is 1 after deleting 1', got: sizeAfterDel },\n    { pass: del3 === false, description: 'delete(3) returns false (not found)', got: del3 },\n  ];\n}",
      "hint": "Use an object internally where keys represent the set values. add() sets obj[value] = true. has() checks hasOwnProperty. delete() uses the delete operator. size() uses Object.keys().length.",
      "resources": [
        {
          "label": "MDN: Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        }
      ],
      "hints": [
        "How can an object's keys serve as a collection of unique values, since each key can only appear once?",
        "Use an object internally where keys represent the set values. add() sets obj[value] = true. has() checks hasOwnProperty. delete() uses the delete operator. size() uses Object.keys().length.",
        "Key method(s): `hasOwnProperty`, `has`, `keys`. The function should return a boolean."
      ]
    },
    {
      "id": 325,
      "title": "LRU Cache",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "class",
        "data-structures",
        "cache",
        "design-pattern",
        "tier4"
      ],
      "description": "Implement a Least Recently Used (LRU) cache with O(1) get and put operations.",
      "instructions": "Create a class called `LRUCache` that implements a least recently used cache.\n\n**Constructor:** takes a capacity (positive integer)\n\n**Methods:**\n- `get(key)` — returns the value associated with the key, or -1 if not found. Marks the key as recently used.\n- `put(key, value)` — adds or updates a key-value pair. If adding would exceed capacity, evict the least recently used item first.\n\nA key becomes \"most recently used\" whenever it is accessed via get() or updated via put().\n\n```js\nconst cache = new LRUCache(2);  // capacity 2\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 1 (marks key 1 as recently used)\ncache.put(3, 3);    // evicts key 2 (least recently used)\ncache.get(2);       // -1 (was evicted)\ncache.get(3);       // 3\n```",
      "starterCode": "class LRUCache {\n  constructor(capacity) {\n    // your code here\n  }\n\n  get(key) {\n    // Returns value or -1 if not found\n  }\n\n  put(key, value) {\n    // Evicts least recently used if at capacity\n  }\n}",
      "solution": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}",
      "testRunner": "(code) => {\n  const LRUCache = new Function(code + '; return LRUCache;')();\n  const cache = new LRUCache(2);\n  cache.put(1, 1);\n  cache.put(2, 2);\n  const get1 = cache.get(1);\n  cache.put(3, 3);\n  const get2 = cache.get(2);\n  const get3 = cache.get(3);\n  cache.put(4, 4);\n  const get1b = cache.get(1);\n  const get3b = cache.get(3);\n  const get4 = cache.get(4);\n  return [\n    { pass: get1 === 1, description: 'get(1) → 1 (exists)', got: get1 },\n    { pass: get2 === -1, description: 'get(2) → -1 (evicted by put(3,3))', got: get2 },\n    { pass: get3 === 3, description: 'get(3) → 3', got: get3 },\n    { pass: get1b === -1, description: 'get(1) → -1 (evicted by put(4,4))', got: get1b },\n    { pass: get3b === 3, description: 'get(3) → 3 (still in cache)', got: get3b },\n    { pass: get4 === 4, description: 'get(4) → 4', got: get4 },\n    { pass: (() => { const c = new LRUCache(1); c.put(1, 10); c.put(1, 20); return c.get(1) === 20; })(), description: 'put overwrites existing key', got: (() => { const c = new LRUCache(1); c.put(1, 10); c.put(1, 20); return c.get(1); })() },\n  ];\n}",
      "hint": "Use a Map, which maintains insertion order. On get(): delete and re-insert the key to move it to the end (most recent). On put(): if key exists, delete it first. If at capacity, delete the first key (Map.keys().next().value). Then set the new key.",
      "resources": [
        {
          "label": "LeetCode: LRU Cache",
          "url": "https://leetcode.com/problems/lru-cache/"
        },
        {
          "label": "MDN: Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        }
      ],
      "hints": [
        "The `keys` method will be helpful here.",
        "Use a Map, which maintains insertion order. On get(): delete and re-insert the key to move it to the end (most recent). On put(): if key exists, delete it first. If at capacity, delete the first key (Map.keys().next().value). Then set the new key.",
        "Key method(s): `has`, `get`, `delete`. The function should return a boolean."
      ]
    },
    {
      "id": 326,
      "title": "Validate Email",
      "type": "js",
      "tier": 2,
      "category": [
        "regex",
        "basics"
      ],
      "tags": [
        "regex",
        "validation",
        "strings"
      ],
      "description": "Write a function that validates whether a given string is a plausible email address using a regular expression.",
      "instructions": "Write a function called `validateEmail` that takes a string and returns `true` if it looks like a valid email address, or `false` otherwise.\n\nA valid email has:\n- One or more non-whitespace, non-@ characters before the @\n- An @ symbol\n- One or more non-whitespace, non-@ characters for the domain\n- A dot\n- One or more non-whitespace, non-@ characters for the TLD\n\nExamples:\n  validateEmail(\"user@example.com\")        → true\n  validateEmail(\"user.name+tag@domain.co\") → true\n  validateEmail(\"invalid\")                 → false\n  validateEmail(\"@domain.com\")             → false\n  validateEmail(\"user@\")                   → false\n  validateEmail(\"\")                        → false",
      "starterCode": "function validateEmail(email) {\n\n}",
      "solution": "function validateEmail(email) {\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return validateEmail;')();\n  return [\n    { pass: fn(\"user@example.com\") === true, description: '\"user@example.com\" is valid', got: String(fn(\"user@example.com\")) },\n    { pass: fn(\"user.name+tag@domain.co\") === true, description: '\"user.name+tag@domain.co\" is valid', got: String(fn(\"user.name+tag@domain.co\")) },\n    { pass: fn(\"invalid\") === false, description: '\"invalid\" is not valid', got: String(fn(\"invalid\")) },\n    { pass: fn(\"@domain.com\") === false, description: '\"@domain.com\" is not valid', got: String(fn(\"@domain.com\")) },\n    { pass: fn(\"user@\") === false, description: '\"user@\" is not valid', got: String(fn(\"user@\")) },\n    { pass: fn(\"\") === false, description: 'empty string is not valid', got: String(fn(\"\")) },\n  ];\n}",
      "hint": "Use the regex /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ and the .test() method. The character class [^\\s@] matches anything that is not whitespace or @.",
      "resources": [
        {
          "label": "MDN: RegExp.prototype.test()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"
        },
        {
          "label": "RegExr: Learn, Build & Test",
          "url": "https://regexr.com/"
        }
      ],
      "hints": [
        "Consider how `test` works.",
        "Use the regex /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ and the .test() method. The character class [^\\s@] matches anything that is not whitespace or @.",
        "Key method(s): `test`."
      ]
    },
    {
      "id": 327,
      "title": "Validate Phone Number",
      "type": "js",
      "tier": 2,
      "category": [
        "regex",
        "basics"
      ],
      "tags": [
        "regex",
        "validation",
        "strings"
      ],
      "description": "Write a function that checks whether a string matches common US phone number formats.",
      "instructions": "Write a function called `validatePhone` that takes a string and returns `true` if it matches a valid US phone number format.\n\nAccepted formats:\n- (123) 456-7890\n- (123)456-7890\n- 123-456-7890\n- 1234567890\n\nExamples:\n  validatePhone(\"(123) 456-7890\")  → true\n  validatePhone(\"123-456-7890\")    → true\n  validatePhone(\"1234567890\")      → true\n  validatePhone(\"123-45-6789\")     → false\n  validatePhone(\"abc\")             → false\n  validatePhone(\"(123)456-7890\")   → true",
      "starterCode": "function validatePhone(phone) {\n\n}",
      "solution": "function validatePhone(phone) {\n  return /^(\\(\\d{3}\\)\\s?|\\d{3}[-]?)\\d{3}[-]?\\d{4}$/.test(phone);\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return validatePhone;')();\n  return [\n    { pass: fn(\"(123) 456-7890\") === true, description: '\"(123) 456-7890\" is valid', got: String(fn(\"(123) 456-7890\")) },\n    { pass: fn(\"123-456-7890\") === true, description: '\"123-456-7890\" is valid', got: String(fn(\"123-456-7890\")) },\n    { pass: fn(\"1234567890\") === true, description: '\"1234567890\" is valid', got: String(fn(\"1234567890\")) },\n    { pass: fn(\"123-45-6789\") === false, description: '\"123-45-6789\" is not valid', got: String(fn(\"123-45-6789\")) },\n    { pass: fn(\"abc\") === false, description: '\"abc\" is not valid', got: String(fn(\"abc\")) },\n    { pass: fn(\"(123)456-7890\") === true, description: '\"(123)456-7890\" is valid', got: String(fn(\"(123)456-7890\")) },\n  ];\n}",
      "hint": "Break the pattern into parts: optional area code in parens with optional space OR digits with optional dash, then 3 digits, optional dash, then 4 digits. Use \\d{3} to match exactly 3 digits.",
      "resources": [
        {
          "label": "MDN: Regular Expressions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions"
        }
      ],
      "hints": [
        "What characters can appear between the digit groups in a phone number, and how do you express \"this character is optional\" in a regex?",
        "Break the pattern into parts: optional area code in parens with optional space OR digits with optional dash, then 3 digits, optional dash, then 4 digits. Use \\d{3} to match exactly 3 digits.",
        "Key method(s): `test`."
      ]
    },
    {
      "id": 328,
      "title": "Extract Numbers from String",
      "type": "js",
      "tier": 2,
      "category": [
        "regex",
        "basics"
      ],
      "tags": [
        "regex",
        "extraction",
        "strings"
      ],
      "description": "Use a regular expression to find all sequences of digits in a string and return them as an array of numbers.",
      "instructions": "Write a function called `extractNumbers` that takes a string and returns an array of all the numbers found in it.\n\nEach contiguous sequence of digits counts as one number. Return them as actual numbers (not strings). If no numbers are found, return an empty array.\n\nExamples:\n  extractNumbers(\"abc123def456\")              → [123, 456]\n  extractNumbers(\"no numbers\")                → []\n  extractNumbers(\"42\")                        → [42]\n  extractNumbers(\"price: $9.99 and $12.50\")   → [9, 99, 12, 50]\n  extractNumbers(\"\")                          → []",
      "starterCode": "function extractNumbers(str) {\n\n}",
      "solution": "function extractNumbers(str) {\n  return (str.match(/\\d+/g) || []).map(Number);\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return extractNumbers;')();\n  return [\n    { pass: JSON.stringify(fn(\"abc123def456\")) === '[123,456]', description: '\"abc123def456\" yields [123, 456]', got: JSON.stringify(fn(\"abc123def456\")) },\n    { pass: JSON.stringify(fn(\"no numbers\")) === '[]', description: '\"no numbers\" yields []', got: JSON.stringify(fn(\"no numbers\")) },\n    { pass: JSON.stringify(fn(\"42\")) === '[42]', description: '\"42\" yields [42]', got: JSON.stringify(fn(\"42\")) },\n    { pass: JSON.stringify(fn(\"price: $9.99 and $12.50\")) === '[9,99,12,50]', description: 'decimal prices yield individual number groups', got: JSON.stringify(fn(\"price: $9.99 and $12.50\")) },\n    { pass: JSON.stringify(fn(\"\")) === '[]', description: 'empty string yields []', got: JSON.stringify(fn(\"\")) },\n  ];\n}",
      "hint": "Use str.match(/\\d+/g) to find all digit sequences. The g flag finds all matches. Handle the null case when no matches are found (match returns null, not []).",
      "resources": [
        {
          "label": "MDN: String.prototype.match()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"
        }
      ],
      "hints": [
        "`match` is a key tool for this exercise.",
        "Use str.match(/\\d+/g) to find all digit sequences. The g flag finds all matches. Handle the null case when no matches are found (match returns null, not []).",
        "Key method(s): `match`, `map`. Map each element to its transformed value. The function should return an array."
      ]
    },
    {
      "id": 329,
      "title": "Match HTML Tags",
      "type": "js",
      "tier": 3,
      "category": [
        "regex",
        "basics"
      ],
      "tags": [
        "regex",
        "patterns",
        "strings"
      ],
      "description": "Extract all opening HTML tag names from a string using a regular expression.",
      "instructions": "Write a function called `extractTagNames` that takes an HTML string and returns an array of all opening tag names found in it.\n\nOnly extract the tag name itself (e.g., \"div\", \"p\", \"img\"), not closing tags (those starting with </).\n\nExamples:\n  extractTagNames(\"<div><p>hello</p></div>\")         → [\"div\", \"p\"]\n  extractTagNames(\"<img src='x'/><br/>\")              → [\"img\", \"br\"]\n  extractTagNames(\"no tags\")                         → []\n  extractTagNames(\"<h1 class='title'>Hi</h1>\")       → [\"h1\"]\n  extractTagNames(\"<ul><li>A</li><li>B</li></ul>\")   → [\"ul\", \"li\", \"li\"]",
      "starterCode": "function extractTagNames(html) {\n  // Extract all opening HTML tag names\n  // e.g. \"<div><p>hello</p></div>\" → [\"div\", \"p\"]\n}",
      "solution": "function extractTagNames(html) {\n  return [...html.matchAll(/<([a-zA-Z][a-zA-Z0-9]*)[^>]*\\/?>/g)].map(m => m[1]);\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return extractTagNames;')();\n  return [\n    { pass: JSON.stringify(fn(\"<div><p>hello</p></div>\")) === '[\"div\",\"p\"]', description: '\"<div><p>hello</p></div>\" yields [\"div\",\"p\"]', got: JSON.stringify(fn(\"<div><p>hello</p></div>\")) },\n    { pass: JSON.stringify(fn(\"<img src='x'/><br/>\")) === '[\"img\",\"br\"]', description: 'self-closing tags extracted correctly', got: JSON.stringify(fn(\"<img src='x'/><br/>\")) },\n    { pass: JSON.stringify(fn(\"no tags\")) === '[]', description: '\"no tags\" yields []', got: JSON.stringify(fn(\"no tags\")) },\n    { pass: JSON.stringify(fn(\"<h1 class='title'>Hi</h1>\")) === '[\"h1\"]', description: 'tag with attributes yields [\"h1\"]', got: JSON.stringify(fn(\"<h1 class='title'>Hi</h1>\")) },\n    { pass: JSON.stringify(fn(\"<ul><li>A</li><li>B</li></ul>\")) === '[\"ul\",\"li\",\"li\"]', description: 'repeated tags are each captured', got: JSON.stringify(fn(\"<ul><li>A</li><li>B</li></ul>\")) },\n  ];\n}",
      "hint": "Use matchAll with a regex that captures the tag name in a group. The pattern /<([a-zA-Z][a-zA-Z0-9]*)[^>]*\\/?>/g matches opening tags (including self-closing ones) while skipping closing tags that start with </.",
      "resources": [
        {
          "label": "MDN: String.prototype.matchAll()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"
        }
      ],
      "hints": [
        "What pattern do all opening HTML tags share — what comes right after the `<` character?",
        "Use matchAll with a regex that captures the tag name in a group. The pattern /<([a-zA-Z][a-zA-Z0-9]*)[^>]*\\/?>/g matches opening tags (including self-closing ones) while skipping closing tags that start with </.",
        "Key method(s): `matchAll`, `map`. Map each element to its transformed value. The function should return an array."
      ]
    },
    {
      "id": 330,
      "title": "Password Strength Validator",
      "type": "js",
      "tier": 3,
      "category": [
        "regex",
        "patterns"
      ],
      "tags": [
        "regex",
        "validation",
        "strings"
      ],
      "description": "Classify a password as \"weak\", \"medium\", or \"strong\" based on its length and character variety.",
      "instructions": "Write a function called `passwordStrength` that takes a password string and returns one of three ratings:\n\n- **\"weak\"**: fewer than 8 characters, OR 8+ characters but only one type of character\n- **\"medium\"**: 8+ characters with both letters and numbers (but not all four groups)\n- **\"strong\"**: 8+ characters with all four: uppercase letter, lowercase letter, digit, and special character\n\nExamples:\n  passwordStrength(\"abc\")        → \"weak\"\n  passwordStrength(\"abcd1234\")   → \"medium\"\n  passwordStrength(\"Abcd123!\")   → \"strong\"\n  passwordStrength(\"ABCD1234\")   → \"medium\"\n  passwordStrength(\"Ab1!\")       → \"weak\"\n  passwordStrength(\"abcdefgh\")   → \"weak\"",
      "starterCode": "function passwordStrength(password) {\n  // Return \"weak\", \"medium\", or \"strong\"\n  // weak: < 8 chars\n  // medium: 8+ chars with both letters and numbers\n  // strong: 8+ chars with uppercase, lowercase, number, and special char\n}",
      "solution": "function passwordStrength(password) {\n  if (password.length < 8) return \"weak\";\n  const hasUpper = /[A-Z]/.test(password);\n  const hasLower = /[a-z]/.test(password);\n  const hasDigit = /\\d/.test(password);\n  const hasSpecial = /[^a-zA-Z0-9]/.test(password);\n  if (hasUpper && hasLower && hasDigit && hasSpecial) return \"strong\";\n  const hasLetters = hasUpper || hasLower;\n  if (hasLetters && hasDigit) return \"medium\";\n  return \"weak\";\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return passwordStrength;')();\n  return [\n    { pass: fn(\"abc\") === \"weak\", description: '\"abc\" is weak (too short)', got: fn(\"abc\") },\n    { pass: fn(\"abcd1234\") === \"medium\", description: '\"abcd1234\" is medium (letters + numbers)', got: fn(\"abcd1234\") },\n    { pass: fn(\"Abcd123!\") === \"strong\", description: '\"Abcd123!\" is strong (all four groups)', got: fn(\"Abcd123!\") },\n    { pass: fn(\"ABCD1234\") === \"medium\", description: '\"ABCD1234\" is medium (uppercase + digits)', got: fn(\"ABCD1234\") },\n    { pass: fn(\"Ab1!\") === \"weak\", description: '\"Ab1!\" is weak (too short)', got: fn(\"Ab1!\") },\n    { pass: fn(\"abcdefgh\") === \"weak\", description: '\"abcdefgh\" is weak (only lowercase)', got: fn(\"abcdefgh\") },\n  ];\n}",
      "hint": "First check length. Then test the password against separate regexes for uppercase (/[A-Z]/), lowercase (/[a-z]/), digits (/\\d/), and special characters (/[^a-zA-Z0-9]/). Count how many groups are present to determine the rating.",
      "resources": [
        {
          "label": "MDN: Regular Expressions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions"
        }
      ],
      "hints": [
        "The `test` method will be helpful here.",
        "First check length. Then test the password against separate regexes for uppercase (/[A-Z]/), lowercase (/[a-z]/), digits (/\\d/), and special characters (/[^a-zA-Z0-9]/). Count how many groups are present to determine the rating.",
        "Key method(s): `test`. The function should return a string."
      ]
    },
    {
      "id": 331,
      "title": "URL Parser",
      "type": "js",
      "tier": 3,
      "category": [
        "regex",
        "patterns"
      ],
      "tags": [
        "regex",
        "extraction",
        "strings"
      ],
      "description": "Parse a URL string into its component parts using regular expressions.",
      "instructions": "Write a function called `parseURL` that takes a URL string and returns an object with the following properties:\n- `protocol`: the protocol (e.g., \"https\", \"http\", \"ftp\")\n- `host`: the hostname (e.g., \"example.com\")\n- `path`: the path portion (e.g., \"/path/to/page\"), or \"\" if none\n- `query`: the query string without the \"?\" (e.g., \"key=val&a=b\"), or \"\" if none\n\nExamples:\n  parseURL(\"https://example.com/path?key=val\")\n  // { protocol: \"https\", host: \"example.com\", path: \"/path\", query: \"key=val\" }\n\n  parseURL(\"http://google.com\")\n  // { protocol: \"http\", host: \"google.com\", path: \"\", query: \"\" }\n\n  parseURL(\"ftp://files.server.com/docs\")\n  // { protocol: \"ftp\", host: \"files.server.com\", path: \"/docs\", query: \"\" }",
      "starterCode": "function parseURL(url) {\n  // Return { protocol, host, path, query }\n}",
      "solution": "function parseURL(url) {\n  const match = url.match(/^(https?|ftp):\\/\\/([^\\/\\?]+)(\\/[^\\?]*)?(?:\\?(.*))?$/);\n  if (!match) return { protocol: \"\", host: \"\", path: \"\", query: \"\" };\n  return {\n    protocol: match[1] || \"\",\n    host: match[2] || \"\",\n    path: match[3] || \"\",\n    query: match[4] || \"\",\n  };\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return parseURL;')();\n  const r1 = fn(\"https://example.com/path?key=val\");\n  const r2 = fn(\"http://google.com\");\n  const r3 = fn(\"ftp://files.server.com/docs\");\n  return [\n    { pass: r1.protocol === \"https\", description: 'protocol is \"https\"', got: r1.protocol },\n    { pass: r1.host === \"example.com\", description: 'host is \"example.com\"', got: r1.host },\n    { pass: r1.path === \"/path\", description: 'path is \"/path\"', got: r1.path },\n    { pass: r1.query === \"key=val\", description: 'query is \"key=val\"', got: r1.query },\n    { pass: r2.protocol === \"http\" && r2.host === \"google.com\", description: 'parses \"http://google.com\" correctly', got: JSON.stringify(r2) },\n    { pass: r2.path === \"\" && r2.query === \"\", description: 'no path or query yields empty strings', got: JSON.stringify({ path: r2.path, query: r2.query }) },\n    { pass: r3.protocol === \"ftp\" && r3.host === \"files.server.com\" && r3.path === \"/docs\", description: 'parses ftp URL correctly', got: JSON.stringify(r3) },\n  ];\n}",
      "hint": "Build a regex with capture groups for each part: ^(https?|ftp):\\/\\/([^\\/\\?]+)(\\/[^\\?]*)?(?:\\?(.*))?$ — group 1 is protocol, group 2 is host, group 3 is path, group 4 is query.",
      "resources": [
        {
          "label": "MDN: String.prototype.match()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"
        }
      ],
      "hints": [
        "Consider how `match` works.",
        "Build a regex with capture groups for each part: ^(https?|ftp):\\/\\/([^\\/\\?]+)(\\/[^\\?]*)?(?:\\?(.*))?$ — group 1 is protocol, group 2 is host, group 3 is path, group 4 is query.",
        "Key method(s): `match`. The function should return an object."
      ]
    },
    {
      "id": 332,
      "title": "Markdown Bold/Italic Converter",
      "type": "js",
      "tier": 3,
      "category": [
        "regex",
        "patterns"
      ],
      "tags": [
        "regex",
        "patterns",
        "strings"
      ],
      "description": "Convert Markdown bold and italic syntax to HTML using regular expression replacements.",
      "instructions": "Write a function called `markdownToHtml` that converts basic Markdown formatting to HTML:\n- **bold**: \\*\\*text\\*\\* becomes <strong>text</strong>\n- *italic*: \\*text\\* becomes <em>text</em>\n\nImportant: process bold (\\*\\*) before italic (\\*) so that double-asterisk patterns are handled first.\n\nExamples:\n  markdownToHtml(\"**bold**\")                       → \"<strong>bold</strong>\"\n  markdownToHtml(\"*italic*\")                       → \"<em>italic</em>\"\n  markdownToHtml(\"**bold** and *italic*\")           → \"<strong>bold</strong> and <em>italic</em>\"\n  markdownToHtml(\"no formatting\")                  → \"no formatting\"",
      "starterCode": "function markdownToHtml(text) {\n  // Convert **bold** → <strong>bold</strong>\n  // Convert *italic* → <em>italic</em>\n}",
      "solution": "function markdownToHtml(text) {\n  return text\n    .replace(/\\*\\*(.+?)\\*\\*/g, '<strong>$1</strong>')\n    .replace(/\\*(.+?)\\*/g, '<em>$1</em>');\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return markdownToHtml;')();\n  return [\n    { pass: fn(\"**bold**\") === \"<strong>bold</strong>\", description: '**bold** becomes <strong>bold</strong>', got: fn(\"**bold**\") },\n    { pass: fn(\"*italic*\") === \"<em>italic</em>\", description: '*italic* becomes <em>italic</em>', got: fn(\"*italic*\") },\n    { pass: fn(\"**bold** and *italic*\") === \"<strong>bold</strong> and <em>italic</em>\", description: 'mixed bold and italic', got: fn(\"**bold** and *italic*\") },\n    { pass: fn(\"no formatting\") === \"no formatting\", description: 'plain text unchanged', got: fn(\"no formatting\") },\n  ];\n}",
      "hint": "Use two .replace() calls chained together. Process bold first with /\\*\\*(.+?)\\*\\*/g, then italic with /\\*(.+?)\\*/g. The .+? is a non-greedy match.",
      "resources": [
        {
          "label": "MDN: String.prototype.replace()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"
        }
      ],
      "hints": [
        "What pattern do all opening HTML tags share — what comes right after the `<` character?",
        "Use two .replace() calls chained together. Process bold first with /\\*\\*(.+?)\\*\\*/g, then italic with /\\*(.+?)\\*/g. The .+? is a non-greedy match.",
        "Key method(s): `replace`."
      ]
    },
    {
      "id": 333,
      "title": "Log File Parser",
      "type": "js",
      "tier": 4,
      "category": [
        "regex",
        "extraction"
      ],
      "tags": [
        "regex",
        "extraction",
        "strings"
      ],
      "description": "Parse a multi-line log string into structured objects using regular expressions.",
      "instructions": "Write a function called `parseLogs` that takes a log string (with entries separated by newlines) and returns an array of log entry objects.\n\nEach log line has the format:\n  [TIMESTAMP] LEVEL: message text\n\nFor example:\n  \"[2024-01-15 10:30:00] ERROR: Connection timeout\"\n\nReturn an array of objects with { timestamp, level, message } properties. Skip any lines that don't match the expected format. If the input is empty, return an empty array.\n\nExamples:\n  parseLogs(\"[2024-01-15 10:30:00] ERROR: Connection timeout\")\n  // [{ timestamp: \"2024-01-15 10:30:00\", level: \"ERROR\", message: \"Connection timeout\" }]\n\n  parseLogs(\"[ts1] INFO: Started\\n[ts2] WARN: Low memory\")\n  // [{ timestamp: \"ts1\", level: \"INFO\", message: \"Started\" },\n  //  { timestamp: \"ts2\", level: \"WARN\", message: \"Low memory\" }]\n\n  parseLogs(\"\")  → []",
      "starterCode": "function parseLogs(logString) {\n  // your code here\n}",
      "solution": "function parseLogs(logString) {\n  if (!logString) return [];\n  const regex = /\\[(.+?)\\]\\s+(\\w+):\\s+(.+)/;\n  return logString.split('\\n')\n    .map(line => line.match(regex))\n    .filter(m => m !== null)\n    .map(m => ({ timestamp: m[1], level: m[2], message: m[3] }));\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return parseLogs;')();\n  const single = fn(\"[2024-01-15 10:30:00] ERROR: Connection timeout\");\n  const multi = fn(\"[ts1] INFO: Started\\n[ts2] WARN: Low memory\\n[ts3] ERROR: Disk full\");\n  const empty = fn(\"\");\n  return [\n    { pass: single.length === 1 && single[0].timestamp === \"2024-01-15 10:30:00\", description: 'single line: correct timestamp', got: single.length > 0 ? single[0].timestamp : 'none' },\n    { pass: single.length === 1 && single[0].level === \"ERROR\", description: 'single line: correct level', got: single.length > 0 ? single[0].level : 'none' },\n    { pass: single.length === 1 && single[0].message === \"Connection timeout\", description: 'single line: correct message', got: single.length > 0 ? single[0].message : 'none' },\n    { pass: multi.length === 3, description: 'multi-line: returns 3 entries', got: multi.length },\n    { pass: multi.length === 3 && multi[1].level === \"WARN\" && multi[2].level === \"ERROR\", description: 'multi-line: correct levels', got: multi.map(e => e.level).join(', ') },\n    { pass: Array.isArray(empty) && empty.length === 0, description: 'empty string returns []', got: JSON.stringify(empty) },\n  ];\n}",
      "hint": "Split the input by newlines. For each line, use a regex like /\\[(.+?)\\]\\s+(\\w+):\\s+(.+)/ which captures the timestamp (inside brackets), the level word, and the message. Filter out non-matching lines.",
      "resources": [
        {
          "label": "MDN: String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "label": "MDN: Capturing Groups",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences"
        }
      ],
      "hints": [
        "`split` is a key tool for this exercise.",
        "Split the input by newlines. For each line, use a regex like /\\[(.+?)\\]\\s+(\\w+):\\s+(.+)/ which captures the timestamp (inside brackets), the level word, and the message. Filter out non-matching lines.",
        "Key method(s): `split`, `map`, `match`. Map each element to its transformed value. The function should return an array."
      ]
    },
    {
      "id": 334,
      "title": "Template String Interpolator",
      "type": "js",
      "tier": 4,
      "category": [
        "regex",
        "extraction"
      ],
      "tags": [
        "regex",
        "extraction",
        "strings"
      ],
      "description": "Build a template engine that replaces {{key}} placeholders with values from a data object, supporting nested keys.",
      "instructions": "Write a function called `interpolate` that takes a template string and a data object, and replaces all `{{key}}` placeholders with the corresponding values from the data object.\n\nSupport dot-notation for nested keys (e.g., \"{{user.name}}\" looks up data.user.name). If a key is not found, keep the original placeholder unchanged.\n\nExamples:\n  interpolate(\"Hello {{name}}\", { name: \"World\" })\n  // \"Hello World\"\n\n  interpolate(\"{{user.name}} is {{user.age}}\", { user: { name: \"Alice\", age: 30 } })\n  // \"Alice is 30\"\n\n  interpolate(\"{{missing}} stays\", { name: \"X\" })\n  // \"{{missing}} stays\"",
      "starterCode": "function interpolate(template, data) {\n  // your code here\n}",
      "solution": "function interpolate(template, data) {\n  return template.replace(/\\{\\{([\\w.]+)\\}\\}/g, (_, key) => {\n    const parts = key.split('.');\n    let val = data;\n    for (const p of parts) {\n      val = val != null ? val[p] : undefined;\n    }\n    return val !== undefined ? val : '{{' + key + '}}';\n  });\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return interpolate;')();\n  const r1 = fn(\"Hello {{name}}\", { name: \"World\" });\n  const r2 = fn(\"{{user.name}} is {{user.age}}\", { user: { name: \"Alice\", age: 30 } });\n  const r3 = fn(\"{{missing}} stays\", { name: \"X\" });\n  const r4 = fn(\"{{a}} and {{b}}\", { a: \"1\", b: \"2\" });\n  const r5 = fn(\"no placeholders\", { x: 1 });\n  return [\n    { pass: r1 === \"Hello World\", description: 'simple key replacement', got: r1 },\n    { pass: r2 === \"Alice is 30\", description: 'nested key with dot notation', got: r2 },\n    { pass: r3 === \"{{missing}} stays\", description: 'missing key keeps placeholder', got: r3 },\n    { pass: r4 === \"1 and 2\", description: 'multiple replacements', got: r4 },\n    { pass: r5 === \"no placeholders\", description: 'no placeholders returns unchanged', got: r5 },\n  ];\n}",
      "hint": "Use .replace() with /\\{\\{([\\w.]+)\\}\\}/g. In the replacer function, split the captured key by \".\" and walk into the data object step by step. If any step yields undefined, return the original placeholder.",
      "resources": [
        {
          "label": "MDN: String.prototype.replace()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"
        }
      ],
      "hints": [
        "How can you match the `{{key}}` pattern and use the captured key to look up a value in an object?",
        "Use .replace() with /\\{\\{([\\w.]+)\\}\\}/g. In the replacer function, split the captured key by \".\" and walk into the data object step by step. If any step yields undefined, return the original placeholder.",
        "Key method(s): `replace`, `split`. Use a loop to iterate, then return the accumulated result."
      ]
    },
    {
      "id": 335,
      "title": "Regex-based Tokenizer",
      "type": "js",
      "tier": 5,
      "category": [
        "regex",
        "extraction"
      ],
      "tags": [
        "regex",
        "extraction",
        "strings",
        "advanced"
      ],
      "description": "Build a lexical tokenizer that converts an input string into an array of typed tokens using configurable regex rules.",
      "instructions": "Write a function called `tokenize` that takes an input string and an array of token rules, and returns an array of token objects.\n\nEach rule is an object: `{ type: string, pattern: RegExp }`\n\nThe tokenizer should:\n1. Start at the beginning of the input string\n2. Skip any leading whitespace\n3. Try each rule's pattern at the current position (anchor with ^)\n4. If a rule matches, push `{ type: rule.type, value: matchedText }` and advance past the match\n5. If no rule matches, push `{ type: \"UNKNOWN\", value: currentChar }` and advance by 1\n6. Repeat until the end of the string\n\nExamples:\n  const rules = [\n    { type: 'NUMBER', pattern: /\\d+/ },\n    { type: 'OPERATOR', pattern: /[+\\-*/]/ },\n  ];\n  tokenize(\"42 + 3\", rules)\n  // [{ type: \"NUMBER\", value: \"42\" }, { type: \"OPERATOR\", value: \"+\" }, { type: \"NUMBER\", value: \"3\" }]\n\n  const rules2 = [\n    { type: 'IDENT', pattern: /[a-zA-Z_]\\w*/ },\n    { type: 'ASSIGN', pattern: /=/ },\n    { type: 'NUMBER', pattern: /\\d+/ },\n  ];\n  tokenize(\"x = 10\", rules2)\n  // [{ type: \"IDENT\", value: \"x\" }, { type: \"ASSIGN\", value: \"=\" }, { type: \"NUMBER\", value: \"10\" }]",
      "starterCode": "// Build a tokenizer: tokenize(input, rules) → [{type, value}]\n// rules: [{type: string, pattern: RegExp}]\n// Skip whitespace between tokens\n// Unknown chars → {type: \"UNKNOWN\", value: char}\nfunction tokenize(input, rules) {\n\n}",
      "solution": "function tokenize(input, rules) {\n  const tokens = [];\n  let pos = 0;\n  while (pos < input.length) {\n    // Skip whitespace\n    const wsMatch = input.slice(pos).match(/^\\s+/);\n    if (wsMatch) {\n      pos += wsMatch[0].length;\n      if (pos >= input.length) break;\n    }\n    let matched = false;\n    for (const rule of rules) {\n      const re = new RegExp('^(?:' + rule.pattern.source + ')');\n      const m = input.slice(pos).match(re);\n      if (m) {\n        tokens.push({ type: rule.type, value: m[0] });\n        pos += m[0].length;\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      tokens.push({ type: 'UNKNOWN', value: input[pos] });\n      pos++;\n    }\n  }\n  return tokens;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return tokenize;')();\n  const mathRules = [\n    { type: 'NUMBER', pattern: /\\d+/ },\n    { type: 'OPERATOR', pattern: /[+\\-*/]/ },\n  ];\n  const r1 = fn(\"42 + 3\", mathRules);\n\n  const assignRules = [\n    { type: 'IDENT', pattern: /[a-zA-Z_]\\w*/ },\n    { type: 'ASSIGN', pattern: /=/ },\n    { type: 'NUMBER', pattern: /\\d+/ },\n  ];\n  const r2 = fn(\"x = 10\", assignRules);\n  const r3 = fn(\"hello @ world\", assignRules);\n\n  return [\n    { pass: r1.length === 3 && r1[0].type === 'NUMBER' && r1[0].value === '42', description: 'tokenizes \"42\" as NUMBER', got: JSON.stringify(r1[0]) },\n    { pass: r1.length === 3 && r1[1].type === 'OPERATOR' && r1[1].value === '+', description: 'tokenizes \"+\" as OPERATOR', got: JSON.stringify(r1[1]) },\n    { pass: r1.length === 3 && r1[2].type === 'NUMBER' && r1[2].value === '3', description: 'tokenizes \"3\" as NUMBER', got: JSON.stringify(r1[2]) },\n    { pass: r2.length === 3 && r2[0].type === 'IDENT' && r2[0].value === 'x', description: 'tokenizes \"x\" as IDENT', got: JSON.stringify(r2[0]) },\n    { pass: r2.length === 3 && r2[1].type === 'ASSIGN' && r2[1].value === '=', description: 'tokenizes \"=\" as ASSIGN', got: JSON.stringify(r2[1]) },\n    { pass: r2.length === 3 && r2[2].type === 'NUMBER' && r2[2].value === '10', description: 'tokenizes \"10\" as NUMBER', got: JSON.stringify(r2[2]) },\n    { pass: r3.some(t => t.type === 'UNKNOWN' && t.value === '@'), description: 'unknown char \"@\" produces UNKNOWN token', got: JSON.stringify(r3.find(t => t.type === 'UNKNOWN')) },\n  ];\n}",
      "hint": "Iterate through the string with a position pointer. At each position, skip whitespace first, then try each rule by creating a new RegExp anchored to the start (^) of the remaining string. Use rule.pattern.source to get the pattern text.",
      "resources": [
        {
          "label": "MDN: RegExp constructor",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp"
        },
        {
          "label": "Wikipedia: Lexical Analysis",
          "url": "https://en.wikipedia.org/wiki/Lexical_analysis"
        }
      ],
      "hints": [
        "The `slice` method will be helpful here.",
        "Iterate through the string with a position pointer. At each position, skip whitespace first, then try each rule by creating a new RegExp anchored to the start (^) of the remaining string. Use rule.pattern.source to get the pattern text.",
        "Key method(s): `slice`, `match`, `new RegExp`. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 336,
      "title": "Query and Count Elements",
      "type": "js",
      "tier": 2,
      "category": [
        "dom-manipulation",
        "selection"
      ],
      "tags": [
        "dom",
        "selection",
        "querySelector"
      ],
      "description": "Use querySelectorAll to count how many elements match a given CSS selector within a container.",
      "instructions": "Write a function called `countBySelector` that takes a DOM element (the container) and a CSS selector string, and returns the number of elements inside the container that match the selector.\n\nExamples:\n  // Given: <div id=\"root\"><p class=\"item\">A</p><p class=\"item\">B</p><span class=\"item\">C</span><p>D</p></div>\n  countBySelector(root, '.item')   → 3\n  countBySelector(root, 'p')       → 3\n  countBySelector(root, 'span')    → 1\n  countBySelector(root, '.none')   → 0",
      "starterCode": "function countBySelector(container, selector) {\n\n}",
      "solution": "function countBySelector(container, selector) {\n  return container.querySelectorAll(selector).length;\n}",
      "testRunner": "(code) => {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString('<div id=\"root\"><p class=\"item\">A</p><p class=\"item\">B</p><span class=\"item\">C</span><p>D</p></div>', 'text/html');\n  const root = doc.getElementById('root');\n  const fn = new Function('container', 'selector', code + '; return countBySelector(container, selector);');\n  return [\n    { pass: fn(root, '.item') === 3, description: 'countBySelector(root, \".item\") returns 3', got: String(fn(root, '.item')) },\n    { pass: fn(root, 'p') === 3, description: 'countBySelector(root, \"p\") returns 3', got: String(fn(root, 'p')) },\n    { pass: fn(root, 'span') === 1, description: 'countBySelector(root, \"span\") returns 1', got: String(fn(root, 'span')) },\n    { pass: fn(root, '.none') === 0, description: 'countBySelector(root, \".none\") returns 0', got: String(fn(root, '.none')) },\n    { pass: fn(root, 'p.item') === 2, description: 'countBySelector(root, \"p.item\") returns 2', got: String(fn(root, 'p.item')) },\n  ];\n}",
      "hint": "Use container.querySelectorAll(selector) to find all matching elements, then return the .length of the resulting NodeList.",
      "resources": [
        {
          "label": "MDN: querySelectorAll",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll"
        }
      ],
      "hints": [
        "How do you select multiple elements matching a CSS selector, and what does the result look like — an array, or something else?",
        "Use container.querySelectorAll(selector) to find all matching elements, then return the .length of the resulting NodeList.",
        "Key method(s): `querySelectorAll`."
      ]
    },
    {
      "id": 337,
      "title": "Walk the DOM Tree",
      "type": "js",
      "tier": 3,
      "category": [
        "dom-manipulation",
        "selection"
      ],
      "tags": [
        "dom",
        "recursion",
        "traversal"
      ],
      "description": "Recursively traverse a DOM tree and collect all text content from text nodes.",
      "instructions": "Write a function called `collectText` that takes a DOM element and recursively walks the entire DOM tree, collecting text from text nodes (nodes where `node.nodeType === 3`).\n\nReturn an array of trimmed, non-empty text strings in the order they appear.\n\nExamples:\n  // Given: <div><p>Hello <strong>World</strong></p><p>Goodbye</p></div>\n  collectText(div) → [\"Hello\", \"World\", \"Goodbye\"]\n\n  // Given: <ul><li>A</li><li>B</li></ul>\n  collectText(ul) → [\"A\", \"B\"]",
      "starterCode": "function collectText(element) {\n  // Recursively walk the DOM tree\n  // Collect text from text nodes (node.nodeType === 3)\n  // Return array of trimmed, non-empty text\n}",
      "solution": "function collectText(element) {\n  const result = [];\n  for (const node of element.childNodes) {\n    if (node.nodeType === 3) {\n      const text = node.textContent.trim();\n      if (text) result.push(text);\n    } else if (node.nodeType === 1) {\n      result.push(...collectText(node));\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => {\n  const parser = new DOMParser();\n  const doc1 = parser.parseFromString('<div><p>Hello <strong>World</strong></p><p>Goodbye</p></div>', 'text/html');\n  const div1 = doc1.body.firstChild;\n  const doc2 = parser.parseFromString('<ul><li>A</li><li>B</li><li>C</li></ul>', 'text/html');\n  const ul = doc2.body.firstChild;\n  const doc3 = parser.parseFromString('<div>  <span>  </span>  </div>', 'text/html');\n  const emptyDiv = doc3.body.firstChild;\n  const doc4 = parser.parseFromString('<div><div><div>Deep</div></div></div>', 'text/html');\n  const deep = doc4.body.firstChild;\n\n  const fn = new Function('element', code + '; return collectText(element);');\n  const r1 = fn(div1);\n  const r2 = fn(ul);\n  const r3 = fn(emptyDiv);\n  const r4 = fn(deep);\n  return [\n    { pass: JSON.stringify(r1) === '[\"Hello\",\"World\",\"Goodbye\"]', description: 'collects text from nested elements', got: JSON.stringify(r1) },\n    { pass: JSON.stringify(r2) === '[\"A\",\"B\",\"C\"]', description: 'collects text from list items', got: JSON.stringify(r2) },\n    { pass: JSON.stringify(r3) === '[]', description: 'whitespace-only nodes are excluded', got: JSON.stringify(r3) },\n    { pass: JSON.stringify(r4) === '[\"Deep\"]', description: 'deeply nested text is found', got: JSON.stringify(r4) },\n  ];\n}",
      "hint": "Loop through element.childNodes. For each node, check nodeType: 3 means text node (grab its textContent), 1 means element node (recurse into it). Trim text and skip empty strings.",
      "resources": [
        {
          "label": "MDN: Node.childNodes",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes"
        },
        {
          "label": "MDN: Node.nodeType",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType"
        }
      ],
      "hints": [
        "What DOM API method lets you find or manipulate the element you need?",
        "Loop through element.childNodes. For each node, check nodeType: 3 means text node (grab its textContent), 1 means element node (recurse into it). Trim text and skip empty strings.",
        "Key method(s): `trim`, `collectText`. The function calls itself recursively. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 338,
      "title": "Event Delegation",
      "type": "js",
      "tier": 3,
      "category": [
        "dom-manipulation",
        "events"
      ],
      "tags": [
        "dom",
        "events",
        "delegation"
      ],
      "description": "Implement event delegation by attaching a single click listener to a parent element that responds to clicks on child <li> elements.",
      "instructions": "Write a function called `setupDelegation` that takes two DOM elements:\n- `container`: a parent element (e.g., a <ul>)\n- `outputEl`: an element where results will be displayed\n\nAdd a single click event listener to the container. When an <li> element (or anything inside an <li>) is clicked, set `outputEl.textContent` to the value of the clicked <li>'s `data-id` attribute.\n\nExamples:\n  // Given: <ul id=\"list\"><li data-id=\"1\">Item 1</li><li data-id=\"2\">Item 2</li></ul>\n  //        <div id=\"output\"></div>\n  setupDelegation(list, output);\n  // After clicking \"Item 2\": output.textContent === \"2\"",
      "starterCode": "function setupDelegation(container, outputEl) {\n  // Add a single click listener to the container\n  // When an <li> is clicked, set outputEl.textContent to its data-id\n}",
      "solution": "function setupDelegation(container, outputEl) {\n  container.addEventListener('click', (e) => {\n    const li = e.target.closest('li');\n    if (li && container.contains(li)) {\n      outputEl.textContent = li.getAttribute('data-id');\n    }\n  });\n}",
      "testRunner": "(code) => {\n  return new Promise((resolve) => {\n    const iframe = document.createElement('iframe');\n    iframe.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:400px;height:300px;';\n    document.body.appendChild(iframe);\n    const idoc = iframe.contentDocument;\n    idoc.open();\n    idoc.write('<ul id=\"list\"><li data-id=\"1\">Item 1</li><li data-id=\"2\">Item 2</li><li data-id=\"3\"><span>Nested</span></li></ul><div id=\"output\"></div>');\n    idoc.close();\n\n    const iwin = iframe.contentWindow;\n    try {\n      iwin.eval(code);\n      const list = idoc.getElementById('list');\n      const output = idoc.getElementById('output');\n      iwin.eval('setupDelegation(document.getElementById(\"list\"), document.getElementById(\"output\"))');\n\n      const results = [];\n\n      // Click li[data-id=\"1\"]\n      const li1 = list.querySelector('[data-id=\"1\"]');\n      li1.dispatchEvent(new iwin.MouseEvent('click', { bubbles: true }));\n      results.push({ pass: output.textContent === '1', description: 'clicking first li sets output to \"1\"', got: output.textContent });\n\n      // Click li[data-id=\"2\"]\n      const li2 = list.querySelector('[data-id=\"2\"]');\n      li2.dispatchEvent(new iwin.MouseEvent('click', { bubbles: true }));\n      results.push({ pass: output.textContent === '2', description: 'clicking second li sets output to \"2\"', got: output.textContent });\n\n      // Click nested span inside li[data-id=\"3\"]\n      const span = list.querySelector('[data-id=\"3\"] span');\n      span.dispatchEvent(new iwin.MouseEvent('click', { bubbles: true }));\n      results.push({ pass: output.textContent === '3', description: 'clicking nested span delegates to parent li', got: output.textContent });\n\n      // Click container itself (not an li)\n      output.textContent = 'unchanged';\n      list.dispatchEvent(new iwin.MouseEvent('click', { bubbles: false }));\n      results.push({ pass: output.textContent === 'unchanged', description: 'clicking container directly does not change output', got: output.textContent });\n\n      document.body.removeChild(iframe);\n      resolve(results);\n    } catch (err) {\n      document.body.removeChild(iframe);\n      resolve([{ pass: false, description: 'setup failed: ' + err.message, got: err.message }]);\n    }\n  });\n}",
      "hint": "Add one click listener to the container. Inside it, use e.target.closest(\"li\") to find the nearest <li> ancestor of whatever was clicked. Then read its data-id attribute with getAttribute(\"data-id\").",
      "resources": [
        {
          "label": "MDN: Event Delegation",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_delegation"
        },
        {
          "label": "MDN: Element.closest()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/closest"
        }
      ],
      "hints": [
        "Instead of adding a listener to every child element, how can you use a single listener on the parent to handle events from its children?",
        "Add one click listener to the container. Inside it, use e.target.closest(\"li\") to find the nearest <li> ancestor of whatever was clicked. Then read its data-id attribute with getAttribute(\"data-id\").",
        "Key method(s): `addEventListener`, `closest`, `contains`."
      ]
    },
    {
      "id": 339,
      "title": "Debounced Input",
      "type": "js",
      "tier": 3,
      "category": [
        "dom-manipulation",
        "events"
      ],
      "tags": [
        "dom",
        "events",
        "closure",
        "timing"
      ],
      "description": "Attach a debounced input listener that only fires a callback after the user stops typing for 300ms.",
      "instructions": "Write a function called `debounceInput` that takes:\n- `inputEl`: an <input> DOM element\n- `callback`: a function to call with the input's value\n\nListen for \"input\" events on inputEl. Only call `callback(inputEl.value)` after 300ms of no new input events (debounce).\n\nIf the user types \"a\", then 100ms later types \"b\", only callback(\"ab\") should fire (300ms after the \"b\").\n\nExample:\n  debounceInput(myInput, (val) => console.log(val));\n  // User types \"hello\" quickly—callback fires once with \"hello\" after 300ms of silence",
      "starterCode": "function debounceInput(inputEl, callback) {\n  // Listen for 'input' events on inputEl\n  // Only call callback(inputEl.value) after 300ms of no input\n}",
      "solution": "function debounceInput(inputEl, callback) {\n  let timer;\n  inputEl.addEventListener('input', () => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      callback(inputEl.value);\n    }, 300);\n  });\n}",
      "testRunner": "(code) => {\n  return new Promise((resolve) => {\n    const iframe = document.createElement('iframe');\n    iframe.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:400px;height:300px;';\n    document.body.appendChild(iframe);\n    const idoc = iframe.contentDocument;\n    idoc.open();\n    idoc.write('<input id=\"inp\" type=\"text\" />');\n    idoc.close();\n\n    const iwin = iframe.contentWindow;\n    try {\n      iwin.eval(code);\n      const inp = idoc.getElementById('inp');\n      const calls = [];\n      iwin.eval('debounceInput(document.getElementById(\"inp\"), function(val) { window.__calls.push(val); })');\n      iwin.__calls = calls;\n\n      // Simulate rapid typing: \"a\" then \"ab\" then \"abc\" with 100ms gaps\n      inp.value = 'a';\n      inp.dispatchEvent(new iwin.Event('input', { bubbles: true }));\n\n      setTimeout(() => {\n        inp.value = 'ab';\n        inp.dispatchEvent(new iwin.Event('input', { bubbles: true }));\n      }, 100);\n\n      setTimeout(() => {\n        inp.value = 'abc';\n        inp.dispatchEvent(new iwin.Event('input', { bubbles: true }));\n      }, 200);\n\n      // At 350ms after last input (200 + 300 = 500ms + buffer), check\n      setTimeout(() => {\n        const results = [];\n        results.push({ pass: calls.length === 0, description: 'callback not called during rapid typing (at 350ms)', got: 'calls: ' + calls.length });\n\n        // Wait for debounce to fire (at ~550ms total)\n        setTimeout(() => {\n          results.push({ pass: calls.length === 1, description: 'callback called exactly once after debounce', got: 'calls: ' + calls.length });\n          results.push({ pass: calls[0] === 'abc', description: 'callback received final value \"abc\"', got: calls[0] });\n\n          // Fire another single input and check it fires\n          inp.value = 'xyz';\n          inp.dispatchEvent(new iwin.Event('input', { bubbles: true }));\n\n          setTimeout(() => {\n            results.push({ pass: calls.length === 2 && calls[1] === 'xyz', description: 'second debounced call fires with \"xyz\"', got: 'calls: ' + calls.length + ', last: ' + calls[calls.length - 1] });\n            document.body.removeChild(iframe);\n            resolve(results);\n          }, 400);\n        }, 250);\n      }, 350);\n    } catch (err) {\n      document.body.removeChild(iframe);\n      resolve([{ pass: false, description: 'setup failed: ' + err.message, got: err.message }]);\n    }\n  });\n}",
      "hint": "Store a timer variable in the closure. On each input event, clearTimeout(timer) to cancel the previous timer, then set a new setTimeout for 300ms. The callback only fires if no new input arrives within that window.",
      "resources": [
        {
          "label": "MDN: setTimeout",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "label": "MDN: clearTimeout",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout"
        }
      ],
      "hints": [
        "Start by thinking about DOM manipulation and event handling.",
        "Store a timer variable in the closure. On each input event, clearTimeout(timer) to cancel the previous timer, then set a new setTimeout for 300ms. The callback only fires if no new input arrives within that window.",
        "Key method(s): `addEventListener`."
      ]
    },
    {
      "id": 340,
      "title": "Build a List from Data",
      "type": "js",
      "tier": 2,
      "category": [
        "dom-manipulation",
        "manipulation"
      ],
      "tags": [
        "dom",
        "manipulation",
        "createElement"
      ],
      "description": "Programmatically create DOM elements from an array of data and append them to a container.",
      "instructions": "Write a function called `buildList` that takes three arguments:\n- `doc`: the document object (used to create elements)\n- `container`: a DOM element to append to\n- `items`: an array of strings\n\nCreate a `<ul>` element, and for each item in the array, create an `<li>` element with the item as its textContent. Append the `<ul>` to the container.\n\nExamples:\n  buildList(document, container, [\"Apple\", \"Banana\", \"Cherry\"]);\n  // container now contains: <ul><li>Apple</li><li>Banana</li><li>Cherry</li></ul>",
      "starterCode": "function buildList(doc, container, items) {\n\n}",
      "solution": "function buildList(doc, container, items) {\n  const ul = doc.createElement('ul');\n  for (const item of items) {\n    const li = doc.createElement('li');\n    li.textContent = item;\n    ul.appendChild(li);\n  }\n  container.appendChild(ul);\n}",
      "testRunner": "(code) => {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString('<div id=\"root\"></div>', 'text/html');\n  const root = doc.getElementById('root');\n  const fn = new Function('doc', 'container', 'items', code + '; buildList(doc, container, items);');\n  fn(doc, root, ['Apple', 'Banana', 'Cherry']);\n  const ul = root.querySelector('ul');\n  const lis = ul ? ul.querySelectorAll('li') : [];\n  return [\n    { pass: ul !== null, description: 'a <ul> element is created', got: ul ? 'found' : 'not found' },\n    { pass: lis.length === 3, description: '3 <li> elements created', got: String(lis.length) },\n    { pass: lis.length >= 1 && lis[0].textContent === 'Apple', description: 'first li contains \"Apple\"', got: lis.length >= 1 ? lis[0].textContent : 'none' },\n    { pass: lis.length >= 2 && lis[1].textContent === 'Banana', description: 'second li contains \"Banana\"', got: lis.length >= 2 ? lis[1].textContent : 'none' },\n    { pass: lis.length >= 3 && lis[2].textContent === 'Cherry', description: 'third li contains \"Cherry\"', got: lis.length >= 3 ? lis[2].textContent : 'none' },\n  ];\n}",
      "hint": "Use doc.createElement(\"ul\") and doc.createElement(\"li\") to create elements. Set li.textContent for each item, then use ul.appendChild(li) and container.appendChild(ul).",
      "resources": [
        {
          "label": "MDN: Document.createElement()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement"
        },
        {
          "label": "MDN: Node.appendChild()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild"
        }
      ],
      "hints": [
        "How do you create new DOM elements from data and attach them to the page?",
        "Use doc.createElement(\"ul\") and doc.createElement(\"li\") to create elements. Set li.textContent for each item, then use ul.appendChild(li) and container.appendChild(ul).",
        "Key method(s): `createElement`, `appendChild`."
      ]
    },
    {
      "id": 341,
      "title": "Toggle Classes Conditionally",
      "type": "js",
      "tier": 2,
      "category": [
        "dom-manipulation",
        "manipulation"
      ],
      "tags": [
        "dom",
        "manipulation",
        "classList"
      ],
      "description": "Add or remove a CSS class on elements based on whether their numeric content exceeds a threshold.",
      "instructions": "Write a function called `toggleHighlight` that takes:\n- `elements`: an array-like list of DOM elements (each contains a number as text)\n- `threshold`: a number\n\nFor each element, parse its textContent as a number. If the number is greater than or equal to the threshold, add the CSS class \"highlight\". Otherwise, remove it.\n\nExamples:\n  // Given: <span>10</span> <span>20</span> <span>30</span>\n  toggleHighlight(spans, 20);\n  // First span: no \"highlight\" class\n  // Second span: has \"highlight\" class\n  // Third span: has \"highlight\" class",
      "starterCode": "function toggleHighlight(elements, threshold) {\n\n}",
      "solution": "function toggleHighlight(elements, threshold) {\n  for (const el of elements) {\n    const num = Number(el.textContent);\n    if (num >= threshold) {\n      el.classList.add('highlight');\n    } else {\n      el.classList.remove('highlight');\n    }\n  }\n}",
      "testRunner": "(code) => {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString('<div><span>10</span><span>20</span><span>30</span><span>5</span></div>', 'text/html');\n  const spans = doc.querySelectorAll('span');\n  const fn = new Function('elements', 'threshold', code + '; toggleHighlight(elements, threshold);');\n  fn(spans, 20);\n  return [\n    { pass: !spans[0].classList.contains('highlight'), description: '10 < 20: no highlight', got: spans[0].classList.contains('highlight') ? 'has highlight' : 'no highlight' },\n    { pass: spans[1].classList.contains('highlight'), description: '20 >= 20: has highlight', got: spans[1].classList.contains('highlight') ? 'has highlight' : 'no highlight' },\n    { pass: spans[2].classList.contains('highlight'), description: '30 >= 20: has highlight', got: spans[2].classList.contains('highlight') ? 'has highlight' : 'no highlight' },\n    { pass: !spans[3].classList.contains('highlight'), description: '5 < 20: no highlight', got: spans[3].classList.contains('highlight') ? 'has highlight' : 'no highlight' },\n    { pass: (() => { fn(spans, 10); return spans[0].classList.contains('highlight') && !spans[3].classList.contains('highlight'); })(), description: 'changing threshold to 10 updates classes correctly', got: 'checked' },\n  ];\n}",
      "hint": "Loop through elements. Use Number(el.textContent) to parse the number. Then use el.classList.add(\"highlight\") or el.classList.remove(\"highlight\") based on the comparison.",
      "resources": [
        {
          "label": "MDN: Element.classList",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/classList"
        }
      ],
      "hints": [
        "How can you add or remove a CSS class from an element based on a condition?",
        "Loop through elements. Use Number(el.textContent) to parse the number. Then use el.classList.add(\"highlight\") or el.classList.remove(\"highlight\") based on the comparison.",
        "Key method(s): `add`, `remove`."
      ]
    },
    {
      "id": 342,
      "title": "Create a Tabbed Interface",
      "type": "js",
      "tier": 3,
      "category": [
        "dom-manipulation",
        "manipulation"
      ],
      "tags": [
        "dom",
        "manipulation",
        "events"
      ],
      "description": "Build a tabbed UI where clicking a tab button shows the corresponding panel and hides the others.",
      "instructions": "Write a function called `initTabs` that takes a container element.\n\nInside the container, find all elements with a `data-tab` attribute (tab buttons) and all elements with a `data-panel` attribute (panels).\n\nWhen a tab button is clicked:\n1. Hide all panels (set `style.display = \"none\"`)\n2. Show the panel whose `data-panel` value matches the clicked tab's `data-tab` value (set `style.display = \"block\"`)\n\nInitially, hide all panels except the first one.\n\nExample HTML:\n  <div id=\"tabs\">\n    <button data-tab=\"a\">Tab A</button>\n    <button data-tab=\"b\">Tab B</button>\n    <div data-panel=\"a\">Panel A content</div>\n    <div data-panel=\"b\">Panel B content</div>\n  </div>",
      "starterCode": "function initTabs(container) {\n  // Find [data-tab] buttons and [data-panel] panels\n  // Clicking a tab shows matching panel, hides others\n}",
      "solution": "function initTabs(container) {\n  const tabs = container.querySelectorAll('[data-tab]');\n  const panels = container.querySelectorAll('[data-panel]');\n\n  // Hide all panels except first\n  panels.forEach((p, i) => {\n    p.style.display = i === 0 ? 'block' : 'none';\n  });\n\n  tabs.forEach(tab => {\n    tab.addEventListener('click', () => {\n      const target = tab.getAttribute('data-tab');\n      panels.forEach(p => {\n        p.style.display = p.getAttribute('data-panel') === target ? 'block' : 'none';\n      });\n    });\n  });\n}",
      "testRunner": "(code) => {\n  return new Promise((resolve) => {\n    const iframe = document.createElement('iframe');\n    iframe.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:400px;height:300px;';\n    document.body.appendChild(iframe);\n    const idoc = iframe.contentDocument;\n    idoc.open();\n    idoc.write('<div id=\"tabs\"><button data-tab=\"a\">Tab A</button><button data-tab=\"b\">Tab B</button><button data-tab=\"c\">Tab C</button><div data-panel=\"a\">Panel A</div><div data-panel=\"b\">Panel B</div><div data-panel=\"c\">Panel C</div></div>');\n    idoc.close();\n\n    const iwin = iframe.contentWindow;\n    try {\n      iwin.eval(code);\n      iwin.eval('initTabs(document.getElementById(\"tabs\"))');\n\n      const panels = idoc.querySelectorAll('[data-panel]');\n      const tabs = idoc.querySelectorAll('[data-tab]');\n      const results = [];\n\n      // Initial state: first panel visible, others hidden\n      results.push({ pass: panels[0].style.display === 'block', description: 'initially panel A is visible', got: panels[0].style.display });\n      results.push({ pass: panels[1].style.display === 'none', description: 'initially panel B is hidden', got: panels[1].style.display });\n\n      // Click tab B\n      tabs[1].dispatchEvent(new iwin.MouseEvent('click', { bubbles: true }));\n      results.push({ pass: panels[0].style.display === 'none', description: 'after clicking tab B: panel A hidden', got: panels[0].style.display });\n      results.push({ pass: panels[1].style.display === 'block', description: 'after clicking tab B: panel B visible', got: panels[1].style.display });\n\n      // Click tab C\n      tabs[2].dispatchEvent(new iwin.MouseEvent('click', { bubbles: true }));\n      results.push({ pass: panels[2].style.display === 'block' && panels[1].style.display === 'none', description: 'clicking tab C shows panel C and hides B', got: 'C:' + panels[2].style.display + ' B:' + panels[1].style.display });\n\n      document.body.removeChild(iframe);\n      resolve(results);\n    } catch (err) {\n      document.body.removeChild(iframe);\n      resolve([{ pass: false, description: 'setup failed: ' + err.message, got: err.message }]);\n    }\n  });\n}",
      "hint": "Use querySelectorAll(\"[data-tab]\") and querySelectorAll(\"[data-panel]\") to find tabs and panels. Set all panels to display:none initially (except the first). Add a click listener to each tab that shows the matching panel and hides the rest.",
      "resources": [
        {
          "label": "MDN: HTMLElement.dataset",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset"
        },
        {
          "label": "MDN: getAttribute()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute"
        }
      ],
      "hints": [
        "How does event propagation (bubbling) work, and how can you use it to handle events efficiently?",
        "Use querySelectorAll(\"[data-tab]\") and querySelectorAll(\"[data-panel]\") to find tabs and panels. Set all panels to display:none initially (except the first). Add a click listener to each tab that shows the matching panel and hides the rest.",
        "Key method(s): `querySelectorAll`, `forEach`, `addEventListener`."
      ]
    },
    {
      "id": 343,
      "title": "Drag-and-Drop Sort",
      "type": "js",
      "tier": 4,
      "category": [
        "dom-manipulation",
        "manipulation"
      ],
      "tags": [
        "dom",
        "manipulation",
        "events",
        "advanced"
      ],
      "description": "Make a list sortable via drag-and-drop by implementing dragstart, dragover, and drop event handlers.",
      "instructions": "Write a function called `makeSortable` that takes a <ul> (or <ol>) element and makes its <li> children sortable via drag-and-drop.\n\nFor each <li> child:\n1. Set its `draggable` attribute to `true`\n2. On `dragstart`: store a reference to the dragged element\n3. On `dragover`: call `e.preventDefault()` to allow dropping\n4. On `drop`: insert the dragged element before the drop target\n\nAfter your function runs, the user (or automated events) should be able to reorder list items by dragging.\n\nExample:\n  // Given: <ul><li>A</li><li>B</li><li>C</li></ul>\n  makeSortable(ul);\n  // Dragging \"C\" onto \"A\" results in: C, A, B",
      "starterCode": "function makeSortable(list) {\n  // your code here\n  // Make each <li> draggable\n  // Handle dragstart, dragover, drop to reorder\n}",
      "solution": "function makeSortable(list) {\n  let dragged = null;\n  const items = list.querySelectorAll('li');\n  items.forEach(item => {\n    item.draggable = true;\n    item.addEventListener('dragstart', (e) => {\n      dragged = item;\n    });\n    item.addEventListener('dragover', (e) => {\n      e.preventDefault();\n    });\n    item.addEventListener('drop', (e) => {\n      e.preventDefault();\n      if (dragged && dragged !== item) {\n        list.insertBefore(dragged, item);\n      }\n    });\n  });\n}",
      "testRunner": "(code) => {\n  return new Promise((resolve) => {\n    const iframe = document.createElement('iframe');\n    iframe.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:400px;height:300px;';\n    document.body.appendChild(iframe);\n    const idoc = iframe.contentDocument;\n    idoc.open();\n    idoc.write('<ul id=\"sortable\"><li>A</li><li>B</li><li>C</li></ul>');\n    idoc.close();\n\n    const iwin = iframe.contentWindow;\n    try {\n      iwin.eval(code);\n      const ul = idoc.getElementById('sortable');\n      iwin.eval('makeSortable(document.getElementById(\"sortable\"))');\n\n      const results = [];\n      const lis = ul.querySelectorAll('li');\n\n      // Check all items are draggable\n      results.push({ pass: Array.from(lis).every(li => li.draggable === true), description: 'all items are draggable', got: Array.from(lis).map(li => li.draggable).join(', ') });\n\n      // Simulate drag C (index 2) onto A (index 0)\n      const liC = lis[2]; // C\n      const liA = lis[0]; // A\n\n      const dragStartEvent = new iwin.Event('dragstart', { bubbles: true });\n      liC.dispatchEvent(dragStartEvent);\n\n      const dragOverEvent = new iwin.Event('dragover', { bubbles: true, cancelable: true });\n      liA.dispatchEvent(dragOverEvent);\n\n      const dropEvent = new iwin.Event('drop', { bubbles: true, cancelable: true });\n      liA.dispatchEvent(dropEvent);\n\n      const newOrder = Array.from(ul.querySelectorAll('li')).map(li => li.textContent);\n      results.push({ pass: newOrder[0] === 'C', description: 'after drag C onto A: first item is C', got: newOrder[0] });\n      results.push({ pass: newOrder[1] === 'A', description: 'after drag C onto A: second item is A', got: newOrder[1] });\n      results.push({ pass: newOrder[2] === 'B', description: 'after drag C onto A: third item is B', got: newOrder[2] });\n      results.push({ pass: newOrder.join(',') === 'C,A,B', description: 'full order is C,A,B', got: newOrder.join(',') });\n\n      document.body.removeChild(iframe);\n      resolve(results);\n    } catch (err) {\n      document.body.removeChild(iframe);\n      resolve([{ pass: false, description: 'setup failed: ' + err.message, got: err.message }]);\n    }\n  });\n}",
      "hint": "Store the dragged element in a closure variable. Set draggable=true on each <li>. On dragstart, save the element. On dragover, call e.preventDefault(). On drop, use list.insertBefore(dragged, dropTarget) to move the element.",
      "resources": [
        {
          "label": "MDN: Drag and Drop API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API"
        },
        {
          "label": "MDN: Node.insertBefore()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore"
        }
      ],
      "hints": [
        "`forEach` is a key tool for this exercise.",
        "Store the dragged element in a closure variable. Set draggable=true on each <li>. On dragstart, save the element. On dragover, call e.preventDefault(). On drop, use list.insertBefore(dragged, dropTarget) to move the element.",
        "Key method(s): `querySelectorAll`, `forEach`, `addEventListener`."
      ]
    },
    {
      "id": 344,
      "title": "Virtual DOM Diffing",
      "type": "js",
      "tier": 5,
      "category": [
        "dom-manipulation",
        "manipulation"
      ],
      "tags": [
        "dom",
        "algorithms",
        "recursion",
        "advanced"
      ],
      "description": "Implement a simplified virtual DOM diff algorithm that compares two virtual node trees and produces a list of patches.",
      "instructions": "Implement a function called `diff` that compares two virtual DOM trees and returns an array of patch objects describing the differences.\n\nA virtual node (vnode) is a plain object:\n```js\n{ tag: 'div', props: { id: 'app' }, children: [ ... ] }\n```\n\nChildren can be either vnode objects or strings (text nodes).\n\nPatch types:\n- `{ type: 'REPLACE', path, newNode }` — node was replaced entirely (different tag or text vs element)\n- `{ type: 'PROPS', path, props }` — props changed (props object contains only changed/added/removed keys; removed keys have value null)\n- `{ type: 'REMOVE', path }` — child was removed\n- `{ type: 'ADD', path, newNode }` — child was added\n\n`path` is an array of child indices showing how to reach the node from the root (empty array = root node).\n\nExamples:\n  diff({ tag: 'div', props: {}, children: [] },\n       { tag: 'span', props: {}, children: [] })\n  // [{ type: 'REPLACE', path: [], newNode: { tag: 'span', props: {}, children: [] } }]\n\n  diff({ tag: 'div', props: { id: 'a' }, children: [] },\n       { tag: 'div', props: { id: 'b' }, children: [] })\n  // [{ type: 'PROPS', path: [], props: { id: 'b' } }]",
      "starterCode": "// Virtual node structure:\n// { tag: string, props: object, children: (vnode | string)[] }\n//\n// Patch types:\n// { type: 'REPLACE', path: number[], newNode: vnode | string }\n// { type: 'PROPS',   path: number[], props: object }\n// { type: 'REMOVE',  path: number[] }\n// { type: 'ADD',     path: number[], newNode: vnode | string }\n\nfunction diff(oldTree, newTree) {\n  // Compare two virtual DOM trees\n  // Return array of patch objects\n}",
      "solution": "function diff(oldTree, newTree, path) {\n  if (path === undefined) path = [];\n  const patches = [];\n\n  // Both are strings (text nodes)\n  if (typeof oldTree === 'string' && typeof newTree === 'string') {\n    if (oldTree !== newTree) {\n      patches.push({ type: 'REPLACE', path: [...path], newNode: newTree });\n    }\n    return patches;\n  }\n\n  // One is string, other is element (or vice versa)\n  if (typeof oldTree !== typeof newTree) {\n    patches.push({ type: 'REPLACE', path: [...path], newNode: newTree });\n    return patches;\n  }\n\n  // Different tags\n  if (oldTree.tag !== newTree.tag) {\n    patches.push({ type: 'REPLACE', path: [...path], newNode: newTree });\n    return patches;\n  }\n\n  // Same tag — check props\n  const propChanges = {};\n  let hasChanges = false;\n  const allKeys = new Set([...Object.keys(oldTree.props || {}), ...Object.keys(newTree.props || {})]);\n  for (const key of allKeys) {\n    const oldVal = (oldTree.props || {})[key];\n    const newVal = (newTree.props || {})[key];\n    if (oldVal !== newVal) {\n      propChanges[key] = newVal !== undefined ? newVal : null;\n      hasChanges = true;\n    }\n  }\n  if (hasChanges) {\n    patches.push({ type: 'PROPS', path: [...path], props: propChanges });\n  }\n\n  // Diff children\n  const oldChildren = oldTree.children || [];\n  const newChildren = newTree.children || [];\n  const maxLen = Math.max(oldChildren.length, newChildren.length);\n  for (let i = 0; i < maxLen; i++) {\n    const childPath = [...path, i];\n    if (i >= oldChildren.length) {\n      patches.push({ type: 'ADD', path: childPath, newNode: newChildren[i] });\n    } else if (i >= newChildren.length) {\n      patches.push({ type: 'REMOVE', path: childPath });\n    } else {\n      patches.push(...diff(oldChildren[i], newChildren[i], childPath));\n    }\n  }\n\n  return patches;\n}",
      "testRunner": "(code) => {\n  const fn = new Function(code + '; return diff;')();\n\n  // Test 1: Different tags at root\n  const r1 = fn(\n    { tag: 'div', props: {}, children: [] },\n    { tag: 'span', props: {}, children: [] }\n  );\n  const t1 = r1.length === 1 && r1[0].type === 'REPLACE' && r1[0].newNode.tag === 'span';\n\n  // Test 2: Prop change\n  const r2 = fn(\n    { tag: 'div', props: { id: 'a' }, children: [] },\n    { tag: 'div', props: { id: 'b' }, children: [] }\n  );\n  const t2 = r2.length === 1 && r2[0].type === 'PROPS' && r2[0].props.id === 'b';\n\n  // Test 3: Identical trees\n  const r3 = fn(\n    { tag: 'div', props: { x: 1 }, children: ['hello'] },\n    { tag: 'div', props: { x: 1 }, children: ['hello'] }\n  );\n  const t3 = r3.length === 0;\n\n  // Test 4: Child added\n  const r4 = fn(\n    { tag: 'ul', props: {}, children: [{ tag: 'li', props: {}, children: ['A'] }] },\n    { tag: 'ul', props: {}, children: [{ tag: 'li', props: {}, children: ['A'] }, { tag: 'li', props: {}, children: ['B'] }] }\n  );\n  const t4 = r4.some(p => p.type === 'ADD' && p.path.length === 1 && p.path[0] === 1);\n\n  // Test 5: Child removed\n  const r5 = fn(\n    { tag: 'ul', props: {}, children: [{ tag: 'li', props: {}, children: ['A'] }, { tag: 'li', props: {}, children: ['B'] }] },\n    { tag: 'ul', props: {}, children: [{ tag: 'li', props: {}, children: ['A'] }] }\n  );\n  const t5 = r5.some(p => p.type === 'REMOVE' && p.path[0] === 1);\n\n  // Test 6: Text node change\n  const r6 = fn(\n    { tag: 'p', props: {}, children: ['old'] },\n    { tag: 'p', props: {}, children: ['new'] }\n  );\n  const t6 = r6.some(p => p.type === 'REPLACE' && p.newNode === 'new');\n\n  // Test 7: Prop removal\n  const r7 = fn(\n    { tag: 'div', props: { class: 'foo', id: 'bar' }, children: [] },\n    { tag: 'div', props: { class: 'foo' }, children: [] }\n  );\n  const t7 = r7.some(p => p.type === 'PROPS' && p.props.id === null);\n\n  return [\n    { pass: t1, description: 'different tags produce REPLACE patch', got: JSON.stringify(r1[0]) },\n    { pass: t2, description: 'changed prop produces PROPS patch', got: JSON.stringify(r2[0]) },\n    { pass: t3, description: 'identical trees produce no patches', got: 'patches: ' + r3.length },\n    { pass: t4, description: 'added child produces ADD patch', got: JSON.stringify(r4.find(p => p.type === 'ADD')) },\n    { pass: t5, description: 'removed child produces REMOVE patch', got: JSON.stringify(r5.find(p => p.type === 'REMOVE')) },\n    { pass: t6, description: 'changed text node produces REPLACE patch', got: JSON.stringify(r6.find(p => p.type === 'REPLACE')) },\n    { pass: t7, description: 'removed prop has null value in PROPS patch', got: JSON.stringify(r7.find(p => p.type === 'PROPS')) },\n  ];\n}",
      "hint": "Build a recursive function that takes oldTree, newTree, and a path array. Handle base cases: both strings (compare), different types (REPLACE), different tags (REPLACE). For same tags, diff the props and then recursively diff children by index.",
      "resources": [
        {
          "label": "Virtual DOM Explained",
          "url": "https://reactjs.org/docs/faq-internals.html"
        },
        {
          "label": "MDN: Recursion",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Recursion"
        }
      ],
      "hints": [
        "What DOM API method lets you find or manipulate the element you need?",
        "Build a recursive function that takes oldTree, newTree, and a path array. Handle base cases: both strings (compare), different types (REPLACE), different tags (REPLACE). For same tags, diff the props and then recursively diff children by index.",
        "Key method(s): `keys`, `max`, `diff`. The function calls itself recursively. Use a loop to iterate, then return the accumulated result. The function should return an array."
      ]
    },
    {
      "id": 345,
      "title": "Ordered List",
      "type": "html",
      "tier": 1,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "lists",
        "beginner"
      ],
      "description": "Create an ordered (numbered) list using the <ol> and <li> elements.",
      "instructions": "Create an ordered list with exactly three items:\n  1. \"First\"\n  2. \"Second\"\n  3. \"Third\"\n\nUse the `<ol>` element for the list and `<li>` elements for each item.",
      "starterCode": "<!-- Create an ordered list with three items: First, Second, Third -->\n<ol>\n  <!-- Add your list items here -->\n\n</ol>",
      "solution": "<ol>\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ol>",
      "testRunner": "",
      "testCases": [
        {
          "query": "ol",
          "assertion": "exists",
          "description": "An <ol> element exists"
        },
        {
          "query": "ol li",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "At least 3 <li> items inside the <ol>"
        },
        {
          "query": "ol",
          "assertion": "sourceContains",
          "value": "First",
          "description": "Page contains \"First\""
        },
        {
          "query": "ol",
          "assertion": "sourceContains",
          "value": "Second",
          "description": "Page contains \"Second\""
        },
        {
          "query": "ol",
          "assertion": "sourceContains",
          "value": "Third",
          "description": "Page contains \"Third\""
        }
      ],
      "hint": "An ordered list uses <ol> instead of <ul>. The browser automatically numbers each <li> item. The structure is the same as an unordered list, just with a different parent tag.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: <ul>, <ol>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul",
          "description": "HTML list elements"
        }
      ],
      "hints": [
        "Which semantic HTML element best describes this type of content, and why does choosing the right one matter?",
        "An ordered list uses <ol> instead of <ul>. The browser automatically numbers each <li> item. The structure is the same as an unordered list, just with a different parent tag.",
        "Key elements: `<ol>`, `<li>`."
      ]
    },
    {
      "id": 346,
      "title": "HTML Table",
      "type": "html",
      "tier": 1,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "tables",
        "beginner"
      ],
      "description": "Build a basic HTML table with a header row and data rows.",
      "instructions": "Create an HTML table with:\n  - A `<thead>` containing one row with two header cells (`<th>`): \"Name\" and \"Age\"\n  - A `<tbody>` containing two data rows, each with two cells (`<td>`)\n\nExample data rows:\n  - Alice, 25\n  - Bob, 30\n\nUse the `<table>`, `<thead>`, `<tbody>`, `<tr>`, `<th>`, and `<td>` elements.",
      "starterCode": "<!-- Build a table with a header row and two data rows -->\n<table>\n  <thead>\n    <tr>\n      <!-- Add header cells (th) for Name and Age -->\n\n    </tr>\n  </thead>\n  <tbody>\n    <!-- Add two data rows (tr) with cells (td) -->\n\n  </tbody>\n</table>",
      "solution": "<table>\n  <thead>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Alice</td>\n      <td>25</td>\n    </tr>\n    <tr>\n      <td>Bob</td>\n      <td>30</td>\n    </tr>\n  </tbody>\n</table>",
      "testRunner": "",
      "testCases": [
        {
          "query": "table",
          "assertion": "exists",
          "description": "A <table> element exists"
        },
        {
          "query": "thead",
          "assertion": "exists",
          "description": "A <thead> element exists"
        },
        {
          "query": "th",
          "assertion": "countAtLeast",
          "value": 2,
          "description": "At least 2 <th> header cells"
        },
        {
          "query": "tbody",
          "assertion": "exists",
          "description": "A <tbody> element exists"
        },
        {
          "query": "tr",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "At least 3 <tr> rows (1 header + 2 data)"
        }
      ],
      "hint": "Tables are built with nested elements: <table> wraps everything, <thead> holds the header, <tbody> holds the data. Each row uses <tr>. Header cells use <th>, data cells use <td>.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: HTML table",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table",
          "description": "HTML table element"
        }
      ],
      "hints": [
        "What is the difference between `<thead>`, `<tbody>`, `<th>`, and `<td>` — and why does table structure matter for accessibility?",
        "Tables are built with nested elements: <table> wraps everything, <thead> holds the header, <tbody> holds the data. Each row uses <tr>. Header cells use <th>, data cells use <td>.",
        "Key elements: `<table>`, `<thead>`, `<tr>`, `<th>`."
      ]
    },
    {
      "id": 347,
      "title": "Text Formatting",
      "type": "html",
      "tier": 1,
      "category": [
        "html",
        "semantics"
      ],
      "tags": [
        "html",
        "text",
        "semantics",
        "formatting",
        "beginner"
      ],
      "description": "Use semantic inline elements to format text within a paragraph.",
      "instructions": "Create a `<p>` element that contains text using all three of these formatting elements:\n  - `<strong>` to mark important text (bold)\n  - `<em>` to mark emphasized text (italic)\n  - `<code>` to mark inline code\n\nFor example: \"JavaScript has a <strong>powerful</strong> <em>event loop</em> that runs <code>setTimeout</code> callbacks.\"\n\nYou may use any text you like, as long as all three elements appear inside the paragraph.",
      "starterCode": "<!-- Create a paragraph with strong, em, and code elements -->\n<p>\n  <!-- Use <strong> for important text -->\n  <!-- Use <em> for emphasized text -->\n  <!-- Use <code> for inline code -->\n\n</p>",
      "solution": "<p>\n  JavaScript has a <strong>powerful</strong>\n  <em>event loop</em> that runs\n  <code>setTimeout</code> callbacks.\n</p>",
      "testRunner": "",
      "testCases": [
        {
          "query": "p",
          "assertion": "exists",
          "description": "A <p> element exists"
        },
        {
          "query": "strong",
          "assertion": "exists",
          "description": "A <strong> element exists"
        },
        {
          "query": "em",
          "assertion": "exists",
          "description": "An <em> element exists"
        },
        {
          "query": "code",
          "assertion": "exists",
          "description": "A <code> element exists"
        }
      ],
      "hint": "<strong> is for text with strong importance (browsers show it bold). <em> is for stress emphasis (browsers show it italic). <code> is for short code snippets (browsers show it in a monospace font). All three can be placed inside a <p> alongside regular text.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: HTML forms",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/Forms",
          "description": "Web forms guide"
        },
        {
          "label": "MDN: Semantics in HTML",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html",
          "description": "HTML semantic elements"
        }
      ],
      "hints": [
        "Which semantic HTML element best describes this type of content, and why does choosing the right one matter?",
        "<strong> is for text with strong importance (browsers show it bold). <em> is for stress emphasis (browsers show it italic). <code> is for short code snippets (browsers show it in a monospace font). All three can be placed inside a <p> alongside regular text.",
        "Key elements: `<strong>`, `<em>`, `<code>`."
      ]
    },
    {
      "id": 348,
      "title": "Display Property",
      "type": "css",
      "tier": 1,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "css",
        "display",
        "layout",
        "beginner"
      ],
      "description": "Control element visibility and flow using the CSS display property.",
      "instructions": "Write CSS to set the `display` property for three elements:\n  1. `.block` should have `display: block`\n  2. `.inline` should have `display: inline`\n  3. `.hidden` should have `display: none`\n\nThe `display` property controls whether an element is treated as a block-level box, an inline box, or is removed from the page flow entirely.",
      "starterCode": "/* Set the display property for each class */\n.block {\n  /* Make this a block element */\n\n}\n\n.inline {\n  /* Make this an inline element */\n\n}\n\n.hidden {\n  /* Hide this element completely */\n\n}",
      "solution": ".block {\n  display: block;\n}\n\n.inline {\n  display: inline;\n}\n\n.hidden {\n  display: none;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"block\" id=\"block-el\">Block</div><span class=\"inline\" id=\"inline-el\">Inline</span><div class=\"hidden\" id=\"hidden-el\">Hidden</div>",
      "testCases": [
        {
          "assertion": "equals",
          "property": "display",
          "value": "block",
          "description": ".block has display: block",
          "query": "#block-el"
        },
        {
          "assertion": "equals",
          "property": "display",
          "value": "inline",
          "description": ".inline has display: inline",
          "query": "#inline-el"
        },
        {
          "assertion": "equals",
          "property": "display",
          "value": "none",
          "description": ".hidden has display: none",
          "query": "#hidden-el"
        }
      ],
      "hint": "The display property accepts several values: \"block\" makes an element take the full width and start on a new line, \"inline\" makes it flow with text, and \"none\" removes it from the page completely (it takes up no space).",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: display",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/display",
          "description": "CSS display property"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "The display property accepts several values: \"block\" makes an element take the full width and start on a new line, \"inline\" makes it flow with text, and \"none\" removes it from the page completely (it takes up no space).",
        "Key properties: `display`."
      ]
    },
    {
      "id": 349,
      "title": "Width and Height",
      "type": "css",
      "tier": 1,
      "category": [
        "css",
        "box-model"
      ],
      "tags": [
        "css",
        "box-model",
        "sizing",
        "beginner"
      ],
      "description": "Set explicit dimensions on an element and use border-box sizing.",
      "instructions": "Write CSS that targets the `.box` class and sets:\n  1. `width` to `200px`\n  2. `height` to `150px`\n  3. `box-sizing` to `border-box`\n\nThe `box-sizing: border-box` property ensures that padding and borders are included within the specified width and height, instead of being added on top of them.",
      "starterCode": "/* Set the width, height, and box-sizing for .box */\n.box {\n  /* Set width to 200px */\n\n  /* Set height to 150px */\n\n  /* Set box-sizing to border-box */\n\n}",
      "solution": ".box {\n  width: 200px;\n  height: 150px;\n  box-sizing: border-box;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"box\" id=\"test-box\">Content</div>",
      "testCases": [
        {
          "assertion": "equals",
          "property": "width",
          "value": "200px",
          "description": "Width is 200px",
          "query": "#test-box"
        },
        {
          "assertion": "equals",
          "property": "height",
          "value": "150px",
          "description": "Height is 150px",
          "query": "#test-box"
        },
        {
          "assertion": "equals",
          "property": "box-sizing",
          "value": "border-box",
          "description": "Box-sizing is border-box",
          "query": "#test-box"
        }
      ],
      "hint": "The \"width\" and \"height\" properties set the dimensions of an element. By default, CSS uses \"content-box\" sizing where padding and borders are added outside the specified dimensions. Setting \"box-sizing: border-box\" changes this so that padding and borders are included within the width and height you set.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        },
        {
          "label": "MDN: Box model",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_box_model",
          "description": "CSS box model"
        }
      ],
      "hints": [
        "Start by thinking about CSS properties and values.",
        "The \"width\" and \"height\" properties set the dimensions of an element. By default, CSS uses \"content-box\" sizing where padding and borders are added outside the specified dimensions. Setting \"box-sizing: border-box\" changes this so that padding and borders are included within the width and height you set.",
        "Key properties: `width`, `height`, `box-sizing`."
      ]
    },
    {
      "id": 350,
      "title": "Select, Radio, and Checkbox",
      "type": "html",
      "tier": 2,
      "category": [
        "html",
        "forms"
      ],
      "tags": [
        "html",
        "forms",
        "inputs",
        "select",
        "radio",
        "checkbox"
      ],
      "description": "Build a form that uses a dropdown select, radio buttons, and a checkbox.",
      "instructions": "Create a `<form>` containing:\n  1. A `<select>` dropdown with at least 3 `<option>` elements\n  2. Two `<input type=\"radio\">` buttons that share the same `name` attribute\n  3. An `<input type=\"checkbox\">`\n\nThe select might list favourite colours, the radios could be a yes/no choice, and the checkbox could be an \"I agree\" toggle.",
      "starterCode": "<!-- Build a form with select, radio, and checkbox inputs -->\n<form>\n  <!-- Add a <select> with 3+ options -->\n\n  <!-- Add 2 radio buttons with the same name -->\n\n  <!-- Add a checkbox -->\n\n</form>",
      "solution": "<form>\n  <label for=\"color\">Favourite colour:</label>\n  <select id=\"color\" name=\"color\">\n    <option value=\"red\">Red</option>\n    <option value=\"green\">Green</option>\n    <option value=\"blue\">Blue</option>\n  </select>\n\n  <p>Do you like coding?</p>\n  <label><input type=\"radio\" name=\"coding\" value=\"yes\"> Yes</label>\n  <label><input type=\"radio\" name=\"coding\" value=\"no\"> No</label>\n\n  <label><input type=\"checkbox\" name=\"agree\"> I agree to the terms</label>\n</form>",
      "testRunner": "",
      "testCases": [
        {
          "query": "select",
          "assertion": "exists",
          "description": "A <select> element exists"
        },
        {
          "query": "option",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "At least 3 <option> elements exist"
        },
        {
          "query": "input[type=\"radio\"]",
          "assertion": "countAtLeast",
          "value": 2,
          "description": "At least 2 radio buttons exist"
        },
        {
          "query": "input[type=\"checkbox\"]",
          "assertion": "exists",
          "description": "A checkbox input exists"
        }
      ],
      "hint": "<select> creates a dropdown; each <option> is a choice. Radio buttons with the same \"name\" attribute form a group where only one can be selected. A checkbox is an independent on/off toggle.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: HTML forms",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/Forms",
          "description": "Web forms guide"
        },
        {
          "label": "MDN: <ul>, <ol>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul",
          "description": "HTML list elements"
        }
      ],
      "hints": [
        "What elements does a form need to be both functional and accessible — and how do labels connect to their inputs?",
        "<select> creates a dropdown; each <option> is a choice. Radio buttons with the same \"name\" attribute form a group where only one can be selected. A checkbox is an independent on/off toggle.",
        "Key elements: `<form>`, `<label>`, `<select>`, `<option>`. Important attributes: `for`, `name`, `value`."
      ]
    },
    {
      "id": 351,
      "title": "Image and Link",
      "type": "html",
      "tier": 2,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "images",
        "links",
        "accessibility"
      ],
      "description": "Create an image with alt text wrapped inside a link.",
      "instructions": "Create an `<a>` element with an `href` attribute (any URL is fine) that contains an `<img>` element. The image must have:\n  - A `src` attribute (e.g., \"photo.jpg\")\n  - An `alt` attribute describing the image\n\nThis makes the image clickable as a link.",
      "starterCode": "<!-- Create a link that wraps an image -->\n<!-- The <a> needs an href and the <img> needs src and alt -->\n",
      "solution": "<a href=\"https://example.com\">\n  <img src=\"photo.jpg\" alt=\"A descriptive photo\">\n</a>",
      "testRunner": "",
      "testCases": [
        {
          "query": "a",
          "assertion": "exists",
          "description": "An <a> element exists"
        },
        {
          "query": "a",
          "assertion": "sourceMatch",
          "value": "href=",
          "description": "The link has an href attribute"
        },
        {
          "query": "img",
          "assertion": "exists",
          "description": "An <img> element exists"
        },
        {
          "query": "img",
          "assertion": "sourceMatch",
          "value": "alt=",
          "description": "The image has an alt attribute"
        }
      ],
      "hint": "Wrap the <img> inside an <a> tag. The <a> needs href=\"...\" to set the destination. The <img> needs both src (image file path) and alt (accessible text description).",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: <img>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img",
          "description": "HTML image element"
        },
        {
          "label": "MDN: <a>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a",
          "description": "HTML anchor element"
        }
      ],
      "hints": [
        "What attributes does an image need so that users who cannot see it still understand its purpose?",
        "Wrap the <img> inside an <a> tag. The <a> needs href=\"...\" to set the destination. The <img> needs both src (image file path) and alt (accessible text description).",
        "Key elements: `<a>`, `<img>`. Important attributes: `href`, `src`, `alt`."
      ]
    },
    {
      "id": 352,
      "title": "Blockquote and Citation",
      "type": "html",
      "tier": 2,
      "category": [
        "html",
        "semantics"
      ],
      "tags": [
        "html",
        "semantics",
        "text",
        "blockquote"
      ],
      "description": "Use blockquote, cite, mark, and small elements for rich text semantics.",
      "instructions": "Create two sections:\n  1. A `<blockquote>` element containing a quote, with a `<cite>` element for the source\n  2. A `<p>` paragraph that uses `<mark>` to highlight a word and `<small>` for fine print\n\nExample structure:\n  <blockquote>To be or not to be.<cite>Shakespeare</cite></blockquote>\n  <p>This is <mark>important</mark> text. <small>Terms apply.</small></p>",
      "starterCode": "<!-- Create a blockquote with a citation -->\n\n<!-- Create a paragraph with mark and small elements -->\n",
      "solution": "<blockquote>\n  To be or not to be, that is the question.\n  <cite>William Shakespeare</cite>\n</blockquote>\n<p>This is <mark>important</mark> information. <small>Terms and conditions apply.</small></p>",
      "testRunner": "",
      "testCases": [
        {
          "query": "blockquote",
          "assertion": "exists",
          "description": "A <blockquote> element exists"
        },
        {
          "query": "cite",
          "assertion": "exists",
          "description": "A <cite> element exists"
        },
        {
          "query": "mark",
          "assertion": "exists",
          "description": "A <mark> element exists"
        },
        {
          "query": "small",
          "assertion": "exists",
          "description": "A <small> element exists"
        }
      ],
      "hint": "<blockquote> wraps a quoted block of text. <cite> identifies the source of the quote. <mark> highlights text (like a highlighter pen). <small> is for fine print or side comments.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: Semantics in HTML",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html",
          "description": "HTML semantic elements"
        }
      ],
      "hints": [
        "What semantic elements exist for quotations, and how do you attribute the source?",
        "<blockquote> wraps a quoted block of text. <cite> identifies the source of the quote. <mark> highlights text (like a highlighter pen). <small> is for fine print or side comments.",
        "Key elements: `<blockquote>`, `<cite>`, `<mark>`, `<small>`."
      ]
    },
    {
      "id": 353,
      "title": "Position Relative and Absolute",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "positioning"
      ],
      "tags": [
        "css",
        "positioning",
        "relative",
        "absolute"
      ],
      "description": "Use position relative and absolute to place a child element within its parent.",
      "instructions": "Style the two elements:\n  1. `.parent` should have `position: relative`\n  2. `.child` should have `position: absolute`, `top: 10px`, and `left: 20px`\n\nThis anchors the child to the parent rather than the page.",
      "starterCode": "/* Position the parent and child */\n.parent {\n  /* Make this a positioning context */\n\n}\n\n.child {\n  /* Position absolutely within the parent */\n\n}",
      "solution": ".parent {\n  position: relative;\n}\n\n.child {\n  position: absolute;\n  top: 10px;\n  left: 20px;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"parent\" id=\"parent-el\"><div class=\"child\" id=\"child-el\">Positioned</div></div>",
      "testCases": [
        {
          "query": "#parent-el",
          "assertion": "equals",
          "property": "position",
          "value": "relative",
          "description": "Parent has position: relative"
        },
        {
          "query": "#child-el",
          "assertion": "equals",
          "property": "position",
          "value": "absolute",
          "description": "Child has position: absolute"
        },
        {
          "query": "#child-el",
          "assertion": "equals",
          "property": "top",
          "value": "10px",
          "description": "Child has top: 10px"
        },
        {
          "query": "#child-el",
          "assertion": "equals",
          "property": "left",
          "value": "20px",
          "description": "Child has left: 20px"
        }
      ],
      "hint": "Setting position: relative on the parent makes it the reference point for any absolutely-positioned children. The child with position: absolute is then placed using top/left offsets relative to that parent.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: position",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/position",
          "description": "CSS position property"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "The `position` property is central to this exercise.",
        "Setting position: relative on the parent makes it the reference point for any absolutely-positioned children. The child with position: absolute is then placed using top/left offsets relative to that parent.",
        "Key properties: `position`, `top`, `left`."
      ]
    },
    {
      "id": 354,
      "title": "Typography Basics",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "typography"
      ],
      "tags": [
        "css",
        "typography",
        "fonts",
        "text"
      ],
      "description": "Style heading and body text with font-family, text-transform, letter-spacing, line-height, and text-align.",
      "instructions": "Style the two elements:\n  1. `.heading` should have:\n     - `font-family: Georgia, serif`\n     - `text-transform: uppercase`\n     - `letter-spacing: 2px`\n  2. `.body-text` should have:\n     - `line-height: 1.6`\n     - `text-align: justify`",
      "starterCode": "/* Style the heading */\n.heading {\n  /* font-family, text-transform, letter-spacing */\n\n}\n\n/* Style the body text */\n.body-text {\n  /* line-height, text-align */\n\n}",
      "solution": ".heading {\n  font-family: Georgia, serif;\n  text-transform: uppercase;\n  letter-spacing: 2px;\n}\n\n.body-text {\n  line-height: 1.6;\n  text-align: justify;\n}",
      "testRunner": "",
      "providedHtml": "<h1 class=\"heading\" id=\"heading-el\">Title</h1><p class=\"body-text\" id=\"body-el\">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>",
      "testCases": [
        {
          "query": "#heading-el",
          "assertion": "contains",
          "property": "font-family",
          "value": "Georgia",
          "description": "Heading font-family contains Georgia"
        },
        {
          "query": "#heading-el",
          "assertion": "equals",
          "property": "text-transform",
          "value": "uppercase",
          "description": "Heading text-transform is uppercase"
        },
        {
          "query": "#heading-el",
          "assertion": "equals",
          "property": "letter-spacing",
          "value": "2px",
          "description": "Heading letter-spacing is 2px"
        },
        {
          "query": "#body-el",
          "assertion": "sourceMatch",
          "value": "line-height",
          "description": "CSS source sets a line-height value"
        },
        {
          "query": "#body-el",
          "assertion": "equals",
          "property": "text-align",
          "value": "justify",
          "description": "Body text text-align is justify"
        }
      ],
      "hint": "font-family sets the typeface (with fallbacks after commas). text-transform: uppercase makes all letters caps. letter-spacing adds space between characters. line-height controls vertical space between lines. text-align: justify stretches lines to fill the full width.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        },
        {
          "label": "MDN: Fundamental text and font styling",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals",
          "description": "CSS text and font styling"
        }
      ],
      "hints": [
        "The `font-family` property is central to this exercise.",
        "font-family sets the typeface (with fallbacks after commas). text-transform: uppercase makes all letters caps. letter-spacing adds space between characters. line-height controls vertical space between lines. text-align: justify stretches lines to fill the full width.",
        "Key properties: `font-family`, `text-transform`, `letter-spacing`, `line-height`."
      ]
    },
    {
      "id": 355,
      "title": "CSS Units",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "box-model"
      ],
      "tags": [
        "css",
        "units",
        "rem",
        "viewport",
        "sizing"
      ],
      "description": "Practice using rem, percentage, and viewport units.",
      "instructions": "Style three elements using different CSS units:\n  1. `.rem-box` should have `font-size: 2rem`\n  2. `.percent-box` should have `width: 50%`\n  3. `.vh-box` should have `height: 50vh`",
      "starterCode": "/* Use different CSS units */\n.rem-box {\n  /* font-size in rem */\n\n}\n\n.percent-box {\n  /* width in percent */\n\n}\n\n.vh-box {\n  /* height in viewport units */\n\n}",
      "solution": ".rem-box {\n  font-size: 2rem;\n}\n\n.percent-box {\n  width: 50%;\n}\n\n.vh-box {\n  height: 50vh;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"rem-box\" id=\"rem-el\">Rem</div><div class=\"percent-box\" id=\"pct-el\">Percent</div><div class=\"vh-box\" id=\"vh-el\">Viewport</div>",
      "testCases": [
        {
          "query": "#rem-el",
          "assertion": "sourceMatch",
          "value": "2rem",
          "description": "rem-box uses 2rem for font-size"
        },
        {
          "query": "#pct-el",
          "assertion": "sourceMatch",
          "value": "50%",
          "description": "percent-box uses 50% for width"
        },
        {
          "query": "#vh-el",
          "assertion": "sourceMatch",
          "value": "50vh",
          "description": "vh-box uses 50vh for height"
        }
      ],
      "hint": "rem is relative to the root element font size (usually 16px, so 2rem = 32px). Percentage is relative to the parent element. vh (viewport height) is a percentage of the browser window height.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        },
        {
          "label": "MDN: Fundamental text and font styling",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals",
          "description": "CSS text and font styling"
        }
      ],
      "hints": [
        "The `font-size` property is central to this exercise.",
        "rem is relative to the root element font size (usually 16px, so 2rem = 32px). Percentage is relative to the parent element. vh (viewport height) is a percentage of the browser window height.",
        "Key properties: `font-size`, `width`, `height`."
      ]
    },
    {
      "id": 356,
      "title": "Pseudo-elements",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "selectors"
      ],
      "tags": [
        "css",
        "pseudo-elements",
        "before",
        "after",
        "selectors"
      ],
      "description": "Use ::before and ::after pseudo-elements to add decorative content around text.",
      "instructions": "Add opening and closing quote marks around `.quote` using pseudo-elements:\n  1. `.quote::before` should use the `content` property to insert an opening quote mark (e.g., `\"\\201C\"` which is a left double quotation mark)\n  2. `.quote::after` should use `content` to insert a closing quote mark (e.g., `\"\\201D\"`)\n\nThe content property is required for pseudo-elements to appear.",
      "starterCode": "/* Add quote marks using pseudo-elements */\n.quote::before {\n  /* Insert opening quote using content */\n\n}\n\n.quote::after {\n  /* Insert closing quote using content */\n\n}",
      "solution": ".quote::before {\n  content: \"\\201C\";\n}\n\n.quote::after {\n  content: \"\\201D\";\n}",
      "testRunner": "",
      "providedHtml": "<p class=\"quote\" id=\"quote-el\">To be or not to be</p>",
      "testCases": [
        {
          "query": ".quote",
          "assertion": "sourceMatch",
          "value": "::before",
          "description": "CSS uses ::before pseudo-element"
        },
        {
          "query": ".quote",
          "assertion": "sourceMatch",
          "value": "::after",
          "description": "CSS uses ::after pseudo-element"
        },
        {
          "query": ".quote",
          "assertion": "sourceMatch",
          "value": "content",
          "description": "CSS uses the content property"
        }
      ],
      "hint": "::before and ::after create virtual elements as the first/last child of the selected element. They MUST have the content property set (even if it is just content: \"\") or they will not appear. Use content: \"\\201C\" for a left curly quote and \"\\201D\" for a right curly quote.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Pseudo-elements",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements",
          "description": "CSS pseudo-elements"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "How can you add decorative content before or after an element without changing the HTML?",
        "::before and ::after create virtual elements as the first/last child of the selected element. They MUST have the content property set (even if it is just content: \"\") or they will not appear. Use content: \"\\201C\" for a left curly quote and \"\\201D\" for a right curly quote.",
        "Key properties: `quote`, `content`. Consider selectors like `.quote::before`, `.quote::after`."
      ]
    },
    {
      "id": 357,
      "title": "CSS Combinators",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "selectors"
      ],
      "tags": [
        "css",
        "selectors",
        "combinators",
        "specificity"
      ],
      "description": "Practice descendant, child, and adjacent sibling CSS combinators.",
      "instructions": "Write CSS rules using three different combinators:\n  1. **Descendant**: `.list li` — set `color` to `#1e40af` (rgb(30, 64, 175))\n  2. **Child**: `.list > li` — set `font-weight` to `bold`\n  3. **Adjacent sibling**: `.title + p` — set `margin-top` to `8px`\n\nThe descendant selector targets all nested `<li>` elements. The child selector targets only direct children. The adjacent sibling selector targets the `<p>` immediately after `.title`.",
      "starterCode": "/* Descendant combinator */\n.list li {\n  /* color */\n\n}\n\n/* Child combinator */\n.list > li {\n  /* font-weight */\n\n}\n\n/* Adjacent sibling combinator */\n.title + p {\n  /* margin-top */\n\n}",
      "solution": ".list li {\n  color: #1e40af;\n}\n\n.list > li {\n  font-weight: bold;\n}\n\n.title + p {\n  margin-top: 8px;\n}",
      "testRunner": "",
      "providedHtml": "<h2 class=\"title\" id=\"title-el\">Title</h2><p id=\"sibling-el\">First paragraph</p><ul class=\"list\" id=\"list-el\"><li id=\"direct-li\">Item<ul><li id=\"nested-li\">Nested</li></ul></li></ul>",
      "testCases": [
        {
          "query": ".list",
          "assertion": "sourceMatch",
          "value": ".list li",
          "description": "Uses descendant combinator .list li"
        },
        {
          "query": ".list",
          "assertion": "sourceMatch",
          "value": ".list > li",
          "description": "Uses child combinator .list > li"
        },
        {
          "query": ".title",
          "assertion": "sourceMatch",
          "value": ".title",
          "description": "Uses adjacent sibling combinator with .title"
        }
      ],
      "hint": "A space between selectors is the descendant combinator (matches all nested elements). The > is the child combinator (direct children only). The + is the adjacent sibling combinator (the very next sibling element).",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Specificity",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity",
          "description": "CSS specificity"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "What is the difference between a descendant selector and a direct child selector — when would you pick one over the other?",
        "A space between selectors is the descendant combinator (matches all nested elements). The > is the child combinator (direct children only). The + is the adjacent sibling combinator (the very next sibling element).",
        "Key properties: `font-weight`, `margin-top`. Consider selectors like `.list > li`, `.title + p`."
      ]
    },
    {
      "id": 358,
      "title": "Transitions",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "transitions"
      ],
      "tags": [
        "css",
        "transitions",
        "hover",
        "animation"
      ],
      "description": "Add a smooth colour transition to a button on hover.",
      "instructions": "Style the `.btn` element:\n  1. Default state: `background-color: #3b82f6` and a `transition` on `background-color` lasting `0.3s`\n  2. Hover state (`.btn:hover`): `background-color: #1d4ed8`\n\nThe transition property makes the colour change animate smoothly instead of snapping instantly.",
      "starterCode": "/* Style the button with a transition */\n.btn {\n  /* background-color and transition */\n\n}\n\n.btn:hover {\n  /* background-color on hover */\n\n}",
      "solution": ".btn {\n  background-color: #3b82f6;\n  transition: background-color 0.3s;\n}\n\n.btn:hover {\n  background-color: #1d4ed8;\n}",
      "testRunner": "",
      "providedHtml": "<button class=\"btn\" id=\"btn-el\">Click Me</button>",
      "testCases": [
        {
          "query": "#btn-el",
          "assertion": "equals",
          "property": "background-color",
          "value": "rgb(59, 130, 246)",
          "description": "Button background-color is #3b82f6"
        },
        {
          "query": ".btn",
          "assertion": "sourceMatch",
          "value": "transition",
          "description": "CSS uses the transition property"
        },
        {
          "query": ".btn",
          "assertion": "sourceMatch",
          "value": ":hover",
          "description": "CSS defines a :hover state"
        }
      ],
      "hint": "The transition shorthand is: transition: <property> <duration>. Put it on the default state (not the hover). The browser will then animate between the default and hover background-color values over 0.3 seconds.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS transitions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_transitions",
          "description": "CSS transitions"
        },
        {
          "label": "MDN: CSS animations",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animations",
          "description": "CSS animations"
        }
      ],
      "hints": [
        "The `background-color` property is central to this exercise.",
        "The transition shorthand is: transition: <property> <duration>. Put it on the default state (not the hover). The browser will then animate between the default and hover background-color values over 0.3 seconds.",
        "Key properties: `background-color`, `transition`, `btn`. Consider selectors like `.btn:hover`."
      ]
    },
    {
      "id": 359,
      "title": "Shadows and Borders",
      "type": "css",
      "tier": 2,
      "category": [
        "css",
        "box-model"
      ],
      "tags": [
        "css",
        "shadows",
        "borders",
        "box-model"
      ],
      "description": "Style a card with box-shadow, border-radius, border, and a text-shadow on its content.",
      "instructions": "Style two elements:\n  1. `.card` should have:\n     - `box-shadow` (any visible shadow, e.g., `0 4px 6px rgba(0,0,0,0.3)`)\n     - `border-radius: 12px`\n     - `border: 2px solid #334155`\n  2. `.text` should have a `text-shadow` (any visible shadow, e.g., `1px 1px 2px rgba(0,0,0,0.5)`)",
      "starterCode": "/* Style the card */\n.card {\n  /* box-shadow, border-radius, border */\n\n}\n\n/* Style the text */\n.text {\n  /* text-shadow */\n\n}",
      "solution": ".card {\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);\n  border-radius: 12px;\n  border: 2px solid #334155;\n}\n\n.text {\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"card\" id=\"card-el\"><p class=\"text\" id=\"text-el\">Shadow Box</p></div>",
      "testCases": [
        {
          "query": "#card-el",
          "assertion": "equals",
          "property": "border-radius",
          "value": "12px",
          "description": "Card border-radius is 12px"
        },
        {
          "query": ".card",
          "assertion": "sourceMatch",
          "value": "box-shadow",
          "description": "CSS uses box-shadow on the card"
        },
        {
          "query": ".text",
          "assertion": "sourceMatch",
          "value": "text-shadow",
          "description": "CSS uses text-shadow on the text"
        }
      ],
      "hint": "box-shadow syntax: x-offset y-offset blur-radius color (e.g., 0 4px 6px rgba(0,0,0,0.3)). border-radius rounds the corners. text-shadow uses the same offset/blur/color pattern but applies to text instead of the box.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: box-shadow",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow",
          "description": "CSS box-shadow property"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "The `box-shadow` property is central to this exercise.",
        "box-shadow syntax: x-offset y-offset blur-radius color (e.g., 0 4px 6px rgba(0,0,0,0.3)). border-radius rounds the corners. text-shadow uses the same offset/blur/color pattern but applies to text instead of the box.",
        "Key properties: `box-shadow`, `border-radius`, `border`, `text-shadow`."
      ]
    },
    {
      "id": 360,
      "title": "Specificity Challenge",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "selectors"
      ],
      "tags": [
        "css",
        "specificity",
        "selectors",
        "cascading",
        "intermediate"
      ],
      "description": "Write CSS rules that demonstrate specificity: element selectors, class selectors, and ID-qualified class selectors competing for the same elements.",
      "instructions": "Given the provided HTML, write CSS so that:\n- All `p` elements inside `#main` have `color: gray` (use `rgb(128, 128, 128)`)\n- Elements with class `.highlight` have `color: blue` (use `rgb(0, 0, 255)`) -- this should override the element selector\n- `#main .special` has `color: green` (use `rgb(0, 128, 0)`) -- this should override `.highlight`\n\nYour rules must rely on CSS specificity to produce the correct cascade.",
      "starterCode": "/* Make #main p gray, #main .highlight blue, and #main .special green */\n/* Think about which selectors are more specific */\n",
      "solution": "#main p {\n  color: rgb(128, 128, 128);\n}\n\n#main .highlight {\n  color: rgb(0, 0, 255);\n}\n\n#main .special {\n  color: rgb(0, 128, 0);\n}",
      "testRunner": "",
      "providedHtml": "<div id=\"main\"><p class=\"highlight\">Text 1</p><p>Text 2</p><p class=\"highlight special\">Text 3</p></div>",
      "testCases": [
        {
          "query": "#main p.highlight:not(.special)",
          "assertion": "equals",
          "property": "color",
          "value": "rgb(0, 0, 255)",
          "description": ".highlight paragraph is blue (class beats element)"
        },
        {
          "query": "#main p:not(.highlight)",
          "assertion": "equals",
          "property": "color",
          "value": "rgb(128, 128, 128)",
          "description": "Plain paragraph is gray"
        },
        {
          "query": "#main .special",
          "assertion": "equals",
          "property": "color",
          "value": "rgb(0, 128, 0)",
          "description": "#main .special is green (ID+class beats class alone)"
        }
      ],
      "hint": "CSS specificity follows this order: inline styles > ID selectors > class selectors > element selectors. An ID selector (#main) combined with a class (.special) beats a class alone (.highlight). Write your rules so that the most specific selector wins for each element.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Specificity",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity",
          "description": "CSS specificity"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "What is the difference between a descendant selector and a direct child selector — when would you pick one over the other?",
        "CSS specificity follows this order: inline styles > ID selectors > class selectors > element selectors. An ID selector (#main) combined with a class (.special) beats a class alone (.highlight). Write your rules so that the most specific selector wins for each element.",
        "Focus on the specific CSS properties that control the visual effect described in the instructions."
      ]
    },
    {
      "id": 361,
      "title": "Flexbox Wrapping Layout",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "flexbox"
      ],
      "tags": [
        "css",
        "flexbox",
        "flex-wrap",
        "layout",
        "intermediate"
      ],
      "description": "Create a flex container that wraps its items into multiple rows, with each item having a flexible base width and a gap between them.",
      "instructions": "Style the `.grid` container so that:\n- It uses `display: flex`\n- Items wrap to the next line with `flex-wrap: wrap`\n- There is a `gap` of `16px` between items\n\nAlso style each `.item` so it has:\n- `flex-basis: 200px`\n- `flex-grow: 1`\n\nThis creates a responsive card-like layout where items fill available space and wrap when needed.",
      "starterCode": "/* Style .grid as a wrapping flex container */\n/* Style .item with flex-basis and flex-grow */\n",
      "solution": ".grid {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 16px;\n}\n\n.item {\n  flex-basis: 200px;\n  flex-grow: 1;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"grid\" id=\"grid-el\"><div class=\"item\">1</div><div class=\"item\">2</div><div class=\"item\">3</div><div class=\"item\">4</div><div class=\"item\">5</div><div class=\"item\">6</div></div>",
      "testCases": [
        {
          "query": "#grid-el",
          "assertion": "equals",
          "property": "display",
          "value": "flex",
          "description": ".grid uses display: flex"
        },
        {
          "query": "#grid-el",
          "assertion": "equals",
          "property": "flex-wrap",
          "value": "wrap",
          "description": ".grid uses flex-wrap: wrap"
        },
        {
          "query": "#grid-el",
          "assertion": "sourceMatch",
          "value": "flex-basis",
          "description": "CSS source contains flex-basis"
        },
        {
          "query": "#grid-el",
          "assertion": "equals",
          "property": "gap",
          "value": "16px",
          "description": ".grid gap is 16px"
        }
      ],
      "hint": "flex-wrap: wrap tells the flex container to push items to the next line when they run out of room. flex-basis sets the ideal width of each item, while flex-grow: 1 lets them stretch to fill leftover space.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Flexbox",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout",
          "description": "CSS Flexbox layout"
        },
        {
          "label": "MDN: CSS Grid",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout",
          "description": "CSS Grid layout"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "flex-wrap: wrap tells the flex container to push items to the next line when they run out of room. flex-basis sets the ideal width of each item, while flex-grow: 1 lets them stretch to fill leftover space.",
        "Key properties: `display`, `flex-wrap`, `gap`, `flex-basis`."
      ]
    },
    {
      "id": 362,
      "title": "CSS Grid Basics",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "css",
        "grid",
        "layout",
        "fr-units",
        "intermediate"
      ],
      "description": "Create a 3-column CSS Grid layout using the fr unit for flexible column sizing and a gap between cells.",
      "instructions": "Style the `.container` element so that:\n- It uses `display: grid`\n- It has 3 equal-width columns using `grid-template-columns` with `1fr` units\n- There is a `gap` of `20px` between grid cells\n\nThe six child `.col` elements should automatically flow into a 3x2 grid.",
      "starterCode": "/* Create a 3-column grid layout */\n/* Use fr units for equal columns */\n",
      "solution": ".container {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  gap: 20px;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"container\" id=\"container-el\"><div class=\"col\">A</div><div class=\"col\">B</div><div class=\"col\">C</div><div class=\"col\">D</div><div class=\"col\">E</div><div class=\"col\">F</div></div>",
      "testCases": [
        {
          "query": "#container-el",
          "assertion": "equals",
          "property": "display",
          "value": "grid",
          "description": ".container uses display: grid"
        },
        {
          "query": "#container-el",
          "assertion": "sourceMatch",
          "value": "grid-template-columns",
          "description": "CSS source contains grid-template-columns"
        },
        {
          "query": "#container-el",
          "assertion": "sourceMatch",
          "value": "1fr",
          "description": "CSS source uses fr units"
        },
        {
          "query": "#container-el",
          "assertion": "equals",
          "property": "gap",
          "value": "20px",
          "description": ".container gap is 20px"
        }
      ],
      "hint": "CSS Grid turns a container into a grid with display: grid. Use grid-template-columns to define how many columns and how wide each one is. The fr unit distributes available space proportionally -- 1fr 1fr 1fr creates three equal columns.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Flexbox",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout",
          "description": "CSS Flexbox layout"
        },
        {
          "label": "MDN: CSS Grid",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout",
          "description": "CSS Grid layout"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "CSS Grid turns a container into a grid with display: grid. Use grid-template-columns to define how many columns and how wide each one is. The fr unit distributes available space proportionally -- 1fr 1fr 1fr creates three equal columns.",
        "Key properties: `display`, `grid-template-columns`, `gap`."
      ]
    },
    {
      "id": 363,
      "title": "Nth-child Selectors",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "selectors"
      ],
      "tags": [
        "css",
        "selectors",
        "nth-child",
        "pseudo-class",
        "intermediate"
      ],
      "description": "Use :nth-child pseudo-class selectors to style alternating table rows with different backgrounds and make the first row bold.",
      "instructions": "Style the table rows so that:\n- `tr:nth-child(odd)` has `background-color: rgb(240, 240, 240)`\n- `tr:nth-child(even)` has `background-color: rgb(220, 220, 220)`\n- `tr:first-child` has `font-weight: bold` (or `700`)\n\nThis creates a classic \"zebra-striped\" table with a bold header row.",
      "starterCode": "/* Style alternating rows with :nth-child */\n/* Make the first row bold */\n",
      "solution": "tr:nth-child(odd) {\n  background-color: rgb(240, 240, 240);\n}\n\ntr:nth-child(even) {\n  background-color: rgb(220, 220, 220);\n}\n\ntr:first-child {\n  font-weight: 700;\n}",
      "testRunner": "",
      "providedHtml": "<table id=\"data-table\"><tr id=\"row-1\"><td>Row 1</td></tr><tr id=\"row-2\"><td>Row 2</td></tr><tr id=\"row-3\"><td>Row 3</td></tr><tr id=\"row-4\"><td>Row 4</td></tr></table>",
      "testCases": [
        {
          "query": "#data-table",
          "assertion": "sourceMatch",
          "value": "nth-child",
          "description": "CSS source uses :nth-child"
        },
        {
          "query": "#row-1",
          "assertion": "equals",
          "property": "font-weight",
          "value": "700",
          "description": "First row is bold (font-weight: 700)"
        },
        {
          "query": "#row-1",
          "assertion": "equals",
          "property": "background-color",
          "value": "rgb(240, 240, 240)",
          "description": "Row 1 (odd) background is rgb(240, 240, 240)"
        },
        {
          "query": "#row-2",
          "assertion": "equals",
          "property": "background-color",
          "value": "rgb(220, 220, 220)",
          "description": "Row 2 (even) background is rgb(220, 220, 220)"
        }
      ],
      "hint": "The :nth-child() pseudo-class matches elements based on their position among siblings. Use \"odd\" and \"even\" keywords for alternating styles. :first-child matches only the first element among its siblings.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Pseudo-classes",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes",
          "description": "CSS pseudo-classes"
        },
        {
          "label": "MDN: Fundamental text and font styling",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals",
          "description": "CSS text and font styling"
        }
      ],
      "hints": [
        "The `background-color` property is central to this exercise.",
        "The :nth-child() pseudo-class matches elements based on their position among siblings. Use \"odd\" and \"even\" keywords for alternating styles. :first-child matches only the first element among its siblings.",
        "Key properties: `tr`, `background-color`, `font-weight`. Consider selectors like `tr:nth-child(odd)`, `tr:nth-child(even)`."
      ]
    },
    {
      "id": 364,
      "title": "Sticky Header",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "positioning"
      ],
      "tags": [
        "css",
        "positioning",
        "sticky",
        "z-index",
        "intermediate"
      ],
      "description": "Style a header element with position: sticky so it stays visible at the top of the viewport when the user scrolls.",
      "instructions": "Style the `.sticky-header` element so that:\n- It has `position: sticky`\n- It sticks to the top with `top: 0px`\n- It has a `z-index` of `100` to stay above other content\n- It has a `background-color` of `rgb(30, 41, 59)` so content does not show through\n\nThis is a common pattern for navigation bars that remain visible during scrolling.",
      "starterCode": "/* Make the header sticky at the top */\n/* Add z-index and background so it layers properly */\n",
      "solution": ".sticky-header {\n  position: sticky;\n  top: 0px;\n  z-index: 100;\n  background-color: rgb(30, 41, 59);\n}",
      "testRunner": "",
      "providedHtml": "<header class=\"sticky-header\" id=\"header-el\"><h1>My Site</h1></header><main id=\"content\"><p>Content...</p></main>",
      "testCases": [
        {
          "query": "#header-el",
          "assertion": "equals",
          "property": "position",
          "value": "sticky",
          "description": ".sticky-header has position: sticky"
        },
        {
          "query": "#header-el",
          "assertion": "equals",
          "property": "top",
          "value": "0px",
          "description": ".sticky-header top is 0px"
        },
        {
          "query": "#header-el",
          "assertion": "equals",
          "property": "z-index",
          "value": "100",
          "description": ".sticky-header z-index is 100"
        }
      ],
      "hint": "position: sticky makes an element act like position: relative until the user scrolls past a threshold (set by top, bottom, etc.), at which point it becomes fixed. z-index controls stacking order -- higher values sit on top.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: position",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/position",
          "description": "CSS position property"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "The `position` property is central to this exercise.",
        "position: sticky makes an element act like position: relative until the user scrolls past a threshold (set by top, bottom, etc.), at which point it becomes fixed. z-index controls stacking order -- higher values sit on top.",
        "Key properties: `position`, `top`, `z-index`, `background-color`."
      ]
    },
    {
      "id": 365,
      "title": "Keyframe Animation",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "transitions"
      ],
      "tags": [
        "css",
        "animation",
        "keyframes",
        "transitions",
        "intermediate"
      ],
      "description": "Create a @keyframes animation that moves an element horizontally and apply it to a target element.",
      "instructions": "Create a `@keyframes` animation called `slideIn` that:\n- At `from` (0%): `transform: translateX(-100px)`\n- At `to` (100%): `transform: translateX(0)`\n\nApply it to the `.animated` element with:\n- `animation-name: slideIn`\n- `animation-duration: 1s`\n- `animation-fill-mode: forwards`\n\nThe element should slide in from the left over 1 second.",
      "starterCode": "/* Define a @keyframes animation called slideIn */\n/* Apply it to .animated with a duration */\n",
      "solution": "@keyframes slideIn {\n  from {\n    transform: translateX(-100px);\n  }\n  to {\n    transform: translateX(0);\n  }\n}\n\n.animated {\n  animation-name: slideIn;\n  animation-duration: 1s;\n  animation-fill-mode: forwards;\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"animated\" id=\"anim-el\">Animated</div>",
      "testCases": [
        {
          "query": "#anim-el",
          "assertion": "sourceMatch",
          "value": "@keyframes",
          "description": "CSS source contains @keyframes"
        },
        {
          "query": "#anim-el",
          "assertion": "sourceMatch",
          "value": "animation",
          "description": "CSS source contains animation property"
        },
        {
          "query": "#anim-el",
          "assertion": "equals",
          "property": "animation-duration",
          "value": "1s",
          "description": ".animated animation-duration is 1s"
        }
      ],
      "hint": "@keyframes defines the stages of an animation. The \"from\" and \"to\" keywords represent 0% and 100% of the animation timeline. Use the animation shorthand or individual properties (animation-name, animation-duration) to apply it.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS transitions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_transitions",
          "description": "CSS transitions"
        },
        {
          "label": "MDN: CSS animations",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animations",
          "description": "CSS animations"
        }
      ],
      "hints": [
        "The `transform` property is central to this exercise.",
        "@keyframes defines the stages of an animation. The \"from\" and \"to\" keywords represent 0% and 100% of the animation timeline. Use the animation shorthand or individual properties (animation-name, animation-duration) to apply it.",
        "Key properties: `transform`, `animation-name`, `animation-duration`, `animation-fill-mode`."
      ]
    },
    {
      "id": 366,
      "title": "Responsive Images",
      "type": "html-css",
      "tier": 3,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "html",
        "css",
        "responsive",
        "images",
        "layout",
        "intermediate"
      ],
      "description": "Build a responsive image gallery using flexbox wrapping and max-width to ensure images scale within their containers.",
      "instructions": "Build an image gallery:\n\nHTML:\n- A `<div>` with class `gallery`\n- At least 3 `<img>` elements inside the gallery (use any placeholder src and alt text)\n\nCSS:\n- `.gallery` uses `display: flex` and `flex-wrap: wrap`\n- Images have `max-width: 100%` so they scale down responsively\n\nThe gallery should wrap images into rows that adapt to the available width.",
      "starterCode": "<!-- Build a .gallery with at least 3 images -->\n\n<!-- CSS is written in the second editor panel -->\n",
      "solution": "<div class=\"gallery\">\n  <img src=\"/placeholder1.jpg\" alt=\"Image 1\">\n  <img src=\"/placeholder2.jpg\" alt=\"Image 2\">\n  <img src=\"/placeholder3.jpg\" alt=\"Image 3\">\n</div>\n\n/* CSS */\n.gallery {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.gallery img {\n  max-width: 100%;\n}",
      "testRunner": "",
      "testCases": [
        {
          "query": ".gallery",
          "assertion": "exists",
          "description": ".gallery element exists"
        },
        {
          "query": ".gallery",
          "assertion": "equals",
          "property": "display",
          "value": "flex",
          "description": ".gallery uses display: flex"
        },
        {
          "query": ".gallery",
          "assertion": "equals",
          "property": "flex-wrap",
          "value": "wrap",
          "description": ".gallery uses flex-wrap: wrap"
        },
        {
          "query": ".gallery img",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "Gallery contains at least 3 images"
        },
        {
          "query": ".gallery",
          "assertion": "sourceMatch",
          "value": "max-width",
          "description": "CSS source contains max-width"
        }
      ],
      "hint": "Flexbox with flex-wrap creates a flowing layout where items move to the next line when space runs out. Setting max-width: 100% on images prevents them from overflowing their container, making them responsive.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: <img>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img",
          "description": "HTML image element"
        },
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "Flexbox with flex-wrap creates a flowing layout where items move to the next line when space runs out. Setting max-width: 100% on images prevents them from overflowing their container, making them responsive.",
        "HTML: Key elements: `<img>`. Important attributes: `src`, `alt`. CSS: Key properties: `display`, `flex-wrap`, `max-width`."
      ]
    },
    {
      "id": 367,
      "title": "Accessible Table",
      "type": "html",
      "tier": 3,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "tables",
        "accessibility",
        "semantics",
        "intermediate"
      ],
      "description": "Build a properly structured data table with caption, thead, tbody, tfoot, and scope attributes on header cells for screen reader accessibility.",
      "instructions": "Create an accessible data table with:\n- A `<table>` element\n- A `<caption>` describing the table\n- A `<thead>` section with at least 2 `<th>` elements that have `scope=\"col\"` attributes\n- A `<tbody>` section with data rows\n- A `<tfoot>` section with a summary row\n\nThe `scope` attribute on `<th>` elements tells screen readers whether the header applies to a column or row.",
      "starterCode": "<!-- Build an accessible data table -->\n<!-- Include caption, thead, tbody, tfoot -->\n<!-- Add scope attributes to th elements -->\n",
      "solution": "<table>\n  <caption>Monthly Sales</caption>\n  <thead>\n    <tr>\n      <th scope=\"col\">Month</th>\n      <th scope=\"col\">Revenue</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>January</td>\n      <td>$1,200</td>\n    </tr>\n    <tr>\n      <td>February</td>\n      <td>$1,500</td>\n    </tr>\n  </tbody>\n  <tfoot>\n    <tr>\n      <td>Total</td>\n      <td>$2,700</td>\n    </tr>\n  </tfoot>\n</table>",
      "testRunner": "",
      "testCases": [
        {
          "query": "table",
          "assertion": "exists",
          "description": "<table> element exists"
        },
        {
          "query": "caption",
          "assertion": "exists",
          "description": "<caption> element exists"
        },
        {
          "query": "thead",
          "assertion": "exists",
          "description": "<thead> element exists"
        },
        {
          "query": "tbody",
          "assertion": "exists",
          "description": "<tbody> element exists"
        },
        {
          "query": "tfoot",
          "assertion": "exists",
          "description": "<tfoot> element exists"
        },
        {
          "query": "th",
          "assertion": "countAtLeast",
          "value": 2,
          "description": "At least 2 <th> elements exist"
        },
        {
          "query": "table",
          "assertion": "sourceMatch",
          "value": "scope=",
          "description": "HTML source contains scope attribute"
        }
      ],
      "hint": "A well-structured table uses <thead> for header rows, <tbody> for data rows, and <tfoot> for summary rows. The <caption> element provides a title. Adding scope=\"col\" or scope=\"row\" to <th> elements helps screen readers understand the table structure.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: HTML table",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table",
          "description": "HTML table element"
        },
        {
          "label": "MDN: Semantics in HTML",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html",
          "description": "HTML semantic elements"
        }
      ],
      "hints": [
        "What are the three major landmark elements that define the top, body, and bottom of a page?",
        "A well-structured table uses <thead> for header rows, <tbody> for data rows, and <tfoot> for summary rows. The <caption> element provides a title. Adding scope=\"col\" or scope=\"row\" to <th> elements helps screen readers understand the table structure.",
        "Key elements: `<table>`, `<caption>`, `<thead>`, `<tr>`. Important attributes: `scope`."
      ]
    },
    {
      "id": 368,
      "title": "Gradient Backgrounds",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "box-model"
      ],
      "tags": [
        "css",
        "gradients",
        "backgrounds",
        "intermediate"
      ],
      "description": "Apply a linear-gradient background to one element and a radial-gradient to another to create visually rich backgrounds without images.",
      "instructions": "Style the elements so that:\n- `.hero` has a `background` using `linear-gradient` (choose any two colors, e.g., from `#1e3a5f` to `#4a90d9`)\n- `.badge` has a `background` using `radial-gradient` (choose any two colors, e.g., from `#f59e0b` to `#ef4444`)\n\nCSS gradients create smooth color transitions and are a powerful alternative to background images.",
      "starterCode": "/* Apply a linear-gradient to .hero */\n/* Apply a radial-gradient to .badge */\n",
      "solution": ".hero {\n  background: linear-gradient(to right, #1e3a5f, #4a90d9);\n}\n\n.badge {\n  background: radial-gradient(circle, #f59e0b, #ef4444);\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"hero\" id=\"hero-el\"><span class=\"badge\" id=\"badge-el\">New</span></div>",
      "testCases": [
        {
          "query": "#hero-el",
          "assertion": "sourceMatch",
          "value": "linear-gradient",
          "description": "CSS source contains linear-gradient"
        },
        {
          "query": "#badge-el",
          "assertion": "sourceMatch",
          "value": "radial-gradient",
          "description": "CSS source contains radial-gradient"
        }
      ],
      "hint": "linear-gradient() creates a gradient along a straight line (e.g., left to right). radial-gradient() creates a gradient radiating outward from a center point. Both are used as values for the background or background-image property.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS transitions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_transitions",
          "description": "CSS transitions"
        },
        {
          "label": "MDN: CSS gradients",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_images/Using_CSS_gradients",
          "description": "Using CSS gradients"
        }
      ],
      "hints": [
        "The `background` property is central to this exercise.",
        "linear-gradient() creates a gradient along a straight line (e.g., left to right). radial-gradient() creates a gradient radiating outward from a center point. Both are used as values for the background or background-image property.",
        "Key properties: `background`."
      ]
    },
    {
      "id": 369,
      "title": "Media Query Breakpoint",
      "type": "css",
      "tier": 3,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "css",
        "responsive",
        "media-queries",
        "layout",
        "intermediate"
      ],
      "description": "Use a @media query to change a layout from single-column (mobile) to side-by-side (desktop) at a 768px breakpoint.",
      "instructions": "Style the `.container` element with a mobile-first approach:\n\nDefault (mobile) styles:\n- `display: flex`\n- `flex-direction: column`\n\nAt `min-width: 768px` (desktop):\n- `flex-direction: row`\n\nThis is the standard responsive pattern: stack elements vertically on small screens and lay them out horizontally on wider screens.",
      "starterCode": "/* Mobile-first: .container is flex column by default */\n/* Add a @media query at 768px to switch to row */\n",
      "solution": ".container {\n  display: flex;\n  flex-direction: column;\n}\n\n@media (min-width: 768px) {\n  .container {\n    flex-direction: row;\n  }\n}",
      "testRunner": "",
      "providedHtml": "<div class=\"container\" id=\"container-el\"><aside class=\"sidebar\" id=\"sidebar-el\">Sidebar</aside><main class=\"content\" id=\"content-el\">Main</main></div>",
      "testCases": [
        {
          "query": "#container-el",
          "assertion": "equals",
          "property": "display",
          "value": "flex",
          "description": ".container uses display: flex"
        },
        {
          "assertion": "sourceMatch",
          "value": "flex-direction:\\s*column",
          "description": ".container default flex-direction is column (mobile-first)"
        },
        {
          "query": "#container-el",
          "assertion": "sourceMatch",
          "value": "@media",
          "description": "CSS source contains @media query"
        },
        {
          "query": "#container-el",
          "assertion": "sourceMatch",
          "value": "768px",
          "description": "CSS source references 768px breakpoint"
        }
      ],
      "hint": "Mobile-first design means writing your base CSS for small screens, then using @media (min-width: ...) to add styles that kick in on larger screens. flex-direction: column stacks items vertically; row places them side by side.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Flexbox",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout",
          "description": "CSS Flexbox layout"
        },
        {
          "label": "MDN: display",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/display",
          "description": "CSS display property"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "Mobile-first design means writing your base CSS for small screens, then using @media (min-width: ...) to add styles that kick in on larger screens. flex-direction: column stacks items vertically; row places them side by side.",
        "Key properties: `display`, `flex-direction`, `min-width`."
      ]
    },
    {
      "id": 370,
      "title": "Holy Grail Layout",
      "type": "html-css",
      "tier": 4,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "html",
        "css",
        "grid",
        "layout",
        "holy-grail",
        "tier4"
      ],
      "description": "Build the classic holy grail layout using CSS Grid with named grid areas.",
      "instructions": "Build the classic \"holy grail\" layout with five regions:\n\n**Required HTML structure:**\n- A `.layout` container with 5 children:\n  - `<header>` - top bar spanning the full width\n  - `<nav>` - left sidebar navigation\n  - `<main>` - center content area\n  - `<aside>` - right sidebar\n  - `<footer>` - bottom bar spanning the full width\n\n**Required CSS:**\n1. `.layout` uses `display: grid`\n2. Use `grid-template-areas` to define the named regions\n3. Use `grid-template-rows` to control row sizing (e.g. auto 1fr auto)\n4. The middle row should have three columns: nav | main | aside\n5. Header and footer span the full width\n\nThe layout should fill the viewport height using `min-height: 100vh` or similar.",
      "starterCode": "<!-- Build your holy grail layout -->\n\n/* Add your CSS below */\n",
      "solution": "<div class=\"layout\">\n  <header>Header</header>\n  <nav>Navigation</nav>\n  <main>Main Content</main>\n  <aside>Sidebar</aside>\n  <footer>Footer</footer>\n</div>\n\n<style>\n  .layout {\n    display: grid;\n    grid-template-areas:\n      \"header header header\"\n      \"nav    main   aside\"\n      \"footer footer footer\";\n    grid-template-rows: auto 1fr auto;\n    grid-template-columns: 200px 1fr 200px;\n    min-height: 100vh;\n    gap: 8px;\n  }\n  header { grid-area: header; padding: 16px; background: #1e293b; }\n  nav    { grid-area: nav;    padding: 16px; background: #1e293b; }\n  main   { grid-area: main;   padding: 16px; background: #0f172a; }\n  aside  { grid-area: aside;  padding: 16px; background: #1e293b; }\n  footer { grid-area: footer; padding: 16px; background: #1e293b; }\n</style>",
      "testRunner": "",
      "testCases": [
        {
          "query": ".layout",
          "assertion": "exists",
          "description": ".layout container exists"
        },
        {
          "query": ".layout",
          "assertion": "equals",
          "property": "display",
          "value": "grid",
          "description": ".layout uses display: grid"
        },
        {
          "query": "header",
          "assertion": "exists",
          "description": "<header> element exists"
        },
        {
          "query": "nav",
          "assertion": "exists",
          "description": "<nav> element exists"
        },
        {
          "query": "main",
          "assertion": "exists",
          "description": "<main> element exists"
        },
        {
          "query": "aside",
          "assertion": "exists",
          "description": "<aside> element exists"
        },
        {
          "query": "footer",
          "assertion": "exists",
          "description": "<footer> element exists"
        },
        {
          "query": ".layout",
          "assertion": "sourceMatch",
          "value": "grid-template-areas",
          "description": "Uses grid-template-areas"
        },
        {
          "query": ".layout",
          "assertion": "sourceMatch",
          "value": "grid-template-rows",
          "description": "Uses grid-template-rows"
        }
      ],
      "hint": "Define grid-template-areas with three rows: the first and last rows have one name repeated across all columns (header/footer), while the middle row has three different area names. Assign each child to its area with grid-area.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: <a>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a",
          "description": "HTML anchor element"
        },
        {
          "label": "MDN: Semantics in HTML",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html",
          "description": "HTML semantic elements"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "Define grid-template-areas with three rows: the first and last rows have one name repeated across all columns (header/footer), while the middle row has three different area names. Assign each child to its area with grid-area.",
        "HTML: Key elements: `<header>`, `<nav>`, `<main>`, `<aside>`. CSS: Key properties: `display`, `grid-template-areas`, `grid-template-rows`, `grid-template-columns`."
      ]
    },
    {
      "id": 371,
      "title": "CSS-Only Accordion",
      "type": "html-css",
      "tier": 4,
      "category": [
        "css",
        "transitions"
      ],
      "tags": [
        "html",
        "css",
        "accordion",
        "details",
        "summary",
        "interactive",
        "tier4"
      ],
      "description": "Build an accordion component using HTML details/summary elements with custom CSS styling.",
      "instructions": "Build an accordion using native `<details>` and `<summary>` elements with custom CSS.\n\n**Requirements:**\n- At least 3 `<details>` elements, each with a `<summary>` and content inside\n- Style `<summary>` with `cursor: pointer`\n- Style the open state using `details[open]` to visually distinguish expanded sections\n- Add padding, borders, or background to make sections visually distinct\n- Optional: add a transition or icon indicator for open/closed state\n\n**Example structure:**\n```html\n<details>\n  <summary>Section Title</summary>\n  <p>Section content here...</p>\n</details>\n```\n\nThe accordion should be purely HTML/CSS with no JavaScript.",
      "starterCode": "<!-- Build your accordion sections -->\n\n/* Style your accordion below */\n",
      "solution": "<div class=\"accordion\">\n  <details>\n    <summary>What is HTML?</summary>\n    <p>HTML (HyperText Markup Language) is the standard language for creating web pages and web applications.</p>\n  </details>\n  <details>\n    <summary>What is CSS?</summary>\n    <p>CSS (Cascading Style Sheets) is used to style and layout web pages, controlling colors, fonts, spacing, and more.</p>\n  </details>\n  <details>\n    <summary>What is JavaScript?</summary>\n    <p>JavaScript is a programming language that enables interactive and dynamic behavior on websites.</p>\n  </details>\n</div>\n\n<style>\n  .accordion {\n    max-width: 600px;\n  }\n  details {\n    border: 1px solid #334155;\n    border-radius: 6px;\n    margin-bottom: 8px;\n    overflow: hidden;\n  }\n  summary {\n    cursor: pointer;\n    padding: 12px 16px;\n    font-weight: bold;\n    background: #1e293b;\n    list-style: none;\n  }\n  summary::-webkit-details-marker {\n    display: none;\n  }\n  details p {\n    padding: 12px 16px;\n    margin: 0;\n  }\n  details[open] {\n    border-color: #818cf8;\n  }\n  details[open] summary {\n    background: #312e81;\n    border-bottom: 1px solid #334155;\n  }\n</style>",
      "testRunner": "",
      "testCases": [
        {
          "query": "details",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "At least 3 <details> elements"
        },
        {
          "query": "summary",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "At least 3 <summary> elements"
        },
        {
          "query": "details",
          "assertion": "sourceMatch",
          "value": "details",
          "description": "Source contains details elements"
        },
        {
          "query": "summary",
          "assertion": "sourceMatch",
          "value": "summary",
          "description": "Source contains summary elements"
        },
        {
          "query": "details",
          "assertion": "sourceMatch",
          "value": "[open]",
          "description": "Styles the details[open] state"
        }
      ],
      "hint": "The <details> element is natively collapsible in HTML. <summary> provides the clickable heading. Use the details[open] CSS selector to style the expanded state differently. Add cursor: pointer to summary for better UX.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: Semantics in HTML",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html",
          "description": "HTML semantic elements"
        },
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        }
      ],
      "hints": [
        "The `border` property is central to this exercise.",
        "The <details> element is natively collapsible in HTML. <summary> provides the clickable heading. Use the details[open] CSS selector to style the expanded state differently. Add cursor: pointer to summary for better UX.",
        "HTML: Key elements: `<details>`, `<summary>`, `<style>`. CSS: Key properties: `max-width`, `border`, `border-radius`, `margin-bottom`. Consider selectors like `summary::-webkit-details-marker`, `details[open]`."
      ]
    },
    {
      "id": 372,
      "title": "Dark Mode with Custom Properties",
      "type": "css",
      "tier": 4,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "css",
        "custom-properties",
        "dark-mode",
        "theming",
        "tier4"
      ],
      "description": "Implement a dark mode theme system using CSS custom properties on :root and [data-theme=\"dark\"].",
      "instructions": "Create a theming system using CSS custom properties (variables).\n\n**Requirements:**\n1. Define light theme variables on `:root` with at least 3 custom properties (e.g. `--bg`, `--text`, `--accent`)\n2. Override those variables inside `[data-theme=\"dark\"]` for the dark theme\n3. Style `body` using the custom property for background\n4. Style `.card` with a visible background color using a custom property\n5. Style `.btn` with a background color using a custom property\n\nThe provided HTML has `data-theme=\"dark\"` set, so your dark theme values will be active.",
      "starterCode": "/* Define your theme variables and styles */\n",
      "providedHtml": "<div data-theme=\"dark\"><div class=\"card\" id=\"card-el\"><h2>Title</h2><p>Content</p><button class=\"btn\" id=\"btn-el\">Click</button></div></div>",
      "solution": ":root {\n  --bg: #ffffff;\n  --text: #1e293b;\n  --accent: #6366f1;\n  --card-bg: #f1f5f9;\n  --btn-bg: #6366f1;\n}\n\n[data-theme=\"dark\"] {\n  --bg: #0f172a;\n  --text: #e2e8f0;\n  --accent: #818cf8;\n  --card-bg: #1e293b;\n  --btn-bg: #818cf8;\n}\n\nbody {\n  background-color: var(--bg);\n  color: var(--text);\n}\n\n.card {\n  background-color: var(--card-bg);\n  padding: 24px;\n  border-radius: 8px;\n}\n\n.btn {\n  background-color: var(--btn-bg);\n  color: white;\n  padding: 8px 16px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}",
      "testRunner": "",
      "testCases": [
        {
          "query": ":root",
          "assertion": "sourceMatch",
          "value": ":root",
          "description": "Defines variables on :root"
        },
        {
          "query": "[data-theme]",
          "assertion": "sourceMatch",
          "value": "data-theme",
          "description": "Uses data-theme attribute selector"
        },
        {
          "query": ".card",
          "assertion": "sourceMatch",
          "value": "--",
          "description": "Uses at least one CSS custom property"
        },
        {
          "query": "#card-el",
          "assertion": "exists",
          "description": ".card element exists"
        },
        {
          "query": "#btn-el",
          "assertion": "exists",
          "description": ".btn element exists"
        }
      ],
      "hint": "Define CSS custom properties (--name: value) in :root for the default/light theme. Then re-declare the same properties with different values inside [data-theme=\"dark\"]. Use var(--name) throughout your styles so they automatically switch when the data-theme attribute changes.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: Custom properties (CSS variables)",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties",
          "description": "CSS custom properties"
        },
        {
          "label": "MDN: CSS values and units",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units",
          "description": "CSS values and units"
        }
      ],
      "hints": [
        "The `background-color` property is central to this exercise.",
        "Define CSS custom properties (--name: value) in :root for the default/light theme. Then re-declare the same properties with different values inside [data-theme=\"dark\"]. Use var(--name) throughout your styles so they automatically switch when the data-theme attribute changes.",
        "Key properties: `--bg`, `--text`, `--accent`, `--card-bg`. Consider selectors like `:root`, `[data-theme=\"dark\"]`."
      ]
    },
    {
      "id": 373,
      "title": "Advanced Grid: Auto-fit Gallery",
      "type": "css",
      "tier": 4,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "css",
        "grid",
        "auto-fit",
        "minmax",
        "responsive",
        "tier4"
      ],
      "description": "Create a responsive card grid using CSS Grid auto-fit and minmax() with no media queries.",
      "instructions": "Create a responsive grid layout for the gallery that automatically adjusts the number of columns based on available space.\n\n**Requirements:**\n1. `.gallery` uses `display: grid`\n2. Use `grid-template-columns` with `repeat(auto-fit, minmax(...))` or `repeat(auto-fill, minmax(...))` to create responsive columns\n3. Set a `gap` on the gallery for spacing between cards\n4. No media queries needed — the grid should be intrinsically responsive\n5. Each `.card` should have some padding and a visible background or border\n\nThe provided HTML contains 6 cards inside a `.gallery` container.",
      "starterCode": "/* Style the .gallery grid and .card items */\n",
      "providedHtml": "<div class=\"gallery\" id=\"gallery-el\"><div class=\"card\">1</div><div class=\"card\">2</div><div class=\"card\">3</div><div class=\"card\">4</div><div class=\"card\">5</div><div class=\"card\">6</div></div>",
      "solution": ".gallery {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 16px;\n  padding: 16px;\n}\n\n.card {\n  background: #1e293b;\n  border: 1px solid #334155;\n  border-radius: 8px;\n  padding: 24px;\n  text-align: center;\n  font-size: 1.5rem;\n}",
      "testRunner": "",
      "testCases": [
        {
          "query": "#gallery-el",
          "assertion": "equals",
          "property": "display",
          "value": "grid",
          "description": ".gallery uses display: grid"
        },
        {
          "query": ".gallery",
          "assertion": "sourceMatch",
          "value": "auto-fi",
          "description": "Uses auto-fit or auto-fill"
        },
        {
          "query": ".gallery",
          "assertion": "sourceMatch",
          "value": "minmax",
          "description": "Uses minmax() function"
        },
        {
          "query": "#gallery-el",
          "assertion": "exists",
          "description": ".gallery element renders"
        }
      ],
      "hint": "The magic formula is: grid-template-columns: repeat(auto-fit, minmax(MIN_WIDTH, 1fr)). auto-fit fills as many columns as possible at the minimum width, and 1fr lets them stretch to fill leftover space. No media queries needed!",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS Grid",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout",
          "description": "CSS Grid layout"
        },
        {
          "label": "MDN: display",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/display",
          "description": "CSS display property"
        }
      ],
      "hints": [
        "The `display` property is central to this exercise.",
        "The magic formula is: grid-template-columns: repeat(auto-fit, minmax(MIN_WIDTH, 1fr)). auto-fit fills as many columns as possible at the minimum width, and 1fr lets them stretch to fill leftover space. No media queries needed!",
        "Key properties: `display`, `grid-template-columns`, `gap`, `background`."
      ]
    },
    {
      "id": 374,
      "title": "Accessible Navigation with ARIA",
      "type": "html",
      "tier": 4,
      "category": [
        "html",
        "structure"
      ],
      "tags": [
        "html",
        "accessibility",
        "aria",
        "navigation",
        "tier4"
      ],
      "description": "Build an accessible navigation bar using ARIA attributes, roles, and a skip-link.",
      "instructions": "Build an accessible navigation component with proper ARIA attributes.\n\n**Requirements:**\n1. A `<nav>` element with `role=\"navigation\"` and an `aria-label` attribute describing the nav (e.g. \"Main navigation\")\n2. Inside the nav, an unordered list with at least 3 navigation links\n3. One link should have `aria-current=\"page\"` to indicate the current page\n4. A skip-link: an `<a>` element with class `skip-link` that links to `#main-content` (e.g. \"Skip to main content\"). This should appear before the nav.\n5. A `<main id=\"main-content\">` element as the skip-link target\n\n**Example skip-link:**\n```html\n<a class=\"skip-link\" href=\"#main-content\">Skip to main content</a>\n```\n\nThe skip-link is typically visually hidden but becomes visible on focus for keyboard users.",
      "starterCode": "<!-- Build your accessible navigation -->\n",
      "solution": "<a class=\"skip-link\" href=\"#main-content\">Skip to main content</a>\n\n<nav role=\"navigation\" aria-label=\"Main navigation\">\n  <ul>\n    <li><a href=\"#home\" aria-current=\"page\">Home</a></li>\n    <li><a href=\"#about\">About</a></li>\n    <li><a href=\"#contact\">Contact</a></li>\n  </ul>\n</nav>\n\n<main id=\"main-content\">\n  <h1>Welcome</h1>\n  <p>Main content goes here.</p>\n</main>",
      "testRunner": "",
      "testCases": [
        {
          "query": "nav",
          "assertion": "exists",
          "description": "<nav> element exists"
        },
        {
          "query": "nav",
          "assertion": "sourceMatch",
          "value": "role=",
          "description": "nav has a role attribute"
        },
        {
          "query": "nav",
          "assertion": "sourceMatch",
          "value": "aria-label",
          "description": "nav has an aria-label attribute"
        },
        {
          "query": "nav",
          "assertion": "sourceMatch",
          "value": "aria-current",
          "description": "Uses aria-current to mark active page"
        },
        {
          "query": ".skip-link",
          "assertion": "sourceMatch",
          "value": "skip",
          "description": "Contains a skip link"
        }
      ],
      "hint": "The role=\"navigation\" explicitly tells assistive technology this is a navigation landmark. aria-label provides a text label for when there are multiple navs. aria-current=\"page\" tells screen readers which link represents the current page. The skip-link lets keyboard users jump past the nav.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: <ul>, <ol>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul",
          "description": "HTML list elements"
        },
        {
          "label": "MDN: <a>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a",
          "description": "HTML anchor element"
        }
      ],
      "hints": [
        "Start by thinking about accessibility (a11y).",
        "The role=\"navigation\" explicitly tells assistive technology this is a navigation landmark. aria-label provides a text label for when there are multiple navs. aria-current=\"page\" tells screen readers which link represents the current page. The skip-link lets keyboard users jump past the nav.",
        "Key elements: `<a>`, `<nav>`, `<ul>`, `<li>`. Important attributes: `href`, `role`."
      ]
    },
    {
      "id": 375,
      "title": "Full Page Responsive Layout",
      "type": "html-css",
      "tier": 5,
      "category": [
        "css",
        "layout"
      ],
      "tags": [
        "html",
        "css",
        "responsive",
        "grid",
        "flexbox",
        "composition",
        "tier5"
      ],
      "description": "Build a complete responsive page from scratch with hero, features grid, testimonials, and multi-column footer.",
      "instructions": "Build a complete, responsive landing page from scratch.\n\n**Required sections:**\n1. A `<nav>` with at least 3 `<a>` links\n2. A `.hero` section with a heading and call-to-action\n3. A `.features` section using CSS Grid to display feature cards\n4. A `.testimonials` section with at least one testimonial\n5. A `<footer>` with multi-column link groups\n\n**Required CSS techniques:**\n1. Use **CSS Grid** for the features section (`grid-template-columns`)\n2. Use **Flexbox** for at least one section (nav, footer, etc.)\n3. Define and use at least one **CSS custom property** (`--`)\n4. Include at least one **`@media` query** for responsive behavior\n5. All sections should be visually distinct with appropriate spacing\n\nThis is a composition exercise: plan the full page structure, then style each section.",
      "starterCode": "<!-- Build your full-page layout from scratch -->\n",
      "solution": "<nav class=\"main-nav\">\n  <div class=\"logo\">Brand</div>\n  <div class=\"nav-links\">\n    <a href=\"#features\">Features</a>\n    <a href=\"#testimonials\">Testimonials</a>\n    <a href=\"#contact\">Contact</a>\n  </div>\n</nav>\n\n<section class=\"hero\">\n  <h1>Build Something Amazing</h1>\n  <p>A modern toolkit for modern developers.</p>\n  <a href=\"#features\" class=\"cta-btn\">Get Started</a>\n</section>\n\n<section class=\"features\" id=\"features\">\n  <h2>Features</h2>\n  <div class=\"features-grid\">\n    <div class=\"feature-card\">\n      <h3>Fast</h3>\n      <p>Optimized for performance.</p>\n    </div>\n    <div class=\"feature-card\">\n      <h3>Flexible</h3>\n      <p>Adapts to any workflow.</p>\n    </div>\n    <div class=\"feature-card\">\n      <h3>Friendly</h3>\n      <p>Great developer experience.</p>\n    </div>\n  </div>\n</section>\n\n<section class=\"testimonials\" id=\"testimonials\">\n  <h2>Testimonials</h2>\n  <blockquote>\n    <p>\"This changed the way I build websites.\"</p>\n    <cite>- A Happy Developer</cite>\n  </blockquote>\n</section>\n\n<footer>\n  <div class=\"footer-columns\">\n    <div class=\"footer-col\">\n      <h4>Product</h4>\n      <a href=\"#\">Features</a>\n      <a href=\"#\">Pricing</a>\n    </div>\n    <div class=\"footer-col\">\n      <h4>Company</h4>\n      <a href=\"#\">About</a>\n      <a href=\"#\">Blog</a>\n    </div>\n    <div class=\"footer-col\">\n      <h4>Support</h4>\n      <a href=\"#\">Docs</a>\n      <a href=\"#\">Contact</a>\n    </div>\n  </div>\n</footer>\n\n<style>\n  :root {\n    --primary: #6366f1;\n    --spacing: 24px;\n    --text: #e2e8f0;\n    --bg: #0f172a;\n  }\n\n  * { box-sizing: border-box; margin: 0; padding: 0; }\n  body { background: var(--bg); color: var(--text); font-family: system-ui, sans-serif; }\n\n  .main-nav {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 16px var(--spacing);\n    background: #1e293b;\n  }\n  .nav-links { display: flex; gap: 16px; }\n  .nav-links a { color: var(--text); text-decoration: none; }\n\n  .hero {\n    text-align: center;\n    padding: 80px var(--spacing);\n  }\n  .hero h1 { font-size: 2.5rem; margin-bottom: 16px; }\n  .cta-btn {\n    display: inline-block;\n    margin-top: 16px;\n    padding: 12px 32px;\n    background: var(--primary);\n    color: white;\n    border-radius: 6px;\n    text-decoration: none;\n  }\n\n  .features { padding: var(--spacing); text-align: center; }\n  .features h2 { margin-bottom: var(--spacing); }\n  .features-grid {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 16px;\n    max-width: 900px;\n    margin: 0 auto;\n  }\n  .feature-card {\n    background: #1e293b;\n    padding: var(--spacing);\n    border-radius: 8px;\n  }\n\n  .testimonials {\n    padding: 48px var(--spacing);\n    text-align: center;\n  }\n  .testimonials blockquote {\n    max-width: 600px;\n    margin: 16px auto;\n    font-style: italic;\n  }\n\n  footer {\n    background: #1e293b;\n    padding: var(--spacing);\n  }\n  .footer-columns {\n    display: flex;\n    justify-content: space-around;\n    max-width: 900px;\n    margin: 0 auto;\n  }\n  .footer-col {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n  }\n  .footer-col a { color: var(--text); text-decoration: none; }\n\n  @media (max-width: 768px) {\n    .features-grid {\n      grid-template-columns: 1fr;\n    }\n    .footer-columns {\n      flex-direction: column;\n      gap: 24px;\n      align-items: center;\n    }\n  }\n</style>",
      "testRunner": "",
      "testCases": [
        {
          "query": ".hero",
          "assertion": "exists",
          "description": ".hero section exists"
        },
        {
          "query": ".features",
          "assertion": "exists",
          "description": ".features section exists"
        },
        {
          "query": ".testimonials",
          "assertion": "exists",
          "description": ".testimonials section exists"
        },
        {
          "query": "footer",
          "assertion": "exists",
          "description": "<footer> element exists"
        },
        {
          "query": ".features",
          "assertion": "sourceMatch",
          "value": "grid-template-columns",
          "description": "Features section uses grid-template-columns"
        },
        {
          "query": ".features",
          "assertion": "sourceMatch",
          "value": "@media",
          "description": "Uses at least one @media query"
        },
        {
          "query": ".features",
          "assertion": "sourceMatch",
          "value": "--",
          "description": "Uses CSS custom properties"
        },
        {
          "query": "nav a",
          "assertion": "countAtLeast",
          "value": 3,
          "description": "Navigation has at least 3 links"
        }
      ],
      "hint": "Plan the page top-to-bottom: nav, hero, features, testimonials, footer. Use Grid for the features card layout (grid-template-columns: repeat(3, 1fr)). Use Flexbox for the nav and footer columns. Define custom properties in :root and add a @media query to stack columns on small screens.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: <a>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a",
          "description": "HTML anchor element"
        },
        {
          "label": "MDN: Semantics in HTML",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html",
          "description": "HTML semantic elements"
        }
      ],
      "hints": [
        "The `background` property is central to this exercise.",
        "Plan the page top-to-bottom: nav, hero, features, testimonials, footer. Use Grid for the features card layout (grid-template-columns: repeat(3, 1fr)). Use Flexbox for the nav and footer columns. Define custom properties in :root and add a @media query to stack columns on small screens.",
        "HTML: Key elements: `<nav>`, `<a>`, `<section>`, `<h1>`. Important attributes: `href`. CSS: Key properties: `--primary`, `--spacing`, `--text`, `--bg`."
      ]
    },
    {
      "id": 376,
      "title": "Complex Animation Sequence",
      "type": "css",
      "tier": 5,
      "category": [
        "css",
        "transitions"
      ],
      "tags": [
        "css",
        "animation",
        "keyframes",
        "transforms",
        "complex",
        "tier5"
      ],
      "description": "Create multiple coordinated @keyframes animations: a spinning loader, a fade-in sequence, and a pulse effect.",
      "instructions": "Create a multi-animation CSS system with three distinct @keyframes animations.\n\n**Requirements:**\n1. A `@keyframes spin` animation that rotates an element 360 degrees (for the spinner)\n2. A `@keyframes fadeIn` animation that fades content from transparent to visible\n3. A `@keyframes pulse` animation that scales an element up and down rhythmically\n4. Apply the spin animation to `.spinner` using the `animation` property\n5. Apply fadeIn to `.content`\n6. Apply pulse to `.pulse`\n7. Use `transform` in at least one keyframe (e.g. rotate or scale)\n\n**Provided HTML includes:**\n- A `.loader` container with a `.spinner` inside\n- A `.content` container with a `.card.pulse` inside\n\nMake the animations visually interesting — the spinner should spin continuously, fadeIn should play once, and pulse should loop.",
      "starterCode": "/* Create your @keyframes animations and apply them */\n",
      "providedHtml": "<div class=\"loader\" id=\"loader-el\"><div class=\"spinner\" id=\"spinner-el\"></div></div><div class=\"content\" id=\"content-el\"><div class=\"card pulse\" id=\"pulse-el\">Card</div></div>",
      "solution": "@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; transform: translateY(20px); }\n  to { opacity: 1; transform: translateY(0); }\n}\n\n@keyframes pulse {\n  0%, 100% { transform: scale(1); }\n  50% { transform: scale(1.05); }\n}\n\n.loader {\n  display: flex;\n  justify-content: center;\n  padding: 24px;\n}\n\n.spinner {\n  width: 40px;\n  height: 40px;\n  border: 4px solid #334155;\n  border-top-color: #818cf8;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n}\n\n.content {\n  animation: fadeIn 0.6s ease-out forwards;\n  padding: 24px;\n}\n\n.card {\n  background: #1e293b;\n  padding: 24px;\n  border-radius: 8px;\n  display: inline-block;\n}\n\n.pulse {\n  animation: pulse 2s ease-in-out infinite;\n}",
      "testRunner": "",
      "testCases": [
        {
          "query": ".spinner",
          "assertion": "sourceMatch",
          "value": "@keyframes\\s+\\w+",
          "description": "Defines at least one @keyframes animation"
        },
        {
          "query": ".spinner",
          "assertion": "sourceMatch",
          "value": "@keyframes",
          "description": "Contains multiple @keyframes blocks"
        },
        {
          "query": "#spinner-el",
          "assertion": "exists",
          "description": ".spinner element renders"
        },
        {
          "query": ".spinner",
          "assertion": "sourceMatch",
          "value": "transform",
          "description": "Uses transform in animations"
        }
      ],
      "hint": "@keyframes defines an animation sequence — each block needs a name (spin, fadeIn, pulse). Use from/to or percentage steps. Apply with the animation shorthand: animation: name duration timing-function iteration-count. transform: rotate() for spinning, scale() for pulsing, translateY() for sliding.",
      "resources": [
        {
          "label": "MDN: CSS reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference",
          "description": "CSS reference"
        },
        {
          "label": "MDN: CSS transitions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_transitions",
          "description": "CSS transitions"
        },
        {
          "label": "MDN: CSS animations",
          "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animations",
          "description": "CSS animations"
        }
      ],
      "hints": [
        "The `transform` property is central to this exercise.",
        "@keyframes defines an animation sequence — each block needs a name (spin, fadeIn, pulse). Use from/to or percentage steps. Apply with the animation shorthand: animation: name duration timing-function iteration-count. transform: rotate() for spinning, scale() for pulsing, translateY() for sliding.",
        "Key properties: `transform`, `opacity`, `display`, `justify-content`."
      ]
    },
    {
      "id": 377,
      "title": "Pixel-Perfect Card Component",
      "type": "html-css",
      "tier": 5,
      "category": [
        "css",
        "box-model"
      ],
      "tags": [
        "html",
        "css",
        "component",
        "composition",
        "pixel-perfect",
        "tier5"
      ],
      "description": "Build a detailed card component matching exact specs: border-radius, shadows, gradient overlay, hover transform, and precise spacing.",
      "instructions": "Build a pixel-perfect card component matching these exact specifications.\n\n**Required HTML structure:**\n- `.card` - the outer card container\n- `.card-image` - an image area (can use a colored div as placeholder)\n- `.card-body` - the text content area\n- `.card-tag` - an absolute-positioned badge/tag overlay on the image\n\n**Exact CSS specifications:**\n1. `.card`:\n   - `border-radius: 16px`\n   - `overflow: hidden`\n   - A `box-shadow` for depth\n   - Background color\n\n2. `.card-image`:\n   - `aspect-ratio` set (e.g. 16/9 or 3/2)\n   - Background color or image as placeholder\n\n3. `.card-body`:\n   - Padding for content spacing\n   - Contains heading and text\n\n4. `.card-tag`:\n   - `position: absolute` (positioned over the image area)\n   - Small badge styling (padding, border-radius, background)\n\n5. Hover effect: subtle `transform` on `.card:hover` (e.g. translateY or scale)\n\nBuild everything from scratch — both the HTML structure and all CSS.",
      "starterCode": "<!-- Build your pixel-perfect card -->\n",
      "solution": "<div class=\"card\">\n  <div class=\"card-image-wrapper\">\n    <div class=\"card-image\"></div>\n    <span class=\"card-tag\">Featured</span>\n  </div>\n  <div class=\"card-body\">\n    <h3>Card Title</h3>\n    <p>This is a pixel-perfect card component with precise spacing, shadows, and a gradient overlay.</p>\n  </div>\n</div>\n\n<style>\n  .card {\n    max-width: 360px;\n    border-radius: 16px;\n    overflow: hidden;\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);\n    background: #1e293b;\n    transition: transform 0.2s ease;\n  }\n\n  .card:hover {\n    transform: translateY(-4px);\n  }\n\n  .card-image-wrapper {\n    position: relative;\n  }\n\n  .card-image {\n    aspect-ratio: 16 / 9;\n    background: linear-gradient(135deg, #6366f1, #818cf8);\n  }\n\n  .card-tag {\n    position: absolute;\n    top: 12px;\n    right: 12px;\n    background: rgba(0, 0, 0, 0.7);\n    color: #e2e8f0;\n    padding: 4px 12px;\n    border-radius: 999px;\n    font-size: 12px;\n    font-weight: 600;\n  }\n\n  .card-body {\n    padding: 20px;\n  }\n\n  .card-body h3 {\n    margin: 0 0 8px 0;\n    font-size: 1.25rem;\n  }\n\n  .card-body p {\n    margin: 0;\n    font-size: 0.875rem;\n    line-height: 1.5;\n    color: #94a3b8;\n  }\n</style>",
      "testRunner": "",
      "testCases": [
        {
          "query": ".card",
          "assertion": "exists",
          "description": ".card element exists"
        },
        {
          "query": ".card",
          "assertion": "equals",
          "property": "border-radius",
          "value": "16px",
          "description": ".card has border-radius of 16px"
        },
        {
          "query": ".card",
          "assertion": "equals",
          "property": "overflow",
          "value": "hidden",
          "description": ".card has overflow hidden"
        },
        {
          "query": ".card",
          "assertion": "sourceMatch",
          "value": "box-shadow",
          "description": ".card uses box-shadow"
        },
        {
          "query": ".card-image",
          "assertion": "exists",
          "description": ".card-image element exists"
        },
        {
          "query": ".card-image",
          "assertion": "sourceMatch",
          "value": "aspect-ratio",
          "description": ".card-image uses aspect-ratio"
        },
        {
          "query": ".card-body",
          "assertion": "exists",
          "description": ".card-body element exists"
        },
        {
          "query": ".card-tag",
          "assertion": "exists",
          "description": ".card-tag element exists"
        },
        {
          "query": ".card-tag",
          "assertion": "equals",
          "property": "position",
          "value": "absolute",
          "description": ".card-tag has position absolute"
        }
      ],
      "hint": "Start with the .card container: border-radius, overflow:hidden, and box-shadow give it the card shape and depth. The image wrapper needs position:relative so the tag can be position:absolute inside it. Use aspect-ratio on the image placeholder. The card-body just needs padding for spacing.",
      "resources": [
        {
          "label": "MDN: HTML elements reference",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
          "description": "HTML elements reference"
        },
        {
          "label": "MDN: HTML forms",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/Forms",
          "description": "Web forms guide"
        },
        {
          "label": "MDN: <img>",
          "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img",
          "description": "HTML image element"
        }
      ],
      "hints": [
        "The `border-radius` property is central to this exercise.",
        "Start with the .card container: border-radius, overflow:hidden, and box-shadow give it the card shape and depth. The image wrapper needs position:relative so the tag can be position:absolute inside it. Use aspect-ratio on the image placeholder. The card-body just needs padding for spacing.",
        "HTML: Key elements: `<h3>`, `<style>`. CSS: Key properties: `max-width`, `border-radius`, `overflow`, `box-shadow`. Consider selectors like `.card:hover`."
      ]
    },
    {
      "id": 378,
      "title": "promiseRace",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "implementation",
        "error-handling",
        "tier4"
      ],
      "description": "Implement your own Promise.race — resolve or reject with the first settled promise.",
      "instructions": "Write a function:\n\n**promiseRace(promises)**\n- Takes an array of promises\n- Returns a new Promise that settles with the result of the first promise to settle\n- If the first to settle resolves, the returned promise resolves with that value\n- If the first to settle rejects, the returned promise rejects with that reason\n- If the array is empty, the returned promise should never settle (remain pending)\n\n```js\nconst fast = new Promise(r => setTimeout(() => r('fast'), 10));\nconst slow = new Promise(r => setTimeout(() => r('slow'), 100));\nconst result = await promiseRace([fast, slow]);\n// result === 'fast'\n```",
      "starterCode": "function promiseRace(promises) {\n  // your code here\n}",
      "solution": "function promiseRace(promises) {\n  return new Promise((resolve, reject) => {\n    for (const p of promises) {\n      Promise.resolve(p).then(resolve, reject);\n    }\n  });\n}",
      "testRunner": "(code) => {\n  const promiseRace = new Function(code + '; return promiseRace;')();\n  const results = [];\n\n  const test1 = (async () => {\n    const r = await promiseRace([Promise.resolve('a'), Promise.resolve('b')]);\n    return r === 'a';\n  })();\n\n  const test2 = (async () => {\n    const fast = new Promise(r => setTimeout(() => r('fast'), 10));\n    const slow = new Promise(r => setTimeout(() => r('slow'), 100));\n    const r = await promiseRace([slow, fast]);\n    return r === 'fast';\n  })();\n\n  const test3 = (async () => {\n    try {\n      await promiseRace([Promise.reject('err'), Promise.resolve('ok')]);\n      return false;\n    } catch (e) {\n      return e === 'err';\n    }\n  })();\n\n  const test4 = (async () => {\n    const r = await promiseRace([42, Promise.resolve('str')]);\n    return r === 42;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'First resolved promise wins', got: String(r1) },\n    { pass: r2, description: 'Faster promise wins regardless of array order', got: String(r2) },\n    { pass: r3, description: 'First rejection causes race to reject', got: String(r3) },\n    { pass: r4, description: 'Handles non-promise values', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Return a new Promise. Inside, loop over all promises.",
        "Use Promise.resolve(p) to handle non-promise values, then call .then(resolve, reject) for each.",
        "The first promise to call resolve or reject wins — subsequent calls are ignored by the Promise constructor."
      ],
      "resources": [
        {
          "label": "MDN: Promise.race",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
        }
      ]
    },
    {
      "id": 379,
      "title": "promiseAllSettled",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "implementation",
        "error-handling",
        "tier4"
      ],
      "description": "Implement your own Promise.allSettled — wait for all promises to settle and return their outcomes.",
      "instructions": "Write a function:\n\n**promiseAllSettled(promises)**\n- Takes an array of promises\n- Returns a Promise that resolves when ALL input promises have settled\n- Never rejects — always resolves with an array of outcome objects\n- Each outcome is either `{ status: 'fulfilled', value }` or `{ status: 'rejected', reason }`\n- Results are in the same order as the input array\n- If the array is empty, resolves with `[]`\n\n```js\nconst results = await promiseAllSettled([\n  Promise.resolve('ok'),\n  Promise.reject('fail'),\n  Promise.resolve(42)\n]);\n// [\n//   { status: 'fulfilled', value: 'ok' },\n//   { status: 'rejected', reason: 'fail' },\n//   { status: 'fulfilled', value: 42 }\n// ]\n```",
      "starterCode": "function promiseAllSettled(promises) {\n  // your code here\n}",
      "solution": "function promiseAllSettled(promises) {\n  return new Promise((resolve) => {\n    if (promises.length === 0) return resolve([]);\n    const results = new Array(promises.length);\n    let count = 0;\n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(value => {\n          results[i] = { status: 'fulfilled', value };\n        })\n        .catch(reason => {\n          results[i] = { status: 'rejected', reason };\n        })\n        .finally(() => {\n          count++;\n          if (count === promises.length) resolve(results);\n        });\n    });\n  });\n}",
      "testRunner": "(code) => {\n  const promiseAllSettled = new Function(code + '; return promiseAllSettled;')();\n\n  const test1 = (async () => {\n    const r = await promiseAllSettled([]);\n    return Array.isArray(r) && r.length === 0;\n  })();\n\n  const test2 = (async () => {\n    const r = await promiseAllSettled([Promise.resolve(1), Promise.resolve(2)]);\n    return r.length === 2 && r[0].status === 'fulfilled' && r[0].value === 1 && r[1].value === 2;\n  })();\n\n  const test3 = (async () => {\n    const r = await promiseAllSettled([Promise.reject('err')]);\n    return r.length === 1 && r[0].status === 'rejected' && r[0].reason === 'err';\n  })();\n\n  const test4 = (async () => {\n    const r = await promiseAllSettled([Promise.resolve('a'), Promise.reject('b'), Promise.resolve('c')]);\n    return r[0].status === 'fulfilled' && r[1].status === 'rejected' && r[2].status === 'fulfilled' && r[1].reason === 'b';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Empty array resolves to []', got: String(r1) },\n    { pass: r2, description: 'All fulfilled promises captured correctly', got: String(r2) },\n    { pass: r3, description: 'Rejected promise captured with status and reason', got: String(r3) },\n    { pass: r4, description: 'Mixed fulfilled/rejected in correct order', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Return a new Promise that always resolves (never rejects).",
        "Track a count of settled promises. When count equals the array length, resolve with the results array.",
        "Use .then() for fulfilled and .catch() for rejected, then .finally() to increment the counter."
      ],
      "resources": [
        {
          "label": "MDN: Promise.allSettled",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
        }
      ]
    },
    {
      "id": 380,
      "title": "tryCatchWrapper",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "error-handling",
        "try-catch",
        "tier4"
      ],
      "description": "Write a utility that wraps an async function in try/catch and returns a [error, data] tuple.",
      "instructions": "Write a function:\n\n**tryCatchWrapper(asyncFn)**\n- Takes an async function `asyncFn`\n- Returns a new async function that, when called:\n  - Calls `asyncFn` with the same arguments\n  - If it succeeds, returns `[null, result]`\n  - If it throws, returns `[error, null]`\n- This pattern eliminates nested try/catch blocks\n\n```js\nconst safeFetch = tryCatchWrapper(async (url) => {\n  if (url === 'bad') throw new Error('Not found');\n  return { data: 'hello' };\n});\n\nconst [err1, data1] = await safeFetch('good');\n// err1 === null, data1 === { data: 'hello' }\n\nconst [err2, data2] = await safeFetch('bad');\n// err2.message === 'Not found', data2 === null\n```",
      "starterCode": "function tryCatchWrapper(asyncFn) {\n  // return a new async function\n}",
      "solution": "function tryCatchWrapper(asyncFn) {\n  return async function(...args) {\n    try {\n      const result = await asyncFn(...args);\n      return [null, result];\n    } catch (error) {\n      return [error, null];\n    }\n  };\n}",
      "testRunner": "(code) => {\n  const tryCatchWrapper = new Function(code + '; return tryCatchWrapper;')();\n\n  const test1 = (async () => {\n    const safe = tryCatchWrapper(async () => 42);\n    const [err, data] = await safe();\n    return err === null && data === 42;\n  })();\n\n  const test2 = (async () => {\n    const safe = tryCatchWrapper(async () => { throw new Error('boom'); });\n    const [err, data] = await safe();\n    return err instanceof Error && err.message === 'boom' && data === null;\n  })();\n\n  const test3 = (async () => {\n    const safe = tryCatchWrapper(async (a, b) => a + b);\n    const [err, data] = await safe(3, 4);\n    return err === null && data === 7;\n  })();\n\n  const test4 = (async () => {\n    const safe = tryCatchWrapper(async (x) => { if (x < 0) throw new Error('negative'); return x * 2; });\n    const [e1, d1] = await safe(5);\n    const [e2, d2] = await safe(-1);\n    return d1 === 10 && e1 === null && e2.message === 'negative' && d2 === null;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Success returns [null, result]', got: String(r1) },\n    { pass: r2, description: 'Error returns [error, null]', got: String(r2) },\n    { pass: r3, description: 'Passes through all arguments', got: String(r3) },\n    { pass: r4, description: 'Same wrapper handles both outcomes', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Return an async function that uses ...args to forward all arguments.",
        "Inside the returned function, use try/catch around `await asyncFn(...args)`.",
        "On success return [null, result]. On catch return [error, null]."
      ],
      "resources": [
        {
          "label": "MDN: try...catch",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"
        }
      ]
    },
    {
      "id": 381,
      "title": "promiseTimeout",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "error-handling",
        "timeout",
        "tier4"
      ],
      "description": "Write a function that wraps a promise with a timeout — reject if it takes too long.",
      "instructions": "Write a function:\n\n**promiseTimeout(promise, ms)**\n- Takes a promise and a timeout duration in milliseconds\n- Returns a new Promise:\n  - If the original promise settles before the timeout, resolve/reject with its result\n  - If the timeout fires first, reject with a new `Error('Promise timed out')`\n\n```js\nconst fast = new Promise(r => setTimeout(() => r('done'), 10));\nconst result = await promiseTimeout(fast, 1000);\n// result === 'done'\n\nconst slow = new Promise(r => setTimeout(() => r('done'), 5000));\nawait promiseTimeout(slow, 50);\n// throws Error('Promise timed out')\n```",
      "starterCode": "function promiseTimeout(promise, ms) {\n  // your code here\n}",
      "solution": "function promiseTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Promise timed out')), ms);\n  });\n  return Promise.race([promise, timeout]);\n}",
      "testRunner": "(code) => {\n  const promiseTimeout = new Function(code + '; return promiseTimeout;')();\n\n  const test1 = (async () => {\n    const r = await promiseTimeout(Promise.resolve('ok'), 1000);\n    return r === 'ok';\n  })();\n\n  const test2 = (async () => {\n    try {\n      await promiseTimeout(new Promise(r => setTimeout(() => r('late'), 500)), 10);\n      return false;\n    } catch (e) {\n      return e.message === 'Promise timed out';\n    }\n  })();\n\n  const test3 = (async () => {\n    try {\n      await promiseTimeout(Promise.reject('fail'), 1000);\n      return false;\n    } catch (e) {\n      return e === 'fail';\n    }\n  })();\n\n  const test4 = (async () => {\n    const r = await promiseTimeout(new Promise(r => setTimeout(() => r(42), 5)), 1000);\n    return r === 42;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Resolves if promise is fast enough', got: String(r1) },\n    { pass: r2, description: 'Rejects with timeout error if too slow', got: String(r2) },\n    { pass: r3, description: 'Original rejection passes through', got: String(r3) },\n    { pass: r4, description: 'Async promise resolves before timeout', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Create a second promise that rejects after `ms` milliseconds using setTimeout.",
        "Use Promise.race to race the original promise against the timeout.",
        "The first to settle wins — either the original result or the timeout error."
      ],
      "resources": [
        {
          "label": "MDN: Promise.race",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
        }
      ]
    },
    {
      "id": 382,
      "title": "chainPromises",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "chaining",
        "tier4"
      ],
      "description": "Write a function that chains an array of async functions sequentially, passing each result to the next.",
      "instructions": "Write a function:\n\n**chainPromises(fns, initialValue)**\n- `fns` is an array of functions, each takes a value and returns a Promise\n- `initialValue` is the starting value passed to the first function\n- Execute each function in sequence, passing the resolved value of the previous to the next\n- Return a Promise that resolves with the final value\n- If any function rejects, the chain should reject with that error\n\n```js\nconst double = async (x) => x * 2;\nconst addTen = async (x) => x + 10;\nconst toString = async (x) => String(x);\n\nconst result = await chainPromises([double, addTen, toString], 5);\n// 5 → 10 → 20 → '20'\n// result === '20'\n```",
      "starterCode": "function chainPromises(fns, initialValue) {\n  // your code here\n}",
      "solution": "function chainPromises(fns, initialValue) {\n  return fns.reduce(\n    (chain, fn) => chain.then(fn),\n    Promise.resolve(initialValue)\n  );\n}",
      "testRunner": "(code) => {\n  const chainPromises = new Function(code + '; return chainPromises;')();\n\n  const test1 = (async () => {\n    const r = await chainPromises([async x => x * 2, async x => x + 1], 5);\n    return r === 11;\n  })();\n\n  const test2 = (async () => {\n    const r = await chainPromises([], 42);\n    return r === 42;\n  })();\n\n  const test3 = (async () => {\n    try {\n      await chainPromises([async x => x * 2, async x => { throw new Error('stop'); }, async x => x + 1], 5);\n      return false;\n    } catch (e) {\n      return e.message === 'stop';\n    }\n  })();\n\n  const test4 = (async () => {\n    const r = await chainPromises([async x => x.toUpperCase(), async x => x + '!'], 'hello');\n    return r === 'HELLO!';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Chains two async functions: 5 → 10 → 11', got: String(r1) },\n    { pass: r2, description: 'Empty array returns initialValue', got: String(r2) },\n    { pass: r3, description: 'Rejection stops the chain', got: String(r3) },\n    { pass: r4, description: 'Works with string transformations', got: String(r4) },\n  ]);\n}",
      "hints": [
        "What does `async/await` do under the hood, and how does error handling work with it?",
        "Array.reduce is perfect here: start with Promise.resolve(initialValue) and .then(fn) for each function.",
        "Key pattern: `fns.reduce((chain, fn) => chain.then(fn), Promise.resolve(initialValue))`"
      ],
      "resources": [
        {
          "label": "MDN: Promise.prototype.then()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
        }
      ]
    },
    {
      "id": 383,
      "title": "customError",
      "type": "js",
      "tier": 4,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "error-handling",
        "try-catch",
        "inheritance",
        "tier4"
      ],
      "description": "Create custom error classes that extend Error with extra context like status codes and error types.",
      "instructions": "Create three custom error classes:\n\n**AppError(message, code)**\n- Extends `Error`\n- Properties: `message`, `code` (number), `name` set to `'AppError'`\n\n**ValidationError(message, field)**\n- Extends `AppError` with code `400`\n- Additional property: `field` (the invalid field name)\n- `name` set to `'ValidationError'`\n\n**NotFoundError(resource)**\n- Extends `AppError` with code `404`\n- `message` set to `'${resource} not found'`\n- `name` set to `'NotFoundError'`\n\n```js\nconst err = new ValidationError('Invalid email', 'email');\nerr.message   // 'Invalid email'\nerr.code      // 400\nerr.field     // 'email'\nerr.name      // 'ValidationError'\nerr instanceof ValidationError // true\nerr instanceof AppError        // true\nerr instanceof Error           // true\n```",
      "starterCode": "class AppError extends Error {\n  constructor(message, code) {\n    // your code here\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message, field) {\n    // your code here\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource) {\n    // your code here\n  }\n}",
      "solution": "class AppError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n    this.name = 'AppError';\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message, field) {\n    super(message, 400);\n    this.field = field;\n    this.name = 'ValidationError';\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource) {\n    super(`${resource} not found`, 404);\n    this.name = 'NotFoundError';\n  }\n}",
      "testRunner": "(code) => {\n  const classes = new Function(code + '; return { AppError, ValidationError, NotFoundError };')();\n  const { AppError, ValidationError, NotFoundError } = classes;\n\n  const app = new AppError('Server error', 500);\n  const val = new ValidationError('Invalid email', 'email');\n  const nf = new NotFoundError('User');\n\n  return [\n    { pass: app instanceof Error && app.code === 500 && app.name === 'AppError', description: 'AppError extends Error with code and name', got: `${app.name}, code=${app.code}` },\n    { pass: val instanceof AppError && val.code === 400 && val.field === 'email' && val.name === 'ValidationError', description: 'ValidationError extends AppError with code 400 and field', got: `${val.name}, code=${val.code}, field=${val.field}` },\n    { pass: nf.message === 'User not found' && nf.code === 404 && nf.name === 'NotFoundError', description: 'NotFoundError sets message and code 404', got: `${nf.message}, code=${nf.code}` },\n    { pass: val instanceof Error && nf instanceof AppError && nf instanceof Error, description: 'Inheritance chain works (instanceof checks)', got: String(val instanceof Error && nf instanceof AppError) },\n  ];\n}",
      "hints": [
        "Use `super(message)` to call the parent Error constructor.",
        "Set `this.name` in each constructor to match the class name.",
        "ValidationError calls `super(message, 400)` to pass to AppError, then sets `this.field`."
      ],
      "resources": [
        {
          "label": "MDN: Custom Errors",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types"
        }
      ]
    },
    {
      "id": 384,
      "title": "asyncMap",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "promises",
        "higher-order",
        "tier4"
      ],
      "description": "Write an async version of Array.map that processes items concurrently and returns results in order.",
      "instructions": "Write a function:\n\n**asyncMap(array, asyncFn)**\n- `array` is an array of values\n- `asyncFn` is an async function `(item, index) => Promise`\n- Calls `asyncFn` for every item concurrently (not sequentially)\n- Returns a Promise that resolves with an array of results in the same order as the input\n- If any call rejects, the returned promise rejects\n\n```js\nconst results = await asyncMap([1, 2, 3], async (n) => n * 2);\n// results === [2, 4, 6]\n\n// All calls start at the same time (concurrent)\nconst times = await asyncMap([30, 10, 20], async (ms) => {\n  await new Promise(r => setTimeout(r, ms));\n  return ms;\n});\n// times === [30, 10, 20]  (order preserved)\n```",
      "starterCode": "async function asyncMap(array, asyncFn) {\n  // your code here\n}",
      "solution": "async function asyncMap(array, asyncFn) {\n  return Promise.all(array.map((item, index) => asyncFn(item, index)));\n}",
      "testRunner": "(code) => {\n  const asyncMap = new Function(code + '; return asyncMap;')();\n\n  const test1 = (async () => {\n    const r = await asyncMap([1, 2, 3], async n => n * 2);\n    return JSON.stringify(r) === '[2,4,6]';\n  })();\n\n  const test2 = (async () => {\n    const r = await asyncMap([], async n => n);\n    return JSON.stringify(r) === '[]';\n  })();\n\n  const test3 = (async () => {\n    const order = [];\n    await asyncMap([30, 10, 20], async (ms, i) => {\n      await new Promise(r => setTimeout(r, ms));\n      order.push(i);\n      return ms;\n    });\n    return order[0] === 1 && order[1] === 2 && order[2] === 0;\n  })();\n\n  const test4 = (async () => {\n    try {\n      await asyncMap([1, 2, 3], async n => { if (n === 2) throw new Error('bad'); return n; });\n      return false;\n    } catch (e) {\n      return e.message === 'bad';\n    }\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Maps values concurrently', got: String(r1) },\n    { pass: r2, description: 'Handles empty array', got: String(r2) },\n    { pass: r3, description: 'Runs concurrently (shorter tasks finish first internally)', got: String(r3) },\n    { pass: r4, description: 'Rejection propagates', got: String(r4) },\n  ]);\n}",
      "hints": [
        "What does `async/await` do under the hood, and how does error handling work with it?",
        "Use array.map() to create an array of promises, then wrap with Promise.all().",
        "One-liner: `return Promise.all(array.map((item, index) => asyncFn(item, index)))`"
      ],
      "resources": [
        {
          "label": "MDN: Promise.all",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        }
      ]
    },
    {
      "id": 385,
      "title": "asyncFilter",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "promises",
        "higher-order",
        "tier4"
      ],
      "description": "Write an async version of Array.filter where the predicate is an async function.",
      "instructions": "Write a function:\n\n**asyncFilter(array, asyncPredicate)**\n- `array` is an array of values\n- `asyncPredicate` is an async function `(item) => Promise<boolean>`\n- Tests each item concurrently using the predicate\n- Returns a Promise that resolves with a new array containing only items where the predicate resolved to `true`\n- Results maintain original order\n\n```js\nconst result = await asyncFilter([1, 2, 3, 4, 5], async (n) => {\n  await new Promise(r => setTimeout(r, 10));\n  return n % 2 === 0;\n});\n// result === [2, 4]\n```",
      "starterCode": "async function asyncFilter(array, asyncPredicate) {\n  // your code here\n}",
      "solution": "async function asyncFilter(array, asyncPredicate) {\n  const results = await Promise.all(\n    array.map(async (item) => ({\n      item,\n      keep: await asyncPredicate(item),\n    }))\n  );\n  return results.filter(r => r.keep).map(r => r.item);\n}",
      "testRunner": "(code) => {\n  const asyncFilter = new Function(code + '; return asyncFilter;')();\n\n  const test1 = (async () => {\n    const r = await asyncFilter([1, 2, 3, 4], async n => n > 2);\n    return JSON.stringify(r) === '[3,4]';\n  })();\n\n  const test2 = (async () => {\n    const r = await asyncFilter([], async n => true);\n    return JSON.stringify(r) === '[]';\n  })();\n\n  const test3 = (async () => {\n    const r = await asyncFilter(['hello', 'hi', 'hey', 'h'], async s => s.length > 2);\n    return JSON.stringify(r) === '[\"hello\",\"hey\"]';\n  })();\n\n  const test4 = (async () => {\n    const r = await asyncFilter([1, 2, 3], async n => false);\n    return JSON.stringify(r) === '[]';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Filters items where predicate is true', got: String(r1) },\n    { pass: r2, description: 'Handles empty array', got: String(r2) },\n    { pass: r3, description: 'Works with string items', got: String(r3) },\n    { pass: r4, description: 'All false returns empty array', got: String(r4) },\n  ]);\n}",
      "hints": [
        "You cannot just use array.filter with an async function — filter does not await.",
        "Map each item to a { item, keep: await predicate(item) } object using Promise.all, then filter synchronously.",
        "Pattern: `Promise.all(array.map(async item => ({ item, keep: await pred(item) })))` then `.filter(r => r.keep).map(r => r.item)`"
      ],
      "resources": [
        {
          "label": "MDN: Array.filter",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        }
      ]
    },
    {
      "id": 386,
      "title": "promiseAny",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "implementation",
        "error-handling",
        "tier4"
      ],
      "description": "Implement your own Promise.any — resolve with the first fulfilled promise, or reject if all reject.",
      "instructions": "Write a function:\n\n**promiseAny(promises)**\n- Takes an array of promises\n- Returns a new Promise that resolves with the value of the first promise to **fulfill**\n- Ignores rejections unless ALL promises reject\n- If all reject, reject with an `AggregateError` containing all rejection reasons:\n  - `new AggregateError(errors, 'All promises were rejected')`\n- If the array is empty, reject with an AggregateError with empty errors array\n\n```js\nconst result = await promiseAny([\n  Promise.reject('a'),\n  Promise.resolve('b'),\n  Promise.resolve('c')\n]);\n// result === 'b'  (first to fulfill)\n```",
      "starterCode": "function promiseAny(promises) {\n  // your code here\n}",
      "solution": "function promiseAny(promises) {\n  return new Promise((resolve, reject) => {\n    if (promises.length === 0) {\n      return reject(new AggregateError([], 'All promises were rejected'));\n    }\n    const errors = new Array(promises.length);\n    let rejectedCount = 0;\n    promises.forEach((p, i) => {\n      Promise.resolve(p).then(resolve, (err) => {\n        errors[i] = err;\n        rejectedCount++;\n        if (rejectedCount === promises.length) {\n          reject(new AggregateError(errors, 'All promises were rejected'));\n        }\n      });\n    });\n  });\n}",
      "testRunner": "(code) => {\n  const promiseAny = new Function(code + '; return promiseAny;')();\n\n  const test1 = (async () => {\n    const r = await promiseAny([Promise.reject('a'), Promise.resolve('b')]);\n    return r === 'b';\n  })();\n\n  const test2 = (async () => {\n    const r = await promiseAny([Promise.resolve('first'), Promise.resolve('second')]);\n    return r === 'first';\n  })();\n\n  const test3 = (async () => {\n    try {\n      await promiseAny([Promise.reject('x'), Promise.reject('y')]);\n      return false;\n    } catch (e) {\n      return e instanceof AggregateError && e.errors.length === 2 && e.errors[0] === 'x';\n    }\n  })();\n\n  const test4 = (async () => {\n    try {\n      await promiseAny([]);\n      return false;\n    } catch (e) {\n      return e instanceof AggregateError && e.errors.length === 0;\n    }\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Resolves with first fulfilled, ignoring rejections', got: String(r1) },\n    { pass: r2, description: 'First fulfilled wins among all fulfilled', got: String(r2) },\n    { pass: r3, description: 'All rejected → AggregateError with all reasons', got: String(r3) },\n    { pass: r4, description: 'Empty array rejects with AggregateError', got: String(r4) },\n  ]);\n}",
      "hints": [
        "This is the opposite of Promise.all: resolve on first success, reject only if all fail.",
        "Track rejection count. When rejectedCount equals the array length, reject with AggregateError.",
        "Use Promise.resolve(p).then(resolve, ...) to handle non-promise values."
      ],
      "resources": [
        {
          "label": "MDN: Promise.any",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
        }
      ]
    },
    {
      "id": 387,
      "title": "errorBoundary",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "error-handling",
        "try-catch",
        "tier4"
      ],
      "description": "Build an error boundary utility that catches errors from multiple async operations and collects them.",
      "instructions": "Write a function:\n\n**createErrorBoundary()**\n- Returns an object with:\n  - `run(asyncFn)` — executes an async function, catches and stores any error, returns `undefined` on failure\n  - `get errors` — getter returning array of all caught errors\n  - `get hasErrors` — getter returning boolean\n  - `get results` — getter returning array of all successful results\n\n```js\nconst boundary = createErrorBoundary();\n\nawait boundary.run(async () => 'ok');\nawait boundary.run(async () => { throw new Error('fail'); });\nawait boundary.run(async () => 42);\n\nboundary.results;    // ['ok', 42]\nboundary.errors;     // [Error('fail')]\nboundary.hasErrors;  // true\n```",
      "starterCode": "function createErrorBoundary() {\n  // your code here\n}",
      "solution": "function createErrorBoundary() {\n  const errors = [];\n  const results = [];\n\n  return {\n    async run(asyncFn) {\n      try {\n        const result = await asyncFn();\n        results.push(result);\n        return result;\n      } catch (err) {\n        errors.push(err);\n        return undefined;\n      }\n    },\n    get errors() { return errors; },\n    get hasErrors() { return errors.length > 0; },\n    get results() { return results; },\n  };\n}",
      "testRunner": "(code) => {\n  const createErrorBoundary = new Function(code + '; return createErrorBoundary;')();\n\n  const test1 = (async () => {\n    const b = createErrorBoundary();\n    const r = await b.run(async () => 'hello');\n    return r === 'hello' && b.results.length === 1;\n  })();\n\n  const test2 = (async () => {\n    const b = createErrorBoundary();\n    const r = await b.run(async () => { throw new Error('oops'); });\n    return r === undefined && b.errors.length === 1 && b.errors[0].message === 'oops';\n  })();\n\n  const test3 = (async () => {\n    const b = createErrorBoundary();\n    await b.run(async () => 1);\n    await b.run(async () => { throw new Error('x'); });\n    await b.run(async () => 2);\n    return JSON.stringify(b.results) === '[1,2]' && b.errors.length === 1 && b.hasErrors === true;\n  })();\n\n  const test4 = (async () => {\n    const b = createErrorBoundary();\n    return b.hasErrors === false && b.errors.length === 0 && b.results.length === 0;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Successful run returns result and stores it', got: String(r1) },\n    { pass: r2, description: 'Failed run returns undefined and stores error', got: String(r2) },\n    { pass: r3, description: 'Mixed operations collect results and errors separately', got: String(r3) },\n    { pass: r4, description: 'Fresh boundary has no errors or results', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Use closure to store private `errors` and `results` arrays.",
        "The `run` method should use try/catch — push to results on success, errors on catch.",
        "Use getters (get errors(), get hasErrors(), etc.) for read-only access."
      ],
      "resources": [
        {
          "label": "MDN: try...catch",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"
        }
      ]
    },
    {
      "id": 388,
      "title": "debounceAsync",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "higher-order"
      ],
      "tags": [
        "async",
        "promises",
        "debounce",
        "closures",
        "tier4"
      ],
      "description": "Write a debounced async function that only executes the latest call after a delay.",
      "instructions": "Write a function:\n\n**debounceAsync(fn, delay)**\n- `fn` is an async function\n- `delay` is milliseconds to wait\n- Returns a new function that, when called:\n  - Cancels any pending call from a previous invocation\n  - Waits `delay` ms, then calls `fn` with the latest arguments\n  - Returns a Promise that resolves with fn's result\n  - If cancelled by a newer call, the returned Promise should never resolve\n\n```js\nlet callCount = 0;\nconst search = debounceAsync(async (query) => {\n  callCount++;\n  return `results for ${query}`;\n}, 50);\n\nsearch('he');      // cancelled\nsearch('hel');     // cancelled\nconst result = await search('hello');  // executes after 50ms\n// result === 'results for hello'\n// callCount === 1\n```",
      "starterCode": "function debounceAsync(fn, delay) {\n  // your code here\n}",
      "solution": "function debounceAsync(fn, delay) {\n  let timerId = null;\n\n  return function(...args) {\n    if (timerId !== null) clearTimeout(timerId);\n\n    return new Promise((resolve) => {\n      timerId = setTimeout(async () => {\n        const result = await fn(...args);\n        resolve(result);\n      }, delay);\n    });\n  };\n}",
      "testRunner": "(code) => {\n  const debounceAsync = new Function(code + '; return debounceAsync;')();\n\n  const test1 = (async () => {\n    let count = 0;\n    const fn = debounceAsync(async () => { count++; return 'ok'; }, 20);\n    const p = fn();\n    const r = await p;\n    return r === 'ok' && count === 1;\n  })();\n\n  const test2 = (async () => {\n    let count = 0;\n    const fn = debounceAsync(async (x) => { count++; return x; }, 30);\n    fn('a');\n    fn('b');\n    const r = await fn('c');\n    await new Promise(r => setTimeout(r, 50));\n    return r === 'c' && count === 1;\n  })();\n\n  const test3 = (async () => {\n    const fn = debounceAsync(async (x) => x * 2, 10);\n    const r = await fn(5);\n    return r === 10;\n  })();\n\n  const test4 = (async () => {\n    let count = 0;\n    const fn = debounceAsync(async () => { count++; return count; }, 10);\n    const r1 = await fn();\n    const r2 = await fn();\n    return r1 === 1 && r2 === 2;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Single call executes after delay', got: String(r1) },\n    { pass: r2, description: 'Rapid calls — only last executes', got: String(r2) },\n    { pass: r3, description: 'Passes arguments correctly', got: String(r3) },\n    { pass: r4, description: 'Sequential awaited calls each execute', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Track the timer ID in a closure variable. Clear it on each new call.",
        "Return a new Promise. Inside setTimeout, call fn(...args) and resolve with the result.",
        "Use clearTimeout(timerId) before setting a new timeout to cancel previous calls."
      ],
      "resources": [
        {
          "label": "MDN: setTimeout",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        }
      ]
    },
    {
      "id": 389,
      "title": "safeJsonParse",
      "type": "js",
      "tier": 4,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "error-handling",
        "try-catch",
        "json",
        "tier4"
      ],
      "description": "Write a safe JSON parser that returns a default value instead of throwing on invalid input.",
      "instructions": "Write a function:\n\n**safeJsonParse(str, defaultValue)**\n- Attempts to parse `str` as JSON\n- If successful, returns the parsed value\n- If `JSON.parse` throws (invalid JSON), returns `defaultValue`\n- If `str` is not a string, returns `defaultValue`\n- `defaultValue` defaults to `null` if not provided\n\n```js\nsafeJsonParse('{\"a\":1}');          // { a: 1 }\nsafeJsonParse('invalid', {});       // {}\nsafeJsonParse('{bad json}', []);    // []\nsafeJsonParse(undefined);           // null\nsafeJsonParse('\"hello\"');           // 'hello'\n```",
      "starterCode": "function safeJsonParse(str, defaultValue) {\n  // your code here\n}",
      "solution": "function safeJsonParse(str, defaultValue = null) {\n  if (typeof str !== 'string') return defaultValue;\n  try {\n    return JSON.parse(str);\n  } catch {\n    return defaultValue;\n  }\n}",
      "testRunner": "(code) => {\n  const safeJsonParse = new Function(code + '; return safeJsonParse;')();\n\n  const t1 = JSON.stringify(safeJsonParse('{\"a\":1}')) === '{\"a\":1}';\n  const t2 = safeJsonParse('invalid', 'fallback') === 'fallback';\n  const t3 = safeJsonParse(undefined) === null;\n  const t4 = safeJsonParse('\"hello\"') === 'hello';\n  const t5 = JSON.stringify(safeJsonParse('{bad}', [])) === '[]';\n\n  return [\n    { pass: t1, description: 'Parses valid JSON object', got: String(t1) },\n    { pass: t2, description: 'Returns defaultValue for invalid JSON', got: String(t2) },\n    { pass: t3, description: 'Returns null (default) for non-string input', got: String(t3) },\n    { pass: t4, description: 'Parses JSON string value', got: String(t4) },\n    { pass: t5, description: 'Returns array default for malformed JSON', got: String(t5) },\n  ];\n}",
      "hints": [
        "First check if str is a string using typeof.",
        "Wrap JSON.parse in a try/catch block.",
        "Use a default parameter: `defaultValue = null`."
      ],
      "resources": [
        {
          "label": "MDN: JSON.parse",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"
        }
      ]
    },
    {
      "id": 390,
      "title": "parallelLimit",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "concurrency",
        "tier4"
      ],
      "description": "Run async tasks in parallel but limit how many execute at the same time.",
      "instructions": "Write a function:\n\n**parallelLimit(tasks, limit)**\n- `tasks` is an array of functions that return Promises (thunks)\n- `limit` is the max number of concurrent tasks\n- Executes tasks respecting the concurrency limit\n- Returns a Promise that resolves with an array of all results in order\n- If any task rejects, the returned promise rejects\n\n```js\nlet running = 0, maxRunning = 0;\nconst tasks = [10, 20, 30, 40, 50].map(ms => async () => {\n  running++;\n  maxRunning = Math.max(maxRunning, running);\n  await new Promise(r => setTimeout(r, ms));\n  running--;\n  return ms;\n});\n\nconst results = await parallelLimit(tasks, 2);\n// results === [10, 20, 30, 40, 50]\n// maxRunning === 2  (never more than 2 at once)\n```",
      "starterCode": "async function parallelLimit(tasks, limit) {\n  // your code here\n}",
      "solution": "async function parallelLimit(tasks, limit) {\n  const results = new Array(tasks.length);\n  let nextIndex = 0;\n\n  async function worker() {\n    while (nextIndex < tasks.length) {\n      const i = nextIndex++;\n      results[i] = await tasks[i]();\n    }\n  }\n\n  const workers = Array.from({ length: Math.min(limit, tasks.length) }, () => worker());\n  await Promise.all(workers);\n  return results;\n}",
      "testRunner": "(code) => {\n  const parallelLimit = new Function(code + '; return parallelLimit;')();\n\n  const test1 = (async () => {\n    const r = await parallelLimit([async () => 1, async () => 2, async () => 3], 2);\n    return JSON.stringify(r) === '[1,2,3]';\n  })();\n\n  const test2 = (async () => {\n    let running = 0, maxRunning = 0;\n    const tasks = [1,2,3,4,5].map(n => async () => {\n      running++; maxRunning = Math.max(maxRunning, running);\n      await new Promise(r => setTimeout(r, 10));\n      running--; return n;\n    });\n    await parallelLimit(tasks, 2);\n    return maxRunning <= 2;\n  })();\n\n  const test3 = (async () => {\n    const r = await parallelLimit([], 5);\n    return JSON.stringify(r) === '[]';\n  })();\n\n  const test4 = (async () => {\n    const r = await parallelLimit([async () => 'a', async () => 'b'], 10);\n    return JSON.stringify(r) === '[\"a\",\"b\"]';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Returns results in order', got: String(r1) },\n    { pass: r2, description: 'Respects concurrency limit', got: String(r2) },\n    { pass: r3, description: 'Empty tasks array returns []', got: String(r3) },\n    { pass: r4, description: 'Works when limit exceeds task count', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Think of spawning `limit` worker functions that pull from a shared index.",
        "Each worker runs in a while loop: grab the next index, await the task, store the result.",
        "Use Promise.all to wait for all workers to finish."
      ],
      "resources": [
        {
          "label": "MDN: Promise.all",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        }
      ]
    },
    {
      "id": 391,
      "title": "eventEmitterAsync",
      "type": "js",
      "tier": 4,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "async",
        "events",
        "error-handling",
        "tier4"
      ],
      "description": "Build an EventEmitter that supports async listeners and waits for all of them to complete.",
      "instructions": "Build a class:\n\n**AsyncEventEmitter**\n- `on(event, listener)` — registers an async listener for an event\n- `off(event, listener)` — removes a specific listener\n- `async emit(event, ...args)` — calls all listeners for the event with args, waits for all to complete, returns array of results\n- `listenerCount(event)` — returns the number of listeners for an event\n\n```js\nconst emitter = new AsyncEventEmitter();\n\nemitter.on('save', async (data) => {\n  await new Promise(r => setTimeout(r, 10));\n  return `saved ${data}`;\n});\n\nconst results = await emitter.emit('save', 'doc1');\n// results === ['saved doc1']\n```",
      "starterCode": "class AsyncEventEmitter {\n  constructor() {\n    // your code here\n  }\n\n  on(event, listener) {}\n  off(event, listener) {}\n  async emit(event, ...args) {}\n  listenerCount(event) {}\n}",
      "solution": "class AsyncEventEmitter {\n  constructor() {\n    this.listeners = {};\n  }\n\n  on(event, listener) {\n    if (!this.listeners[event]) this.listeners[event] = [];\n    this.listeners[event].push(listener);\n  }\n\n  off(event, listener) {\n    if (!this.listeners[event]) return;\n    this.listeners[event] = this.listeners[event].filter(l => l !== listener);\n  }\n\n  async emit(event, ...args) {\n    if (!this.listeners[event]) return [];\n    return Promise.all(this.listeners[event].map(l => l(...args)));\n  }\n\n  listenerCount(event) {\n    return (this.listeners[event] || []).length;\n  }\n}",
      "testRunner": "(code) => {\n  const AsyncEventEmitter = new Function(code + '; return AsyncEventEmitter;')();\n\n  const test1 = (async () => {\n    const e = new AsyncEventEmitter();\n    e.on('test', async (x) => x * 2);\n    const r = await e.emit('test', 5);\n    return JSON.stringify(r) === '[10]';\n  })();\n\n  const test2 = (async () => {\n    const e = new AsyncEventEmitter();\n    e.on('test', async () => 'a');\n    e.on('test', async () => 'b');\n    const r = await e.emit('test');\n    return JSON.stringify(r) === '[\"a\",\"b\"]';\n  })();\n\n  const test3 = (async () => {\n    const e = new AsyncEventEmitter();\n    const fn = async () => 'x';\n    e.on('test', fn);\n    e.off('test', fn);\n    return e.listenerCount('test') === 0;\n  })();\n\n  const test4 = (async () => {\n    const e = new AsyncEventEmitter();\n    const r = await e.emit('none');\n    return JSON.stringify(r) === '[]';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Single listener receives args and returns result', got: String(r1) },\n    { pass: r2, description: 'Multiple listeners all execute', got: String(r2) },\n    { pass: r3, description: 'off() removes listener', got: String(r3) },\n    { pass: r4, description: 'Emitting unknown event returns empty array', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Store listeners in an object: `{ eventName: [fn1, fn2, ...] }`.",
        "emit() should map listeners to promises and use Promise.all.",
        "off() filters the listener array to remove the specific function reference."
      ],
      "resources": [
        {
          "label": "MDN: EventTarget",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget"
        }
      ]
    },
    {
      "id": 392,
      "title": "promiseFinally",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "implementation",
        "tier4"
      ],
      "description": "Implement a polyfill for Promise.prototype.finally that runs cleanup regardless of outcome.",
      "instructions": "Write a function:\n\n**promiseFinally(promise, onFinally)**\n- Takes a promise and a callback function `onFinally`\n- Returns a new Promise that:\n  - Calls `onFinally()` when the original promise settles (resolve or reject)\n  - Preserves the original promise's resolved value or rejection reason\n  - If `onFinally` throws, the returned promise rejects with that error instead\n  - If `onFinally` returns a promise, waits for it before settling\n\n```js\nconst result = await promiseFinally(Promise.resolve(42), () => {\n  console.log('cleanup');\n});\n// logs 'cleanup', result === 42\n\ntry {\n  await promiseFinally(Promise.reject('err'), () => console.log('cleanup'));\n} catch (e) {\n  // logs 'cleanup', e === 'err'\n}\n```",
      "starterCode": "function promiseFinally(promise, onFinally) {\n  // your code here\n}",
      "solution": "function promiseFinally(promise, onFinally) {\n  return promise.then(\n    value => Promise.resolve(onFinally()).then(() => value),\n    reason => Promise.resolve(onFinally()).then(() => { throw reason; })\n  );\n}",
      "testRunner": "(code) => {\n  const promiseFinally = new Function(code + '; return promiseFinally;')();\n\n  const test1 = (async () => {\n    let called = false;\n    const r = await promiseFinally(Promise.resolve(42), () => { called = true; });\n    return r === 42 && called;\n  })();\n\n  const test2 = (async () => {\n    let called = false;\n    try {\n      await promiseFinally(Promise.reject('err'), () => { called = true; });\n      return false;\n    } catch (e) {\n      return e === 'err' && called;\n    }\n  })();\n\n  const test3 = (async () => {\n    try {\n      await promiseFinally(Promise.resolve(1), () => { throw new Error('cleanup fail'); });\n      return false;\n    } catch (e) {\n      return e.message === 'cleanup fail';\n    }\n  })();\n\n  const test4 = (async () => {\n    let order = [];\n    const r = await promiseFinally(Promise.resolve('val'), async () => {\n      await new Promise(r => setTimeout(r, 10));\n      order.push('finally');\n    });\n    return r === 'val' && order[0] === 'finally';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Calls onFinally and preserves resolved value', got: String(r1) },\n    { pass: r2, description: 'Calls onFinally and preserves rejection', got: String(r2) },\n    { pass: r3, description: 'onFinally throwing overrides the original result', got: String(r3) },\n    { pass: r4, description: 'Waits for async onFinally before settling', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Use .then() with both a success and error handler.",
        "In the success handler: run onFinally(), then return the original value.",
        "Key: `Promise.resolve(onFinally()).then(() => value)` preserves value and waits for async cleanup."
      ],
      "resources": [
        {
          "label": "MDN: Promise.prototype.finally()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"
        }
      ]
    },
    {
      "id": 393,
      "title": "retryWithBackoff",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "error-handling",
        "retry",
        "tier4"
      ],
      "description": "Write an async retry utility with exponential backoff between attempts.",
      "instructions": "Write a function:\n\n**retryWithBackoff(fn, options)**\n- `fn` is an async function\n- `options` has `{ maxRetries, baseDelay, maxDelay }`\n  - `maxRetries`: max retry attempts (default 3)\n  - `baseDelay`: initial delay in ms (default 100)\n  - `maxDelay`: maximum delay cap in ms (default 5000)\n- Retry logic:\n  1. Call `fn()`. If it succeeds, return the result.\n  2. If it throws, wait `baseDelay * 2^attempt` ms (but capped at `maxDelay`)\n  3. After `maxRetries` total retries, throw the last error\n- The delay doubles each attempt: `100, 200, 400, 800, ...` (capped at `maxDelay`)\n\n```js\nlet attempt = 0;\nconst result = await retryWithBackoff(\n  async () => { attempt++; if (attempt < 3) throw new Error('fail'); return 'done'; },\n  { maxRetries: 5, baseDelay: 10 }\n);\n// result === 'done', attempt === 3\n```",
      "starterCode": "async function retryWithBackoff(fn, options = {}) {\n  const maxRetries = options.maxRetries ?? 3;\n  const baseDelay = options.baseDelay ?? 100;\n  const maxDelay = options.maxDelay ?? 5000;\n\n  // your code here\n}",
      "solution": "async function retryWithBackoff(fn, options = {}) {\n  const maxRetries = options.maxRetries ?? 3;\n  const baseDelay = options.baseDelay ?? 100;\n  const maxDelay = options.maxDelay ?? 5000;\n\n  let lastError;\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (attempt < maxRetries) {\n        const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n        await new Promise(r => setTimeout(r, delay));\n      }\n    }\n  }\n  throw lastError;\n}",
      "testRunner": "(code) => {\n  const retryWithBackoff = new Function(code + '; return retryWithBackoff;')();\n\n  const test1 = (async () => {\n    const r = await retryWithBackoff(async () => 'ok', { maxRetries: 3, baseDelay: 1 });\n    return r === 'ok';\n  })();\n\n  const test2 = (async () => {\n    let c = 0;\n    const r = await retryWithBackoff(async () => { c++; if (c < 3) throw new Error('x'); return 'done'; }, { maxRetries: 5, baseDelay: 1 });\n    return r === 'done' && c === 3;\n  })();\n\n  const test3 = (async () => {\n    try {\n      await retryWithBackoff(async () => { throw new Error('always'); }, { maxRetries: 2, baseDelay: 1 });\n      return false;\n    } catch (e) {\n      return e.message === 'always';\n    }\n  })();\n\n  const test4 = (async () => {\n    const start = Date.now();\n    let c = 0;\n    await retryWithBackoff(async () => { c++; if (c < 2) throw new Error('x'); return 'ok'; }, { maxRetries: 3, baseDelay: 20, maxDelay: 50 });\n    const elapsed = Date.now() - start;\n    return elapsed >= 15;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Succeeds on first try', got: String(r1) },\n    { pass: r2, description: 'Retries until success', got: String(r2) },\n    { pass: r3, description: 'Throws after max retries exhausted', got: String(r3) },\n    { pass: r4, description: 'Actually delays between retries', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Use a for loop from 0 to maxRetries. Try calling fn() each iteration.",
        "Calculate delay: `Math.min(baseDelay * 2 ** attempt, maxDelay)`.",
        "Wait with `await new Promise(r => setTimeout(r, delay))` between retries."
      ],
      "resources": [
        {
          "label": "MDN: async/await",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises"
        }
      ]
    },
    {
      "id": 394,
      "title": "createMiddleware",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "higher-order"
      ],
      "tags": [
        "async",
        "functions",
        "middleware",
        "composition",
        "tier4"
      ],
      "description": "Build a middleware pipeline where each function can modify data before passing to the next.",
      "instructions": "Write a function:\n\n**createMiddleware()**\n- Returns an object with:\n  - `use(fn)` — adds a middleware function `fn(context, next)`\n  - `async run(context)` — executes all middleware in order\n\nEach middleware receives:\n- `context`: a shared object that middleware can read/modify\n- `next`: an async function to call the next middleware\n\nMiddleware must call `next()` to continue the chain. If a middleware doesn't call `next()`, the chain stops.\n\n```js\nconst mw = createMiddleware();\nmw.use(async (ctx, next) => { ctx.step1 = true; await next(); });\nmw.use(async (ctx, next) => { ctx.step2 = true; await next(); });\n\nconst ctx = {};\nawait mw.run(ctx);\n// ctx === { step1: true, step2: true }\n```",
      "starterCode": "function createMiddleware() {\n  // your code here\n}",
      "solution": "function createMiddleware() {\n  const stack = [];\n\n  return {\n    use(fn) {\n      stack.push(fn);\n    },\n    async run(context) {\n      let index = 0;\n      async function next() {\n        if (index < stack.length) {\n          const fn = stack[index++];\n          await fn(context, next);\n        }\n      }\n      await next();\n      return context;\n    }\n  };\n}",
      "testRunner": "(code) => {\n  const createMiddleware = new Function(code + '; return createMiddleware;')();\n\n  const test1 = (async () => {\n    const mw = createMiddleware();\n    mw.use(async (ctx, next) => { ctx.a = 1; await next(); });\n    mw.use(async (ctx, next) => { ctx.b = 2; await next(); });\n    const ctx = {};\n    await mw.run(ctx);\n    return ctx.a === 1 && ctx.b === 2;\n  })();\n\n  const test2 = (async () => {\n    const mw = createMiddleware();\n    const order = [];\n    mw.use(async (ctx, next) => { order.push('a-before'); await next(); order.push('a-after'); });\n    mw.use(async (ctx, next) => { order.push('b'); await next(); });\n    await mw.run({});\n    return order.join(',') === 'a-before,b,a-after';\n  })();\n\n  const test3 = (async () => {\n    const mw = createMiddleware();\n    mw.use(async (ctx, next) => { ctx.ran = true; });\n    mw.use(async (ctx, next) => { ctx.skipped = true; await next(); });\n    const ctx = {};\n    await mw.run(ctx);\n    return ctx.ran === true && ctx.skipped === undefined;\n  })();\n\n  const test4 = (async () => {\n    const mw = createMiddleware();\n    const ctx = { count: 0 };\n    await mw.run(ctx);\n    return ctx.count === 0;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Middleware chain modifies context', got: String(r1) },\n    { pass: r2, description: 'Executes in onion order (before-next-after)', got: String(r2) },\n    { pass: r3, description: 'Not calling next() stops the chain', got: String(r3) },\n    { pass: r4, description: 'Empty middleware stack works', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Store middleware functions in an array. Track the current index.",
        "The `next` function increments the index and calls the next middleware.",
        "This is similar to how Express.js or Koa middleware works."
      ],
      "resources": [
        {
          "label": "MDN: async function",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
        }
      ]
    },
    {
      "id": 395,
      "title": "Dataset: Weather Station",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "objects",
        "reduce",
        "chaining",
        "dataset",
        "tier4"
      ],
      "description": "Analyze weather station data to find temperature extremes, averages, and patterns.",
      "instructions": "You are given an array of weather readings:\n\n```js\nconst readings = [\n  { station: 'A', date: '2024-01-01', tempC: 5, humidity: 60, wind: 15 },\n  { station: 'B', date: '2024-01-01', tempC: -2, humidity: 80, wind: 25 },\n  // ...\n];\n```\n\nWrite these functions:\n\n**avgTempByStation(readings)** — returns an object mapping station names to their average temperature (rounded to 1 decimal)\n\n**hottestDay(readings)** — returns the date string with the highest temperature across all stations\n\n**windyDays(readings, threshold)** — returns an array of unique dates where ANY station recorded wind above the threshold\n\n**dailySummary(readings)** — returns an array of `{ date, avgTemp, maxWind }` objects, one per unique date, sorted by date ascending. avgTemp rounded to 1 decimal.\n\n```js\navgTempByStation(readings); // { A: 5.0, B: -2.0 }\nhottestDay(readings);        // '2024-01-01'\n```",
      "starterCode": "function avgTempByStation(readings) {\n  // your code here\n}\n\nfunction hottestDay(readings) {\n  // your code here\n}\n\nfunction windyDays(readings, threshold) {\n  // your code here\n}\n\nfunction dailySummary(readings) {\n  // your code here\n}",
      "solution": "function avgTempByStation(readings) {\n  const groups = {};\n  for (const r of readings) {\n    if (!groups[r.station]) groups[r.station] = [];\n    groups[r.station].push(r.tempC);\n  }\n  const result = {};\n  for (const [station, temps] of Object.entries(groups)) {\n    result[station] = Math.round((temps.reduce((a, b) => a + b, 0) / temps.length) * 10) / 10;\n  }\n  return result;\n}\n\nfunction hottestDay(readings) {\n  let maxTemp = -Infinity, maxDate = '';\n  for (const r of readings) {\n    if (r.tempC > maxTemp) { maxTemp = r.tempC; maxDate = r.date; }\n  }\n  return maxDate;\n}\n\nfunction windyDays(readings, threshold) {\n  const dates = new Set();\n  for (const r of readings) {\n    if (r.wind > threshold) dates.add(r.date);\n  }\n  return [...dates];\n}\n\nfunction dailySummary(readings) {\n  const groups = {};\n  for (const r of readings) {\n    if (!groups[r.date]) groups[r.date] = { temps: [], maxWind: 0 };\n    groups[r.date].temps.push(r.tempC);\n    groups[r.date].maxWind = Math.max(groups[r.date].maxWind, r.wind);\n  }\n  return Object.entries(groups)\n    .map(([date, d]) => ({\n      date,\n      avgTemp: Math.round((d.temps.reduce((a, b) => a + b, 0) / d.temps.length) * 10) / 10,\n      maxWind: d.maxWind,\n    }))\n    .sort((a, b) => a.date.localeCompare(b.date));\n}",
      "testRunner": "(code) => {\n  const fns = new Function(code + '; return { avgTempByStation, hottestDay, windyDays, dailySummary };')();\n  const { avgTempByStation, hottestDay, windyDays, dailySummary } = fns;\n\n  const data = [\n    { station: 'A', date: '2024-01-01', tempC: 5, humidity: 60, wind: 15 },\n    { station: 'B', date: '2024-01-01', tempC: -2, humidity: 80, wind: 25 },\n    { station: 'A', date: '2024-01-02', tempC: 8, humidity: 55, wind: 10 },\n    { station: 'B', date: '2024-01-02', tempC: 1, humidity: 70, wind: 30 },\n    { station: 'A', date: '2024-01-03', tempC: 12, humidity: 45, wind: 5 },\n    { station: 'B', date: '2024-01-03', tempC: 3, humidity: 65, wind: 20 },\n  ];\n\n  const avg = avgTempByStation(data);\n  const t1 = avg.A === 8.3 && avg.B === 0.7;\n\n  const t2 = hottestDay(data) === '2024-01-03';\n\n  const windy = windyDays(data, 20);\n  const t3 = windy.length === 2 && windy.includes('2024-01-01') && windy.includes('2024-01-02');\n\n  const summary = dailySummary(data);\n  const t4 = summary.length === 3 && summary[0].date === '2024-01-01' && summary[0].avgTemp === 1.5 && summary[1].maxWind === 30;\n\n  return [\n    { pass: t1, description: 'avgTempByStation: A=8.3, B=0.7', got: JSON.stringify(avg) },\n    { pass: t2, description: 'hottestDay: 2024-01-03 (12°C)', got: hottestDay(data) },\n    { pass: t3, description: 'windyDays(>20): Jan 1 and Jan 2', got: JSON.stringify(windy) },\n    { pass: t4, description: 'dailySummary: 3 days, sorted, correct avgTemp and maxWind', got: JSON.stringify(summary[0]) },\n  ];\n}",
      "hints": [
        "Group readings by station (or date) using an object as a lookup.",
        "For averages: sum values and divide by count, use Math.round(x * 10) / 10 for 1 decimal.",
        "Use Set to collect unique dates for windyDays."
      ],
      "resources": [
        {
          "label": "MDN: Array.reduce",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        }
      ]
    },
    {
      "id": 396,
      "title": "createRateLimiter",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "scope"
      ],
      "tags": [
        "closures",
        "async",
        "promises",
        "rate-limiting",
        "tier4"
      ],
      "description": "Build a rate limiter that queues function calls and executes them at a controlled rate.",
      "instructions": "Write a function:\n\n**createRateLimiter(maxCalls, windowMs)**\n- `maxCalls`: maximum number of calls allowed in the time window\n- `windowMs`: time window in milliseconds\n- Returns an async function `limiter(fn)` that:\n  - Executes `fn()` immediately if under the rate limit\n  - Queues and delays execution if the limit has been reached\n  - Returns the result of `fn()`\n  - Processes queued calls in order\n\n```js\nconst limiter = createRateLimiter(2, 100); // 2 calls per 100ms\n\n// These two execute immediately:\nconst r1 = await limiter(() => 'a');\nconst r2 = await limiter(() => 'b');\n\n// This one waits until the window resets:\nconst r3 = await limiter(() => 'c');\n```",
      "starterCode": "function createRateLimiter(maxCalls, windowMs) {\n  // your code here\n}",
      "solution": "function createRateLimiter(maxCalls, windowMs) {\n  const timestamps = [];\n  const queue = [];\n  let processing = false;\n\n  async function processQueue() {\n    if (processing) return;\n    processing = true;\n    while (queue.length > 0) {\n      const now = Date.now();\n      while (timestamps.length > 0 && timestamps[0] <= now - windowMs) {\n        timestamps.shift();\n      }\n      if (timestamps.length < maxCalls) {\n        const { fn, resolve, reject } = queue.shift();\n        timestamps.push(Date.now());\n        try {\n          resolve(fn());\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        const waitTime = timestamps[0] + windowMs - now;\n        await new Promise(r => setTimeout(r, waitTime));\n      }\n    }\n    processing = false;\n  }\n\n  return function(fn) {\n    return new Promise((resolve, reject) => {\n      queue.push({ fn, resolve, reject });\n      processQueue();\n    });\n  };\n}",
      "testRunner": "(code) => {\n  const createRateLimiter = new Function(code + '; return createRateLimiter;')();\n\n  const test1 = (async () => {\n    const limiter = createRateLimiter(3, 100);\n    const r = await limiter(() => 42);\n    return r === 42;\n  })();\n\n  const test2 = (async () => {\n    const limiter = createRateLimiter(2, 50);\n    const r1 = await limiter(() => 'a');\n    const r2 = await limiter(() => 'b');\n    return r1 === 'a' && r2 === 'b';\n  })();\n\n  const test3 = (async () => {\n    const limiter = createRateLimiter(1, 30);\n    const start = Date.now();\n    await limiter(() => 1);\n    await limiter(() => 2);\n    const elapsed = Date.now() - start;\n    return elapsed >= 25;\n  })();\n\n  const test4 = (async () => {\n    const limiter = createRateLimiter(5, 100);\n    const results = [];\n    for (let i = 0; i < 5; i++) {\n      results.push(await limiter(() => i));\n    }\n    return JSON.stringify(results) === '[0,1,2,3,4]';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Single call returns result', got: String(r1) },\n    { pass: r2, description: 'Multiple calls within limit execute immediately', got: String(r2) },\n    { pass: r3, description: 'Exceeding limit causes delay', got: String(r3) },\n    { pass: r4, description: 'All queued calls execute in order', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Track timestamps of recent calls. Remove timestamps older than the window.",
        "If under the limit, execute immediately. If at the limit, wait until the oldest call ages out.",
        "Use a queue array with { fn, resolve, reject } objects and process them in order."
      ],
      "resources": [
        {
          "label": "MDN: Date.now()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now"
        }
      ]
    },
    {
      "id": 397,
      "title": "Graph: Adjacency List",
      "type": "js",
      "tier": 4,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "graph",
        "data-structures",
        "algorithms",
        "tier4"
      ],
      "description": "Implement a graph using an adjacency list with add/remove vertices, edges, and traversal.",
      "instructions": "Build a class:\n\n**Graph**\n- `addVertex(vertex)` — adds a vertex (no duplicates)\n- `addEdge(v1, v2)` — adds an undirected edge between v1 and v2\n- `removeEdge(v1, v2)` — removes the edge between v1 and v2\n- `removeVertex(vertex)` — removes vertex and all its edges\n- `getNeighbors(vertex)` — returns array of adjacent vertices\n- `hasEdge(v1, v2)` — returns boolean\n- `bfs(start)` — breadth-first traversal, returns array of visited vertices in order\n- `get size` — number of vertices\n\n```js\nconst g = new Graph();\ng.addVertex('A');\ng.addVertex('B');\ng.addVertex('C');\ng.addEdge('A', 'B');\ng.addEdge('B', 'C');\ng.bfs('A'); // ['A', 'B', 'C']\n```",
      "starterCode": "class Graph {\n  constructor() {\n    // your code here\n  }\n\n  addVertex(vertex) {}\n  addEdge(v1, v2) {}\n  removeEdge(v1, v2) {}\n  removeVertex(vertex) {}\n  getNeighbors(vertex) {}\n  hasEdge(v1, v2) {}\n  bfs(start) {}\n  get size() {}\n}",
      "solution": "class Graph {\n  constructor() {\n    this.adjacencyList = {};\n  }\n\n  addVertex(vertex) {\n    if (!this.adjacencyList[vertex]) this.adjacencyList[vertex] = [];\n  }\n\n  addEdge(v1, v2) {\n    if (this.adjacencyList[v1] && this.adjacencyList[v2]) {\n      if (!this.adjacencyList[v1].includes(v2)) this.adjacencyList[v1].push(v2);\n      if (!this.adjacencyList[v2].includes(v1)) this.adjacencyList[v2].push(v1);\n    }\n  }\n\n  removeEdge(v1, v2) {\n    if (this.adjacencyList[v1]) this.adjacencyList[v1] = this.adjacencyList[v1].filter(v => v !== v2);\n    if (this.adjacencyList[v2]) this.adjacencyList[v2] = this.adjacencyList[v2].filter(v => v !== v1);\n  }\n\n  removeVertex(vertex) {\n    if (!this.adjacencyList[vertex]) return;\n    for (const neighbor of this.adjacencyList[vertex]) {\n      this.adjacencyList[neighbor] = this.adjacencyList[neighbor].filter(v => v !== vertex);\n    }\n    delete this.adjacencyList[vertex];\n  }\n\n  getNeighbors(vertex) {\n    return this.adjacencyList[vertex] || [];\n  }\n\n  hasEdge(v1, v2) {\n    return !!(this.adjacencyList[v1] && this.adjacencyList[v1].includes(v2));\n  }\n\n  bfs(start) {\n    if (!this.adjacencyList[start]) return [];\n    const visited = new Set();\n    const queue = [start];\n    const result = [];\n    visited.add(start);\n    while (queue.length > 0) {\n      const vertex = queue.shift();\n      result.push(vertex);\n      for (const neighbor of this.adjacencyList[vertex]) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          queue.push(neighbor);\n        }\n      }\n    }\n    return result;\n  }\n\n  get size() {\n    return Object.keys(this.adjacencyList).length;\n  }\n}",
      "testRunner": "(code) => {\n  const Graph = new Function(code + '; return Graph;')();\n  const g = new Graph();\n  g.addVertex('A'); g.addVertex('B'); g.addVertex('C'); g.addVertex('D');\n  g.addEdge('A', 'B'); g.addEdge('A', 'C'); g.addEdge('B', 'D'); g.addEdge('C', 'D');\n\n  const t1 = g.size === 4 && g.hasEdge('A', 'B') && g.hasEdge('B', 'A');\n\n  const bfs = g.bfs('A');\n  const t2 = bfs[0] === 'A' && bfs.length === 4;\n\n  g.removeEdge('C', 'D');\n  const t3 = !g.hasEdge('C', 'D') && !g.hasEdge('D', 'C');\n\n  g.removeVertex('D');\n  const t4 = g.size === 3 && !g.hasEdge('B', 'D');\n\n  return [\n    { pass: t1, description: 'Adds vertices and undirected edges', got: String(t1) },\n    { pass: t2, description: 'BFS traverses all connected vertices', got: JSON.stringify(bfs) },\n    { pass: t3, description: 'removeEdge removes from both directions', got: String(t3) },\n    { pass: t4, description: 'removeVertex cleans up all edges', got: String(t4) },\n  ];\n}",
      "hints": [
        "Use an object as the adjacency list: `{ vertex: [neighbor1, neighbor2, ...] }`.",
        "Edges are undirected — add to both vertices' neighbor lists.",
        "BFS uses a queue (array with shift) and a Set to track visited vertices."
      ],
      "resources": [
        {
          "label": "MDN: Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        }
      ]
    },
    {
      "id": 398,
      "title": "Proxy Validator",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "proxy",
        "validation",
        "es6",
        "tier4"
      ],
      "description": "Use JavaScript Proxy to create an object that validates property assignments with custom rules.",
      "instructions": "Write a function:\n\n**createValidatedObject(schema)**\n- `schema` is an object mapping property names to validator functions: `{ propName: (value) => boolean }`\n- Returns a Proxy-wrapped object that:\n  - On `set`: validates the value using the schema. If the validator returns `false`, throw a `TypeError` with message `'Invalid value for {propName}'`\n  - Properties not in the schema can be set freely\n  - On `get`: returns the value normally\n\n```js\nconst user = createValidatedObject({\n  age: (v) => typeof v === 'number' && v >= 0 && v <= 150,\n  name: (v) => typeof v === 'string' && v.length > 0,\n});\n\nuser.name = 'Alex';  // ok\nuser.age = 25;       // ok\nuser.age = -5;       // throws TypeError: 'Invalid value for age'\nuser.other = 'free'; // ok (not in schema)\n```",
      "starterCode": "function createValidatedObject(schema) {\n  // your code here\n}",
      "solution": "function createValidatedObject(schema) {\n  return new Proxy({}, {\n    set(target, prop, value) {\n      if (schema[prop] && !schema[prop](value)) {\n        throw new TypeError(`Invalid value for ${prop}`);\n      }\n      target[prop] = value;\n      return true;\n    },\n    get(target, prop) {\n      return target[prop];\n    }\n  });\n}",
      "testRunner": "(code) => {\n  const createValidatedObject = new Function(code + '; return createValidatedObject;')();\n\n  const obj = createValidatedObject({\n    age: (v) => typeof v === 'number' && v >= 0,\n    name: (v) => typeof v === 'string' && v.length > 0,\n  });\n\n  let t1 = false;\n  try { obj.name = 'Alex'; t1 = obj.name === 'Alex'; } catch (e) { t1 = false; }\n\n  let t2 = false;\n  try { obj.age = -5; t2 = false; } catch (e) { t2 = e instanceof TypeError && e.message === 'Invalid value for age'; }\n\n  let t3 = false;\n  try { obj.other = 42; t3 = obj.other === 42; } catch (e) { t3 = false; }\n\n  let t4 = false;\n  try { obj.name = ''; t4 = false; } catch (e) { t4 = e instanceof TypeError; }\n\n  return [\n    { pass: t1, description: 'Valid assignment works', got: String(t1) },\n    { pass: t2, description: 'Invalid value throws TypeError with message', got: String(t2) },\n    { pass: t3, description: 'Unvalidated properties set freely', got: String(t3) },\n    { pass: t4, description: 'Empty string fails string length validation', got: String(t4) },\n  ];\n}",
      "hints": [
        "Return `new Proxy({}, { set, get })` with custom trap handlers.",
        "In the set trap, check if `schema[prop]` exists and call the validator.",
        "Don't forget to `return true` from the set trap after successful assignment."
      ],
      "resources": [
        {
          "label": "MDN: Proxy",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
        }
      ]
    },
    {
      "id": 399,
      "title": "asyncReduce",
      "type": "js",
      "tier": 4,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "await",
        "promises",
        "higher-order",
        "tier4"
      ],
      "description": "Write an async version of Array.reduce that processes items sequentially with an async reducer.",
      "instructions": "Write a function:\n\n**asyncReduce(array, asyncReducer, initialValue)**\n- `array` is an array of values\n- `asyncReducer` is an async function `(accumulator, item, index) => Promise`\n- `initialValue` is the starting accumulator value\n- Processes items **sequentially** (not concurrently) — each step waits for the previous\n- Returns a Promise that resolves with the final accumulated value\n\n```js\nconst sum = await asyncReduce([1, 2, 3], async (acc, n) => {\n  await new Promise(r => setTimeout(r, 10));\n  return acc + n;\n}, 0);\n// sum === 6\n```",
      "starterCode": "async function asyncReduce(array, asyncReducer, initialValue) {\n  // your code here\n}",
      "solution": "async function asyncReduce(array, asyncReducer, initialValue) {\n  let accumulator = initialValue;\n  for (let i = 0; i < array.length; i++) {\n    accumulator = await asyncReducer(accumulator, array[i], i);\n  }\n  return accumulator;\n}",
      "testRunner": "(code) => {\n  const asyncReduce = new Function(code + '; return asyncReduce;')();\n\n  const test1 = (async () => {\n    const r = await asyncReduce([1, 2, 3], async (acc, n) => acc + n, 0);\n    return r === 6;\n  })();\n\n  const test2 = (async () => {\n    const r = await asyncReduce(['a', 'b', 'c'], async (acc, s) => acc + s, '');\n    return r === 'abc';\n  })();\n\n  const test3 = (async () => {\n    const r = await asyncReduce([], async (acc, n) => acc + n, 42);\n    return r === 42;\n  })();\n\n  const test4 = (async () => {\n    const order = [];\n    await asyncReduce([1, 2, 3], async (acc, n) => {\n      await new Promise(r => setTimeout(r, 5));\n      order.push(n);\n      return acc + n;\n    }, 0);\n    return JSON.stringify(order) === '[1,2,3]';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Sums numbers: 1+2+3 = 6', got: String(r1) },\n    { pass: r2, description: 'Concatenates strings', got: String(r2) },\n    { pass: r3, description: 'Empty array returns initialValue', got: String(r3) },\n    { pass: r4, description: 'Processes sequentially (not concurrently)', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Use a for loop with await — this ensures sequential execution.",
        "Start with `let acc = initialValue`, then `acc = await asyncReducer(acc, item, i)` each iteration.",
        "Unlike asyncMap, this MUST be sequential since each step depends on the previous result."
      ],
      "resources": [
        {
          "label": "MDN: Array.reduce",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        }
      ]
    },
    {
      "id": 400,
      "title": "Promise Pool: Concurrency Manager",
      "type": "js",
      "tier": 5,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "concurrency",
        "class",
        "tier5"
      ],
      "description": "Build a promise pool that manages concurrent async operations with queuing, events, and stats.",
      "instructions": "Build a class:\n\n**PromisePool(concurrency)**\n- `concurrency`: max number of tasks running at once\n\nMethods:\n- `add(taskFn)` — adds an async task function to the pool. Returns a Promise that resolves/rejects with the task's result. If under the concurrency limit, starts immediately. Otherwise, queues it.\n- `async drain()` — returns a Promise that resolves when all current and queued tasks finish\n- `get active` — number of currently running tasks\n- `get pending` — number of queued tasks waiting\n- `get completed` — total number of finished tasks (success + failure)\n- `get failed` — total number of failed tasks\n\n```js\nconst pool = new PromisePool(2);\n\npool.add(async () => { await delay(50); return 'a'; });\npool.add(async () => { await delay(30); return 'b'; });\npool.add(async () => { await delay(10); return 'c'; });\n\npool.active;    // 2 (first two running)\npool.pending;   // 1 (third queued)\n\nawait pool.drain();\npool.completed; // 3\npool.active;    // 0\n```",
      "starterCode": "class PromisePool {\n  constructor(concurrency) {\n    // your code here\n  }\n\n  add(taskFn) {}\n  async drain() {}\n  get active() {}\n  get pending() {}\n  get completed() {}\n  get failed() {}\n}",
      "solution": "class PromisePool {\n  constructor(concurrency) {\n    this._concurrency = concurrency;\n    this._active = 0;\n    this._completed = 0;\n    this._failed = 0;\n    this._queue = [];\n    this._drainResolvers = [];\n  }\n\n  add(taskFn) {\n    return new Promise((resolve, reject) => {\n      const task = { fn: taskFn, resolve, reject };\n      if (this._active < this._concurrency) {\n        this._run(task);\n      } else {\n        this._queue.push(task);\n      }\n    });\n  }\n\n  async _run(task) {\n    this._active++;\n    try {\n      const result = await task.fn();\n      this._completed++;\n      task.resolve(result);\n    } catch (err) {\n      this._completed++;\n      this._failed++;\n      task.reject(err);\n    } finally {\n      this._active--;\n      if (this._queue.length > 0) {\n        this._run(this._queue.shift());\n      } else if (this._active === 0) {\n        for (const resolver of this._drainResolvers) resolver();\n        this._drainResolvers = [];\n      }\n    }\n  }\n\n  async drain() {\n    if (this._active === 0 && this._queue.length === 0) return;\n    return new Promise(resolve => this._drainResolvers.push(resolve));\n  }\n\n  get active() { return this._active; }\n  get pending() { return this._queue.length; }\n  get completed() { return this._completed; }\n  get failed() { return this._failed; }\n}",
      "testRunner": "(code) => {\n  const PromisePool = new Function(code + '; return PromisePool;')();\n  const delay = ms => new Promise(r => setTimeout(r, ms));\n\n  const test1 = (async () => {\n    const pool = new PromisePool(2);\n    const r = await pool.add(async () => 42);\n    return r === 42 && pool.completed === 1;\n  })();\n\n  const test2 = (async () => {\n    const pool = new PromisePool(1);\n    let maxActive = 0;\n    const tasks = [10, 10, 10].map(ms => pool.add(async () => {\n      maxActive = Math.max(maxActive, pool.active);\n      await delay(ms);\n      return ms;\n    }));\n    await Promise.all(tasks);\n    return maxActive === 1 && pool.completed === 3;\n  })();\n\n  const test3 = (async () => {\n    const pool = new PromisePool(2);\n    pool.add(async () => delay(20));\n    pool.add(async () => delay(20));\n    pool.add(async () => delay(20));\n    await delay(0);\n    const a = pool.active;\n    const p = pool.pending;\n    await pool.drain();\n    return a === 2 && p === 1 && pool.active === 0;\n  })();\n\n  const test4 = (async () => {\n    const pool = new PromisePool(2);\n    pool.add(async () => { throw new Error('x'); }).catch(() => {});\n    pool.add(async () => 'ok');\n    await pool.drain();\n    return pool.failed === 1 && pool.completed === 2;\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Single task resolves with result', got: String(r1) },\n    { pass: r2, description: 'Respects concurrency limit of 1', got: String(r2) },\n    { pass: r3, description: 'Tracks active/pending counts, drain() waits', got: String(r3) },\n    { pass: r4, description: 'Tracks failed tasks separately', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Each added task wraps in a Promise. Store { fn, resolve, reject } in a queue.",
        "When a task finishes, check the queue for the next one.",
        "drain() returns a promise that resolves when active === 0 and queue is empty."
      ],
      "resources": [
        {
          "label": "MDN: Promise",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
        }
      ]
    },
    {
      "id": 401,
      "title": "Async State Machine: Order + Payment + Shipping",
      "type": "js",
      "tier": 5,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "async",
        "state-machine",
        "error-handling",
        "tier5",
        "multi-class"
      ],
      "description": "Build an async order processing system with state transitions, validation, and error recovery.",
      "instructions": "Build three classes that model an async order system.\n\n**Order(id, items)**\n- Properties: `id`, `items` (array of { name, price }), `status` (starts `'created'`)\n- `get total` — sum of all item prices\n- Valid status transitions: created→paid→shipped→delivered\n- `async transition(newStatus)` — changes status if valid, throws Error if invalid transition\n\n**Payment(order)**\n- `async process()` — simulates payment: if order.total > 0 and order.status is 'created', transitions order to 'paid' and returns `{ success: true, orderId }`. Otherwise throws.\n- `async refund()` — only if order.status is 'paid', transitions back to 'created', returns `{ refunded: true }`\n\n**ShippingManager()**\n- `async ship(order)` — if order.status is 'paid', transitions to 'shipped', returns `{ shipped: true, trackingId: 'TRK-{order.id}' }`. Otherwise throws.\n- `async deliver(order)` — if 'shipped', transitions to 'delivered'. Otherwise throws.\n- `get history` — array of `{ orderId, action, timestamp }` for all operations\n\n```js\nconst order = new Order('001', [{ name: 'Book', price: 15 }]);\nconst payment = new Payment(order);\nawait payment.process();   // order.status → 'paid'\n\nconst shipping = new ShippingManager();\nawait shipping.ship(order);    // order.status → 'shipped'\nawait shipping.deliver(order); // order.status → 'delivered'\n```",
      "starterCode": "class Order {\n  constructor(id, items) {\n    // your code here\n  }\n  get total() {}\n  async transition(newStatus) {}\n}\n\nclass Payment {\n  constructor(order) {\n    // your code here\n  }\n  async process() {}\n  async refund() {}\n}\n\nclass ShippingManager {\n  constructor() {\n    // your code here\n  }\n  async ship(order) {}\n  async deliver(order) {}\n  get history() {}\n}",
      "solution": "class Order {\n  constructor(id, items) {\n    this.id = id;\n    this.items = items;\n    this.status = 'created';\n  }\n  get total() {\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n  async transition(newStatus) {\n    const valid = { created: 'paid', paid: 'shipped', shipped: 'delivered' };\n    if (valid[this.status] !== newStatus && !(this.status === 'paid' && newStatus === 'created')) {\n      throw new Error(`Invalid transition: ${this.status} → ${newStatus}`);\n    }\n    this.status = newStatus;\n  }\n}\n\nclass Payment {\n  constructor(order) {\n    this.order = order;\n  }\n  async process() {\n    if (this.order.total <= 0) throw new Error('Invalid total');\n    if (this.order.status !== 'created') throw new Error('Order not in created state');\n    await this.order.transition('paid');\n    return { success: true, orderId: this.order.id };\n  }\n  async refund() {\n    if (this.order.status !== 'paid') throw new Error('Order not in paid state');\n    await this.order.transition('created');\n    return { refunded: true };\n  }\n}\n\nclass ShippingManager {\n  constructor() {\n    this._history = [];\n  }\n  async ship(order) {\n    if (order.status !== 'paid') throw new Error('Order not paid');\n    await order.transition('shipped');\n    this._history.push({ orderId: order.id, action: 'ship', timestamp: Date.now() });\n    return { shipped: true, trackingId: `TRK-${order.id}` };\n  }\n  async deliver(order) {\n    if (order.status !== 'shipped') throw new Error('Order not shipped');\n    await order.transition('delivered');\n    this._history.push({ orderId: order.id, action: 'deliver', timestamp: Date.now() });\n    return { delivered: true };\n  }\n  get history() { return this._history; }\n}",
      "testRunner": "(code) => {\n  const classes = new Function(code + '; return { Order, Payment, ShippingManager };')();\n  const { Order, Payment, ShippingManager } = classes;\n\n  const test1 = (async () => {\n    const o = new Order('1', [{ name: 'A', price: 10 }, { name: 'B', price: 20 }]);\n    return o.total === 30 && o.status === 'created';\n  })();\n\n  const test2 = (async () => {\n    const o = new Order('2', [{ name: 'X', price: 50 }]);\n    const p = new Payment(o);\n    const r = await p.process();\n    return r.success && o.status === 'paid' && r.orderId === '2';\n  })();\n\n  const test3 = (async () => {\n    const o = new Order('3', [{ name: 'Y', price: 25 }]);\n    const p = new Payment(o);\n    await p.process();\n    const sm = new ShippingManager();\n    const sr = await sm.ship(o);\n    await sm.deliver(o);\n    return o.status === 'delivered' && sr.trackingId === 'TRK-3' && sm.history.length === 2;\n  })();\n\n  const test4 = (async () => {\n    const o = new Order('4', [{ name: 'Z', price: 10 }]);\n    const sm = new ShippingManager();\n    try { await sm.ship(o); return false; } catch (e) { return e.message.length > 0; }\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Order tracks items, total, and initial status', got: String(r1) },\n    { pass: r2, description: 'Payment.process() transitions to paid', got: String(r2) },\n    { pass: r3, description: 'Full flow: created → paid → shipped → delivered', got: String(r3) },\n    { pass: r4, description: 'Invalid transition throws error', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Order.transition() uses a valid transitions map to check if the new status is allowed.",
        "Payment and ShippingManager check order.status before attempting transitions.",
        "ShippingManager stores history entries with orderId, action, and timestamp."
      ],
      "resources": [
        {
          "label": "MDN: Classes",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"
        }
      ]
    },
    {
      "id": 402,
      "title": "Async Iterator: Paginated API",
      "type": "js",
      "tier": 5,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "iterator",
        "generator",
        "promises",
        "tier5"
      ],
      "description": "Build an async iterator that lazily fetches paginated data one page at a time using for-await-of.",
      "instructions": "Write a function:\n\n**createPaginatedFetcher(fetchPage)**\n- `fetchPage(page)` is an async function that returns `{ data: [...], hasMore: boolean }`\n- Returns an async iterable (works with `for await...of`)\n- Each iteration yields individual items from the current page\n- Automatically fetches the next page when the current one is exhausted\n- Stops when `hasMore` is `false`\n\nImplement using `Symbol.asyncIterator` or an async generator.\n\n```js\nconst fetcher = createPaginatedFetcher(async (page) => {\n  const items = page <= 3 ? [page * 10 + 1, page * 10 + 2] : [];\n  return { data: items, hasMore: page < 3 };\n});\n\nconst all = [];\nfor await (const item of fetcher) {\n  all.push(item);\n}\n// all === [11, 12, 21, 22, 31, 32]\n```",
      "starterCode": "function createPaginatedFetcher(fetchPage) {\n  // your code here\n}",
      "solution": "function createPaginatedFetcher(fetchPage) {\n  return {\n    async *[Symbol.asyncIterator]() {\n      let page = 1;\n      let hasMore = true;\n      while (hasMore) {\n        const result = await fetchPage(page);\n        for (const item of result.data) {\n          yield item;\n        }\n        hasMore = result.hasMore;\n        page++;\n      }\n    }\n  };\n}",
      "testRunner": "(code) => {\n  const createPaginatedFetcher = new Function(code + '; return createPaginatedFetcher;')();\n\n  const test1 = (async () => {\n    const fetcher = createPaginatedFetcher(async (page) => ({\n      data: [page],\n      hasMore: page < 3\n    }));\n    const items = [];\n    for await (const item of fetcher) items.push(item);\n    return JSON.stringify(items) === '[1,2,3]';\n  })();\n\n  const test2 = (async () => {\n    const fetcher = createPaginatedFetcher(async (page) => ({\n      data: [],\n      hasMore: false\n    }));\n    const items = [];\n    for await (const item of fetcher) items.push(item);\n    return items.length === 0;\n  })();\n\n  const test3 = (async () => {\n    let fetchCount = 0;\n    const fetcher = createPaginatedFetcher(async (page) => {\n      fetchCount++;\n      return { data: [page * 10, page * 10 + 1], hasMore: page < 2 };\n    });\n    const items = [];\n    for await (const item of fetcher) items.push(item);\n    return items.length === 4 && fetchCount === 2;\n  })();\n\n  const test4 = (async () => {\n    const fetcher = createPaginatedFetcher(async (page) => ({\n      data: ['a', 'b'],\n      hasMore: page < 3\n    }));\n    const items = [];\n    for await (const item of fetcher) items.push(item);\n    return items.length === 6 && items[0] === 'a';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Iterates through 3 single-item pages', got: String(r1) },\n    { pass: r2, description: 'Empty first page yields nothing', got: String(r2) },\n    { pass: r3, description: 'Fetches only needed pages lazily', got: String(r3) },\n    { pass: r4, description: 'Multi-item pages across 3 fetches', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Return an object with [Symbol.asyncIterator] method that returns an async generator.",
        "Use `async *[Symbol.asyncIterator]()` syntax for an async generator.",
        "Use a while loop: fetch a page, yield* the data, check hasMore, increment page."
      ],
      "resources": [
        {
          "label": "MDN: Async iteration",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of"
        }
      ]
    },
    {
      "id": 403,
      "title": "Error Recovery Pipeline",
      "type": "js",
      "tier": 5,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "error-handling",
        "try-catch",
        "promises",
        "tier5",
        "composition"
      ],
      "description": "Build a pipeline that processes data through async steps with per-step error recovery and fallbacks.",
      "instructions": "Write a function:\n\n**createPipeline()**\nReturns a pipeline builder with:\n- `step(name, processFn, options)` — adds a processing step\n  - `name`: string identifier\n  - `processFn`: `async (data) => result`\n  - `options.fallback`: optional `async (error, data) => result` called if processFn throws\n  - `options.required`: boolean (default true). If true and both processFn and fallback fail, pipeline stops\n- `async execute(initialData)` — runs all steps in order, passing each result to the next\n  - Returns `{ result, steps }` where steps is array of `{ name, status: 'success'|'recovered'|'skipped'|'failed', duration }`\n  - If a required step fails, return partial result and mark remaining steps as 'skipped'\n\n```js\nconst pipeline = createPipeline();\npipeline.step('validate', async (d) => ({ ...d, valid: true }));\npipeline.step('enrich', async (d) => { throw new Error('API down'); },\n  { fallback: async (err, d) => ({ ...d, enriched: false }) });\npipeline.step('save', async (d) => ({ ...d, saved: true }));\n\nconst { result, steps } = await pipeline.execute({ id: 1 });\n// result: { id: 1, valid: true, enriched: false, saved: true }\n// steps[1].status === 'recovered'\n```",
      "starterCode": "function createPipeline() {\n  // your code here\n}",
      "solution": "function createPipeline() {\n  const steps = [];\n\n  return {\n    step(name, processFn, options = {}) {\n      steps.push({\n        name,\n        processFn,\n        fallback: options.fallback || null,\n        required: options.required !== false,\n      });\n      return this;\n    },\n    async execute(initialData) {\n      let data = initialData;\n      const report = [];\n      let stopped = false;\n\n      for (const step of steps) {\n        if (stopped) {\n          report.push({ name: step.name, status: 'skipped', duration: 0 });\n          continue;\n        }\n        const start = Date.now();\n        try {\n          data = await step.processFn(data);\n          report.push({ name: step.name, status: 'success', duration: Date.now() - start });\n        } catch (err) {\n          if (step.fallback) {\n            try {\n              data = await step.fallback(err, data);\n              report.push({ name: step.name, status: 'recovered', duration: Date.now() - start });\n            } catch (fallbackErr) {\n              report.push({ name: step.name, status: 'failed', duration: Date.now() - start });\n              if (step.required) stopped = true;\n            }\n          } else {\n            report.push({ name: step.name, status: 'failed', duration: Date.now() - start });\n            if (step.required) stopped = true;\n          }\n        }\n      }\n\n      return { result: data, steps: report };\n    }\n  };\n}",
      "testRunner": "(code) => {\n  const createPipeline = new Function(code + '; return createPipeline;')();\n\n  const test1 = (async () => {\n    const p = createPipeline();\n    p.step('a', async d => d + 1);\n    p.step('b', async d => d * 2);\n    const { result, steps } = await p.execute(5);\n    return result === 12 && steps.length === 2 && steps[0].status === 'success';\n  })();\n\n  const test2 = (async () => {\n    const p = createPipeline();\n    p.step('fail', async d => { throw new Error('x'); }, { fallback: async (e, d) => d + 10 });\n    const { result, steps } = await p.execute(5);\n    return result === 15 && steps[0].status === 'recovered';\n  })();\n\n  const test3 = (async () => {\n    const p = createPipeline();\n    p.step('a', async d => d + 1);\n    p.step('boom', async d => { throw new Error('x'); });\n    p.step('c', async d => d + 100);\n    const { result, steps } = await p.execute(0);\n    return result === 1 && steps[1].status === 'failed' && steps[2].status === 'skipped';\n  })();\n\n  const test4 = (async () => {\n    const p = createPipeline();\n    p.step('opt', async d => { throw new Error('x'); }, { required: false });\n    p.step('next', async d => d + 1);\n    const { result, steps } = await p.execute(0);\n    return result === 1 && steps[0].status === 'failed' && steps[1].status === 'success';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Two successful steps chain data', got: String(r1) },\n    { pass: r2, description: 'Fallback recovers from error', got: String(r2) },\n    { pass: r3, description: 'Required failure skips remaining steps', got: String(r3) },\n    { pass: r4, description: 'Non-required failure allows continuation', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Store steps as an array of { name, processFn, fallback, required } objects.",
        "In execute(), loop through steps. Try processFn, then fallback on failure.",
        "Track a 'stopped' flag — when a required step fails, set it to true and mark remaining as 'skipped'."
      ],
      "resources": [
        {
          "label": "MDN: try...catch",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"
        }
      ]
    },
    {
      "id": 404,
      "title": "Circuit Breaker Pattern",
      "type": "js",
      "tier": 5,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "error-handling",
        "design-pattern",
        "class",
        "tier5"
      ],
      "description": "Implement the circuit breaker pattern — automatically stop calling a failing service and recover after a cooldown.",
      "instructions": "Build a class:\n\n**CircuitBreaker(options)**\n- `options`: `{ failureThreshold, cooldownMs, successThreshold }`\n  - `failureThreshold` (default 3): consecutive failures to open the circuit\n  - `cooldownMs` (default 5000): time to wait before trying again\n  - `successThreshold` (default 1): consecutive successes needed to fully close\n\nStates: `'closed'` (normal), `'open'` (rejecting), `'half-open'` (testing)\n\n- `async call(fn)` — executes fn based on state:\n  - **closed**: Call fn. On success, reset failure count. On failure, increment. If failures >= threshold, open circuit.\n  - **open**: Throw `Error('Circuit is open')` without calling fn. After cooldownMs, transition to half-open.\n  - **half-open**: Call fn. On success, close circuit. On failure, reopen.\n- `get state` — current state string\n- `get stats` — `{ failures, successes, state }`\n- `reset()` — force-close the circuit\n\n```js\nconst cb = new CircuitBreaker({ failureThreshold: 2, cooldownMs: 100 });\nawait cb.call(async () => { throw new Error('fail'); }).catch(()=>{});\nawait cb.call(async () => { throw new Error('fail'); }).catch(()=>{});\ncb.state; // 'open'\nawait cb.call(async () => 'ok'); // throws 'Circuit is open'\n```",
      "starterCode": "class CircuitBreaker {\n  constructor(options = {}) {\n    // your code here\n  }\n\n  async call(fn) {}\n  get state() {}\n  get stats() {}\n  reset() {}\n}",
      "solution": "class CircuitBreaker {\n  constructor(options = {}) {\n    this._failureThreshold = options.failureThreshold ?? 3;\n    this._cooldownMs = options.cooldownMs ?? 5000;\n    this._successThreshold = options.successThreshold ?? 1;\n    this._state = 'closed';\n    this._failures = 0;\n    this._successes = 0;\n    this._openedAt = null;\n  }\n\n  async call(fn) {\n    if (this._state === 'open') {\n      if (Date.now() - this._openedAt >= this._cooldownMs) {\n        this._state = 'half-open';\n      } else {\n        throw new Error('Circuit is open');\n      }\n    }\n\n    try {\n      const result = await fn();\n      this._successes++;\n      if (this._state === 'half-open') {\n        if (this._successes >= this._successThreshold) {\n          this._state = 'closed';\n          this._failures = 0;\n        }\n      } else {\n        this._failures = 0;\n      }\n      return result;\n    } catch (err) {\n      this._failures++;\n      this._successes = 0;\n      if (this._failures >= this._failureThreshold || this._state === 'half-open') {\n        this._state = 'open';\n        this._openedAt = Date.now();\n      }\n      throw err;\n    }\n  }\n\n  get state() { return this._state; }\n  get stats() { return { failures: this._failures, successes: this._successes, state: this._state }; }\n  reset() { this._state = 'closed'; this._failures = 0; this._successes = 0; this._openedAt = null; }\n}",
      "testRunner": "(code) => {\n  const CircuitBreaker = new Function(code + '; return CircuitBreaker;')();\n\n  const test1 = (async () => {\n    const cb = new CircuitBreaker({ failureThreshold: 2, cooldownMs: 50 });\n    const r = await cb.call(async () => 'ok');\n    return r === 'ok' && cb.state === 'closed';\n  })();\n\n  const test2 = (async () => {\n    const cb = new CircuitBreaker({ failureThreshold: 2, cooldownMs: 50 });\n    try { await cb.call(async () => { throw new Error('f1'); }); } catch (e) {}\n    try { await cb.call(async () => { throw new Error('f2'); }); } catch (e) {}\n    return cb.state === 'open';\n  })();\n\n  const test3 = (async () => {\n    const cb = new CircuitBreaker({ failureThreshold: 2, cooldownMs: 50 });\n    try { await cb.call(async () => { throw new Error('x'); }); } catch (e) {}\n    try { await cb.call(async () => { throw new Error('x'); }); } catch (e) {}\n    try {\n      await cb.call(async () => 'should not run');\n      return false;\n    } catch (e) {\n      return e.message === 'Circuit is open';\n    }\n  })();\n\n  const test4 = (async () => {\n    const cb = new CircuitBreaker({ failureThreshold: 1, cooldownMs: 20 });\n    try { await cb.call(async () => { throw new Error('x'); }); } catch (e) {}\n    await new Promise(r => setTimeout(r, 30));\n    const r = await cb.call(async () => 'recovered');\n    return r === 'recovered' && cb.state === 'closed';\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'Successful call returns result, stays closed', got: String(r1) },\n    { pass: r2, description: 'Opens after reaching failure threshold', got: String(r2) },\n    { pass: r3, description: 'Open circuit rejects without calling fn', got: String(r3) },\n    { pass: r4, description: 'Recovers after cooldown (half-open → closed)', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Track _state, _failures, _successes, and _openedAt timestamp.",
        "In open state, check if cooldown has elapsed. If so, switch to half-open.",
        "In half-open state, a success closes the circuit; a failure reopens it."
      ],
      "resources": [
        {
          "label": "MDN: Classes",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"
        }
      ]
    },
    {
      "id": 405,
      "title": "Observable Stream: Observer + Subject + Operators",
      "type": "js",
      "tier": 5,
      "category": [
        "js-fundamentals",
        "classes"
      ],
      "tags": [
        "class",
        "oop",
        "tier5",
        "composition",
        "multi-class",
        "events",
        "streams"
      ],
      "description": "Build a reactive observable stream system with map, filter, and subscribe operators.",
      "instructions": "Build three classes:\n\n**Observable(subscribeFn)**\n- `subscribeFn` receives an observer `{ next, error, complete }` and may return an unsubscribe function\n- `subscribe(observer)` — starts the stream, returns `{ unsubscribe }` object\n- `map(fn)` — returns a new Observable that transforms each value\n- `filter(fn)` — returns a new Observable that only passes values where fn returns true\n\n**Subject**\n- Extends or wraps Observable\n- `next(value)` — pushes a value to all subscribers\n- `error(err)` — sends error to all subscribers\n- `complete()` — completes all subscribers\n- `subscribe(observer)` — adds a subscriber\n\n**Operators (static methods on Observable):**\n- `Observable.fromArray(arr)` — creates Observable that emits each item then completes\n- `Observable.interval(ms)` — creates Observable that emits incrementing numbers every `ms` ms\n\n```js\nconst values = [];\nconst obs = Observable.fromArray([1, 2, 3, 4]);\nobs.filter(x => x % 2 === 0)\n   .map(x => x * 10)\n   .subscribe({ next: v => values.push(v) });\n// values === [20, 40]\n```",
      "starterCode": "class Observable {\n  constructor(subscribeFn) {\n    // your code here\n  }\n  subscribe(observer) {}\n  map(fn) {}\n  filter(fn) {}\n  static fromArray(arr) {}\n  static interval(ms) {}\n}\n\nclass Subject {\n  constructor() {\n    // your code here\n  }\n  next(value) {}\n  error(err) {}\n  complete() {}\n  subscribe(observer) {}\n}",
      "solution": "class Observable {\n  constructor(subscribeFn) {\n    this._subscribeFn = subscribeFn;\n  }\n\n  subscribe(observer) {\n    const cleanup = this._subscribeFn(observer);\n    return { unsubscribe: cleanup || (() => {}) };\n  }\n\n  map(fn) {\n    return new Observable((observer) => {\n      const sub = this.subscribe({\n        next: (val) => observer.next(fn(val)),\n        error: (err) => observer.error && observer.error(err),\n        complete: () => observer.complete && observer.complete(),\n      });\n      return () => sub.unsubscribe();\n    });\n  }\n\n  filter(fn) {\n    return new Observable((observer) => {\n      const sub = this.subscribe({\n        next: (val) => { if (fn(val)) observer.next(val); },\n        error: (err) => observer.error && observer.error(err),\n        complete: () => observer.complete && observer.complete(),\n      });\n      return () => sub.unsubscribe();\n    });\n  }\n\n  static fromArray(arr) {\n    return new Observable((observer) => {\n      for (const item of arr) observer.next(item);\n      if (observer.complete) observer.complete();\n    });\n  }\n\n  static interval(ms) {\n    return new Observable((observer) => {\n      let count = 0;\n      const id = setInterval(() => observer.next(count++), ms);\n      return () => clearInterval(id);\n    });\n  }\n}\n\nclass Subject {\n  constructor() {\n    this._observers = [];\n    this._completed = false;\n  }\n\n  next(value) {\n    if (this._completed) return;\n    for (const obs of this._observers) obs.next(value);\n  }\n\n  error(err) {\n    for (const obs of this._observers) obs.error && obs.error(err);\n  }\n\n  complete() {\n    this._completed = true;\n    for (const obs of this._observers) obs.complete && obs.complete();\n  }\n\n  subscribe(observer) {\n    this._observers.push(observer);\n    return { unsubscribe: () => {\n      this._observers = this._observers.filter(o => o !== observer);\n    }};\n  }\n}",
      "testRunner": "(code) => {\n  const classes = new Function(code + '; return { Observable, Subject };')();\n  const { Observable, Subject } = classes;\n\n  const test1 = (() => {\n    const vals = [];\n    Observable.fromArray([1,2,3]).subscribe({ next: v => vals.push(v) });\n    return JSON.stringify(vals) === '[1,2,3]';\n  })();\n\n  const test2 = (() => {\n    const vals = [];\n    Observable.fromArray([1,2,3,4])\n      .filter(x => x > 2)\n      .map(x => x * 10)\n      .subscribe({ next: v => vals.push(v) });\n    return JSON.stringify(vals) === '[30,40]';\n  })();\n\n  const test3 = (() => {\n    const subj = new Subject();\n    const vals = [];\n    subj.subscribe({ next: v => vals.push(v) });\n    subj.next(1); subj.next(2); subj.next(3);\n    return JSON.stringify(vals) === '[1,2,3]';\n  })();\n\n  const test4 = (async () => {\n    const vals = [];\n    const sub = Observable.interval(10).subscribe({ next: v => vals.push(v) });\n    await new Promise(r => setTimeout(r, 35));\n    sub.unsubscribe();\n    return vals.length >= 2 && vals[0] === 0 && vals[1] === 1;\n  })();\n\n  return Promise.resolve(test4).then(r4 => [\n    { pass: test1, description: 'fromArray emits all items', got: String(test1) },\n    { pass: test2, description: 'filter + map chain works', got: String(test2) },\n    { pass: test3, description: 'Subject multicasts to subscribers', got: String(test3) },\n    { pass: r4, description: 'interval emits incrementing values, unsubscribe stops', got: String(r4) },\n  ]);\n}",
      "hints": [
        "Observable stores a subscribeFn. subscribe() calls it with the observer.",
        "map() and filter() return NEW Observables that subscribe to the parent and transform values.",
        "Subject maintains an array of observers and pushes values to all of them."
      ],
      "resources": [
        {
          "label": "MDN: Symbol.iterator",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator"
        }
      ]
    },
    {
      "id": 406,
      "title": "Async Resource Manager: Pool + Lock + Timeout",
      "type": "js",
      "tier": 5,
      "category": [
        "es6-plus",
        "async"
      ],
      "tags": [
        "async",
        "promises",
        "class",
        "tier5",
        "composition",
        "multi-class",
        "resource-management"
      ],
      "description": "Build an async resource pool with acquire/release, locking, and timeout support.",
      "instructions": "Build two classes:\n\n**AsyncLock**\n- `async acquire()` — acquires the lock. If already locked, waits in queue.\n- `release()` — releases the lock, allowing the next waiting acquirer to proceed\n- `get locked` — boolean, whether currently locked\n\n**ResourcePool(factory, size)**\n- `factory` is a function that creates a new resource\n- `size` is the pool size (creates that many resources upfront)\n- `async acquire(timeoutMs)` — gets a free resource. If none available, waits. If timeoutMs provided and exceeded, throws `Error('Acquire timeout')`.\n- `release(resource)` — returns a resource to the pool\n- `get available` — number of free resources\n- `get inUse` — number of checked-out resources\n\n```js\nconst pool = new ResourcePool(() => ({ id: Math.random() }), 2);\n\nconst r1 = await pool.acquire();\nconst r2 = await pool.acquire();\npool.available; // 0\npool.inUse;     // 2\n\npool.release(r1);\npool.available; // 1\n```",
      "starterCode": "class AsyncLock {\n  constructor() {\n    // your code here\n  }\n  async acquire() {}\n  release() {}\n  get locked() {}\n}\n\nclass ResourcePool {\n  constructor(factory, size) {\n    // your code here\n  }\n  async acquire(timeoutMs) {}\n  release(resource) {}\n  get available() {}\n  get inUse() {}\n}",
      "solution": "class AsyncLock {\n  constructor() {\n    this._locked = false;\n    this._queue = [];\n  }\n  async acquire() {\n    if (!this._locked) {\n      this._locked = true;\n      return;\n    }\n    return new Promise(resolve => this._queue.push(resolve));\n  }\n  release() {\n    if (this._queue.length > 0) {\n      const next = this._queue.shift();\n      next();\n    } else {\n      this._locked = false;\n    }\n  }\n  get locked() { return this._locked; }\n}\n\nclass ResourcePool {\n  constructor(factory, size) {\n    this._resources = Array.from({ length: size }, () => factory());\n    this._inUse = new Set();\n    this._queue = [];\n  }\n  async acquire(timeoutMs) {\n    if (this._resources.length > 0) {\n      const resource = this._resources.pop();\n      this._inUse.add(resource);\n      return resource;\n    }\n    return new Promise((resolve, reject) => {\n      const entry = { resolve, reject, timer: null };\n      if (timeoutMs !== undefined) {\n        entry.timer = setTimeout(() => {\n          this._queue = this._queue.filter(e => e !== entry);\n          reject(new Error('Acquire timeout'));\n        }, timeoutMs);\n      }\n      this._queue.push(entry);\n    });\n  }\n  release(resource) {\n    if (!this._inUse.has(resource)) return;\n    this._inUse.delete(resource);\n    if (this._queue.length > 0) {\n      const entry = this._queue.shift();\n      if (entry.timer) clearTimeout(entry.timer);\n      this._inUse.add(resource);\n      entry.resolve(resource);\n    } else {\n      this._resources.push(resource);\n    }\n  }\n  get available() { return this._resources.length; }\n  get inUse() { return this._inUse.size; }\n}",
      "testRunner": "(code) => {\n  const classes = new Function(code + '; return { AsyncLock, ResourcePool };')();\n  const { AsyncLock, ResourcePool } = classes;\n\n  const test1 = (async () => {\n    const lock = new AsyncLock();\n    await lock.acquire();\n    const locked = lock.locked;\n    lock.release();\n    return locked === true && lock.locked === false;\n  })();\n\n  const test2 = (async () => {\n    const pool = new ResourcePool(() => ({ v: Math.random() }), 2);\n    const r1 = await pool.acquire();\n    const r2 = await pool.acquire();\n    return pool.available === 0 && pool.inUse === 2 && r1 !== r2;\n  })();\n\n  const test3 = (async () => {\n    const pool = new ResourcePool(() => ({}), 1);\n    const r1 = await pool.acquire();\n    const p = pool.acquire(50);\n    pool.release(r1);\n    const r2 = await p;\n    return r2 === r1;\n  })();\n\n  const test4 = (async () => {\n    const pool = new ResourcePool(() => ({}), 1);\n    await pool.acquire();\n    try {\n      await pool.acquire(20);\n      return false;\n    } catch (e) {\n      return e.message === 'Acquire timeout';\n    }\n  })();\n\n  return Promise.all([test1, test2, test3, test4]).then(([r1, r2, r3, r4]) => [\n    { pass: r1, description: 'AsyncLock acquires and releases', got: String(r1) },\n    { pass: r2, description: 'Pool manages multiple resources', got: String(r2) },\n    { pass: r3, description: 'Queued acquire gets resource when released', got: String(r3) },\n    { pass: r4, description: 'Timeout throws when no resource available', got: String(r4) },\n  ]);\n}",
      "hints": [
        "AsyncLock uses a queue of resolve callbacks. If locked, push a new Promise's resolve.",
        "ResourcePool maintains a free list (array) and in-use set. acquire() pops from free or queues.",
        "For timeout: use setTimeout to reject the queued promise if it hasn't been resolved."
      ],
      "resources": [
        {
          "label": "MDN: Promise",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
        }
      ]
    },
    {
      "id": 620,
      "title": "Temperature Converter",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "variables",
        "math",
        "arithmetic",
        "beginner"
      ],
      "description": "Convert a temperature from Fahrenheit to Celsius.",
      "instructions": "Write a function called `toCelsius` that takes a temperature in Fahrenheit and returns it converted to Celsius, rounded to one decimal place.\n\nThe formula is: C = (F - 32) × 5/9\n\nExample:\n  toCelsius(32)   →  0\n  toCelsius(212)  →  100\n  toCelsius(98.6) →  37",
      "starterCode": "function toCelsius(fahrenheit) {\n  // Apply the conversion formula\n  // Round to one decimal place\n\n}",
      "solution": "function toCelsius(fahrenheit) {\n  return Math.round((fahrenheit - 32) * 5 / 9 * 10) / 10;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return toCelsius;')(); return [ { pass: fn(32) === 0, description: 'toCelsius(32) → 0', got: fn(32) }, { pass: fn(212) === 100, description: 'toCelsius(212) → 100', got: fn(212) }, { pass: fn(98.6) === 37, description: 'toCelsius(98.6) → 37', got: fn(98.6) }, { pass: fn(-40) === -40, description: 'toCelsius(-40) → -40', got: fn(-40) } ]; }",
      "hints": [
        "Subtract 32 from the Fahrenheit value first, then multiply by 5/9.",
        "To round to one decimal, multiply by 10, use Math.round(), then divide by 10.",
        "Return `Math.round((fahrenheit - 32) * 5 / 9 * 10) / 10`."
      ],
      "resources": [
        {
          "label": "MDN: Math.round()",
          "url": "/docs/mdn/math-round.html",
          "description": "Rounding numbers to the nearest integer"
        },
        {
          "label": "MDN: Arithmetic operators",
          "url": "/docs/mdn/arithmetic.html",
          "description": "Using +, -, *, / in expressions"
        }
      ]
    },
    {
      "id": 621,
      "title": "Coin Counter",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "variables",
        "math",
        "arithmetic",
        "beginner"
      ],
      "description": "Calculate the dollar value of a pile of coins.",
      "instructions": "Write a function called `coinValue` that takes four parameters — the number of quarters, dimes, nickels, and pennies — and returns the total value in dollars as a number.\n\nExample:\n  coinValue(4, 3, 2, 1)  →  1.41\n  coinValue(0, 0, 0, 0)  →  0\n  coinValue(1, 0, 0, 0)  →  0.25",
      "starterCode": "function coinValue(quarters, dimes, nickels, pennies) {\n  // Calculate total cents, then convert to dollars\n\n}",
      "solution": "function coinValue(quarters, dimes, nickels, pennies) {\n  const cents = quarters * 25 + dimes * 10 + nickels * 5 + pennies;\n  return cents / 100;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return coinValue;')(); return [ { pass: fn(4, 3, 2, 1) === 1.41, description: 'coinValue(4,3,2,1) → 1.41', got: fn(4, 3, 2, 1) }, { pass: fn(0, 0, 0, 0) === 0, description: 'coinValue(0,0,0,0) → 0', got: fn(0, 0, 0, 0) }, { pass: fn(1, 0, 0, 0) === 0.25, description: 'coinValue(1,0,0,0) → 0.25', got: fn(1, 0, 0, 0) }, { pass: fn(0, 0, 0, 99) === 0.99, description: 'coinValue(0,0,0,99) → 0.99', got: fn(0, 0, 0, 99) } ]; }",
      "hints": [
        "Each quarter is 25 cents, dime is 10, nickel is 5, penny is 1.",
        "Calculate the total in cents first, then divide by 100 to get dollars.",
        "Return `(quarters * 25 + dimes * 10 + nickels * 5 + pennies) / 100`."
      ],
      "resources": [
        {
          "label": "MDN: Arithmetic operators",
          "url": "/docs/mdn/arithmetic.html",
          "description": "Using +, -, *, / in expressions"
        }
      ]
    },
    {
      "id": 622,
      "title": "Circle Calculator",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "variables",
        "math",
        "objects",
        "beginner"
      ],
      "description": "Calculate the area and circumference of a circle given its radius.",
      "instructions": "Write a function called `circleStats` that takes a radius and returns an object with two properties: `area` and `circumference`, both rounded to two decimal places.\n\nFormulas:\n  area = π × r²\n  circumference = 2 × π × r\n\nExample:\n  circleStats(5)  →  { area: 78.54, circumference: 31.42 }\n  circleStats(1)  →  { area: 3.14, circumference: 6.28 }",
      "starterCode": "function circleStats(radius) {\n  // Your code here\n\n}",
      "solution": "function circleStats(radius) {\n  return {\n    area: Math.round(Math.PI * radius * radius * 100) / 100,\n    circumference: Math.round(2 * Math.PI * radius * 100) / 100\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return circleStats;')(); const r5 = fn(5); const r1 = fn(1); const r0 = fn(0); return [ { pass: r5 && r5.area === 78.54, description: 'circleStats(5).area → 78.54', got: r5 && r5.area }, { pass: r5 && r5.circumference === 31.42, description: 'circleStats(5).circumference → 31.42', got: r5 && r5.circumference }, { pass: r1 && r1.area === 3.14, description: 'circleStats(1).area → 3.14', got: r1 && r1.area }, { pass: r0 && r0.area === 0 && r0.circumference === 0, description: 'circleStats(0) → { area: 0, circumference: 0 }', got: JSON.stringify(r0) } ]; }",
      "hints": [
        "JavaScript provides Math.PI for the value of π.",
        "To round to two decimal places, multiply by 100, round, then divide by 100.",
        "Return an object literal with `area` and `circumference` keys."
      ],
      "resources": [
        {
          "label": "MDN: Math.PI",
          "url": "/docs/mdn/math-pi.html",
          "description": "The built-in constant for π"
        },
        {
          "label": "MDN: Object literals",
          "url": "/docs/mdn/object-literals.html",
          "description": "Creating objects with curly braces"
        }
      ]
    },
    {
      "id": 623,
      "title": "Remainder Roundup",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "operators",
        "modulo",
        "math",
        "beginner"
      ],
      "description": "Use the modulo operator to check divisibility.",
      "instructions": "Write a function called `isDivisibleBy` that takes two numbers and returns `true` if the first number is evenly divisible by the second, and `false` otherwise.\n\nExample:\n  isDivisibleBy(10, 5)  →  true\n  isDivisibleBy(10, 3)  →  false\n  isDivisibleBy(0, 7)   →  true",
      "starterCode": "function isDivisibleBy(num, divisor) {\n  // Use the modulo operator (%)\n\n}",
      "solution": "function isDivisibleBy(num, divisor) {\n  return num % divisor === 0;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return isDivisibleBy;')(); return [ { pass: fn(10, 5) === true, description: 'isDivisibleBy(10, 5) → true', got: fn(10, 5) }, { pass: fn(10, 3) === false, description: 'isDivisibleBy(10, 3) → false', got: fn(10, 3) }, { pass: fn(0, 7) === true, description: 'isDivisibleBy(0, 7) → true', got: fn(0, 7) }, { pass: fn(100, 10) === true, description: 'isDivisibleBy(100, 10) → true', got: fn(100, 10) } ]; }",
      "hints": [
        "The modulo operator `%` gives you the remainder after division.",
        "If the remainder is 0, the number is evenly divisible.",
        "Return `num % divisor === 0`."
      ],
      "resources": [
        {
          "label": "MDN: Remainder (%)",
          "url": "/docs/mdn/remainder.html",
          "description": "The modulo operator returns the remainder of division"
        }
      ]
    },
    {
      "id": 624,
      "title": "Type Detective",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "operators",
        "typeof",
        "types",
        "beginner"
      ],
      "description": "Identify the type of a value using typeof.",
      "instructions": "Write a function called `whatType` that takes any value and returns a string describing its type. Return one of: `\"number\"`, `\"string\"`, `\"boolean\"`, `\"undefined\"`, `\"object\"`, or `\"function\"`.\n\nSpecial case: if the value is `null`, return `\"null\"` (not `\"object\"`).\n\nExample:\n  whatType(42)        →  \"number\"\n  whatType(\"hello\")   →  \"string\"\n  whatType(null)      →  \"null\"\n  whatType([1, 2])    →  \"object\"",
      "starterCode": "function whatType(value) {\n  // Your code here\n\n}",
      "solution": "function whatType(value) {\n  if (value === null) return \"null\";\n  return typeof value;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return whatType;')(); return [ { pass: fn(42) === 'number', description: 'whatType(42) → \"number\"', got: fn(42) }, { pass: fn('hello') === 'string', description: 'whatType(\"hello\") → \"string\"', got: fn('hello') }, { pass: fn(null) === 'null', description: 'whatType(null) → \"null\"', got: fn(null) }, { pass: fn(true) === 'boolean', description: 'whatType(true) → \"boolean\"', got: fn(true) }, { pass: fn(undefined) === 'undefined', description: 'whatType(undefined) → \"undefined\"', got: fn(undefined) }, { pass: fn([1,2]) === 'object', description: 'whatType([1,2]) → \"object\"', got: fn([1,2]) } ]; }",
      "hints": [
        "The `typeof` operator returns a string describing the type of a value.",
        "There's a famous quirk: `typeof null` returns `\"object\"`. You need to handle this case separately.",
        "Check for `null` first with `value === null`, then use `typeof` for everything else."
      ],
      "resources": [
        {
          "label": "MDN: typeof",
          "url": "/docs/mdn/typeof.html",
          "description": "The typeof operator and its quirks"
        }
      ]
    },
    {
      "id": 630,
      "title": "Season Finder",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "conditionals",
        "switch",
        "beginner"
      ],
      "description": "Determine the season based on a month number.",
      "instructions": "Write a function called `getSeason` that takes a month number (1–12) and returns the season as a string.\n\n  Months 12, 1, 2  → \"Winter\"\n  Months 3, 4, 5   → \"Spring\"\n  Months 6, 7, 8   → \"Summer\"\n  Months 9, 10, 11 → \"Fall\"\n\nExample:\n  getSeason(1)   →  \"Winter\"\n  getSeason(7)   →  \"Summer\"\n  getSeason(10)  →  \"Fall\"",
      "starterCode": "function getSeason(month) {\n  // Your code here\n\n}",
      "solution": "function getSeason(month) {\n  if (month === 12 || month <= 2) return \"Winter\";\n  if (month <= 5) return \"Spring\";\n  if (month <= 8) return \"Summer\";\n  return \"Fall\";\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return getSeason;')(); return [ { pass: fn(1) === 'Winter', description: 'getSeason(1) → \"Winter\"', got: fn(1) }, { pass: fn(3) === 'Spring', description: 'getSeason(3) → \"Spring\"', got: fn(3) }, { pass: fn(7) === 'Summer', description: 'getSeason(7) → \"Summer\"', got: fn(7) }, { pass: fn(10) === 'Fall', description: 'getSeason(10) → \"Fall\"', got: fn(10) }, { pass: fn(12) === 'Winter', description: 'getSeason(12) → \"Winter\"', got: fn(12) } ]; }",
      "hints": [
        "December (12) wraps around to be in Winter along with January and February.",
        "Check for month 12 separately, or use `month === 12 || month <= 2` for Winter.",
        "After handling Winter, the remaining months fall in sequential groups of three."
      ],
      "resources": [
        {
          "label": "MDN: if...else",
          "url": "/docs/mdn/if-else.html",
          "description": "Conditional branching"
        },
        {
          "label": "MDN: Logical OR (||)",
          "url": "/docs/mdn/logical-or.html",
          "description": "Combining multiple conditions"
        }
      ]
    },
    {
      "id": 631,
      "title": "Ticket Price",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "conditionals",
        "logic",
        "beginner"
      ],
      "description": "Calculate a movie ticket price based on age.",
      "instructions": "Write a function called `ticketPrice` that takes an age and returns the ticket price:\n  - Under 3: free (0)\n  - 3 to 12: $8\n  - 13 to 64: $12\n  - 65 and over: $6\n\nExample:\n  ticketPrice(2)   →  0\n  ticketPrice(10)  →  8\n  ticketPrice(30)  →  12\n  ticketPrice(70)  →  6",
      "starterCode": "function ticketPrice(age) {\n  // Your code here\n\n}",
      "solution": "function ticketPrice(age) {\n  if (age < 3) return 0;\n  if (age <= 12) return 8;\n  if (age <= 64) return 12;\n  return 6;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return ticketPrice;')(); return [ { pass: fn(2) === 0, description: 'ticketPrice(2) → 0', got: fn(2) }, { pass: fn(10) === 8, description: 'ticketPrice(10) → 8', got: fn(10) }, { pass: fn(30) === 12, description: 'ticketPrice(30) → 12', got: fn(30) }, { pass: fn(70) === 6, description: 'ticketPrice(70) → 6', got: fn(70) }, { pass: fn(3) === 8, description: 'ticketPrice(3) → 8 (boundary)', got: fn(3) }, { pass: fn(65) === 6, description: 'ticketPrice(65) → 6 (boundary)', got: fn(65) } ]; }",
      "hints": [
        "Check the age ranges from youngest to oldest.",
        "Use `<` for the first boundary (under 3) and `<=` for the rest.",
        "Each `if` with an early `return` eliminates the need for `else`."
      ],
      "resources": [
        {
          "label": "MDN: if...else",
          "url": "/docs/mdn/if-else.html",
          "description": "Conditional branching"
        }
      ]
    },
    {
      "id": 632,
      "title": "Countdown",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "for-loop",
        "arrays",
        "beginner"
      ],
      "description": "Generate a countdown array from a given number to 1.",
      "instructions": "Write a function called `countdown` that takes a positive integer `n` and returns an array counting down from `n` to 1.\n\nExample:\n  countdown(5)  →  [5, 4, 3, 2, 1]\n  countdown(3)  →  [3, 2, 1]\n  countdown(1)  →  [1]",
      "starterCode": "function countdown(n) {\n  // Your code here\n\n}",
      "solution": "function countdown(n) {\n  const result = [];\n  for (let i = n; i >= 1; i--) {\n    result.push(i);\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countdown;')(); return [ { pass: JSON.stringify(fn(5)) === '[5,4,3,2,1]', description: 'countdown(5) → [5,4,3,2,1]', got: JSON.stringify(fn(5)) }, { pass: JSON.stringify(fn(3)) === '[3,2,1]', description: 'countdown(3) → [3,2,1]', got: JSON.stringify(fn(3)) }, { pass: JSON.stringify(fn(1)) === '[1]', description: 'countdown(1) → [1]', got: JSON.stringify(fn(1)) } ]; }",
      "hints": [
        "Start a for loop at `n` and decrement until you reach 1.",
        "Push each value into a results array as you go.",
        "The loop condition should be `i >= 1`."
      ],
      "resources": [
        {
          "label": "MDN: for loop",
          "url": "/docs/mdn/for.html",
          "description": "The classic counting loop"
        },
        {
          "label": "MDN: Array.push()",
          "url": "/docs/mdn/array-push.html",
          "description": "Adding elements to the end of an array"
        }
      ]
    },
    {
      "id": 634,
      "title": "Digit Counter",
      "type": "js",
      "tier": 3,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "while-loop",
        "math",
        "intermediate"
      ],
      "description": "Count the number of digits in an integer.",
      "instructions": "Write a function called `countDigits` that takes a non-negative integer and returns the number of digits it has. Do NOT convert to a string — use a loop and math.\n\nExample:\n  countDigits(0)      →  1\n  countDigits(42)     →  2\n  countDigits(12345)  →  5",
      "starterCode": "function countDigits(num) {\n  // Use a loop — don't convert to string!\n\n}",
      "solution": "function countDigits(num) {\n  if (num === 0) return 1;\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 10);\n    count++;\n  }\n  return count;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countDigits;')(); return [ { pass: fn(0) === 1, description: 'countDigits(0) → 1', got: fn(0) }, { pass: fn(42) === 2, description: 'countDigits(42) → 2', got: fn(42) }, { pass: fn(12345) === 5, description: 'countDigits(12345) → 5', got: fn(12345) }, { pass: fn(1000000) === 7, description: 'countDigits(1000000) → 7', got: fn(1000000) } ]; }",
      "hints": [
        "Repeatedly dividing by 10 and rounding down 'removes' the last digit.",
        "Count how many times you can divide before reaching 0.",
        "Handle the special case of 0 separately (it has 1 digit)."
      ],
      "resources": [
        {
          "label": "MDN: while loop",
          "url": "/docs/mdn/while.html",
          "description": "Looping while a condition is true"
        },
        {
          "label": "MDN: Math.floor()",
          "url": "/docs/mdn/math-floor.html",
          "description": "Rounding down to the nearest integer"
        }
      ]
    },
    {
      "id": 635,
      "title": "Multiply Table",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "for-loop",
        "arrays",
        "beginner"
      ],
      "description": "Generate the multiplication table for a number.",
      "instructions": "Write a function called `multiplyTable` that takes a number `n` and returns an array of strings showing its multiplication table from 1 to 10.\n\nExample:\n  multiplyTable(3)  →  [\"3 x 1 = 3\", \"3 x 2 = 6\", ..., \"3 x 10 = 30\"]",
      "starterCode": "function multiplyTable(n) {\n  // Your code here\n\n}",
      "solution": "function multiplyTable(n) {\n  const result = [];\n  for (let i = 1; i <= 10; i++) {\n    result.push(n + \" x \" + i + \" = \" + (n * i));\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return multiplyTable;')(); const r3 = fn(3); const r5 = fn(5); return [ { pass: r3 && r3.length === 10, description: 'multiplyTable(3) returns 10 items', got: r3 && r3.length }, { pass: r3 && r3[0] === '3 x 1 = 3', description: 'First: \"3 x 1 = 3\"', got: r3 && r3[0] }, { pass: r3 && r3[9] === '3 x 10 = 30', description: 'Last: \"3 x 10 = 30\"', got: r3 && r3[9] }, { pass: r5 && r5[4] === '5 x 5 = 25', description: 'multiplyTable(5)[4] → \"5 x 5 = 25\"', got: r5 && r5[4] } ]; }",
      "hints": [
        "Loop from 1 to 10 and build a string for each multiplication.",
        "Use string concatenation to build each line: `n + \" x \" + i + \" = \" + (n * i)`.",
        "Push each string into a results array."
      ],
      "resources": [
        {
          "label": "MDN: for loop",
          "url": "/docs/mdn/for.html",
          "description": "The classic counting loop"
        }
      ]
    },
    {
      "id": 637,
      "title": "Prime Checker",
      "type": "js",
      "tier": 3,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "math",
        "conditionals",
        "intermediate"
      ],
      "description": "Determine whether a number is prime.",
      "instructions": "Write a function called `isPrime` that takes a number and returns `true` if it is a prime number, `false` otherwise. A prime number is greater than 1 and only divisible by 1 and itself.\n\nExample:\n  isPrime(7)   →  true\n  isPrime(4)   →  false\n  isPrime(1)   →  false\n  isPrime(13)  →  true",
      "starterCode": "function isPrime(num) {\n  // Your code here\n\n}",
      "solution": "function isPrime(num) {\n  if (num < 2) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return isPrime;')(); return [ { pass: fn(7) === true, description: 'isPrime(7) → true', got: fn(7) }, { pass: fn(4) === false, description: 'isPrime(4) → false', got: fn(4) }, { pass: fn(1) === false, description: 'isPrime(1) → false', got: fn(1) }, { pass: fn(13) === true, description: 'isPrime(13) → true', got: fn(13) }, { pass: fn(0) === false, description: 'isPrime(0) → false', got: fn(0) }, { pass: fn(97) === true, description: 'isPrime(97) → true', got: fn(97) } ]; }",
      "hints": [
        "Numbers less than 2 are not prime.",
        "You only need to check divisors up to the square root of the number.",
        "If any number from 2 to √num divides evenly, it's not prime."
      ],
      "resources": [
        {
          "label": "MDN: Math.sqrt()",
          "url": "/docs/mdn/math-sqrt.html",
          "description": "Calculating the square root of a number"
        }
      ]
    },
    {
      "id": 638,
      "title": "Sum of Digits",
      "type": "js",
      "tier": 3,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "while-loop",
        "math",
        "intermediate"
      ],
      "description": "Add up all the individual digits of a number.",
      "instructions": "Write a function called `sumOfDigits` that takes a non-negative integer and returns the sum of its digits. Use math (not string conversion).\n\nExample:\n  sumOfDigits(123)   →  6\n  sumOfDigits(9999)  →  36\n  sumOfDigits(0)     →  0",
      "starterCode": "function sumOfDigits(num) {\n  // Use math — don't convert to string!\n\n}",
      "solution": "function sumOfDigits(num) {\n  let sum = 0;\n  while (num > 0) {\n    sum += num % 10;\n    num = Math.floor(num / 10);\n  }\n  return sum;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return sumOfDigits;')(); return [ { pass: fn(123) === 6, description: 'sumOfDigits(123) → 6', got: fn(123) }, { pass: fn(9999) === 36, description: 'sumOfDigits(9999) → 36', got: fn(9999) }, { pass: fn(0) === 0, description: 'sumOfDigits(0) → 0', got: fn(0) }, { pass: fn(100) === 1, description: 'sumOfDigits(100) → 1', got: fn(100) } ]; }",
      "hints": [
        "`num % 10` gives you the last digit. `Math.floor(num / 10)` removes it.",
        "Keep extracting and summing the last digit until the number reaches 0.",
        "The accumulator pattern: `sum += num % 10` inside a while loop."
      ],
      "resources": [
        {
          "label": "MDN: while loop",
          "url": "/docs/mdn/while.html",
          "description": "Looping while a condition is true"
        }
      ]
    },
    {
      "id": 639,
      "title": "Vowel Counter",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "loops",
        "includes",
        "beginner"
      ],
      "description": "Count the number of vowels in a string.",
      "instructions": "Write a function called `countVowels` that takes a string and returns the number of vowels (a, e, i, o, u) it contains. Case-insensitive.\n\nExample:\n  countVowels(\"hello\")      →  2\n  countVowels(\"JavaScript\") →  3\n  countVowels(\"rhythm\")     →  0",
      "starterCode": "function countVowels(str) {\n  // Your code here\n\n}",
      "solution": "function countVowels(str) {\n  let count = 0;\n  for (const char of str.toLowerCase()) {\n    if (\"aeiou\".includes(char)) count++;\n  }\n  return count;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countVowels;')(); return [ { pass: fn('hello') === 2, description: 'countVowels(\"hello\") → 2', got: fn('hello') }, { pass: fn('JavaScript') === 3, description: 'countVowels(\"JavaScript\") → 3', got: fn('JavaScript') }, { pass: fn('rhythm') === 0, description: 'countVowels(\"rhythm\") → 0', got: fn('rhythm') }, { pass: fn('AEIOU') === 5, description: 'countVowels(\"AEIOU\") → 5', got: fn('AEIOU') }, { pass: fn('') === 0, description: 'countVowels(\"\") → 0', got: fn('') } ]; }",
      "hints": [
        "Convert the string to lowercase first so you only need to check lowercase vowels.",
        "Loop through each character and check if it's in the set \"aeiou\".",
        "`\"aeiou\".includes(char)` is a clean way to check if a character is a vowel."
      ],
      "resources": [
        {
          "label": "MDN: String.includes()",
          "url": "/docs/mdn/string-includes.html",
          "description": "Check if a string contains a substring"
        }
      ]
    },
    {
      "id": 643,
      "title": "Word Frequency",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "objects",
        "reduce",
        "intermediate"
      ],
      "description": "Count how many times each word appears in a string.",
      "instructions": "Write a function called `wordFrequency` that takes a string of words (separated by spaces) and returns an object where each key is a lowercase word and each value is the count of how many times it appears.\n\nExample:\n  wordFrequency(\"the cat sat on the mat\")\n  → { the: 2, cat: 1, sat: 1, on: 1, mat: 1 }",
      "starterCode": "function wordFrequency(str) {\n  // Your code here\n\n}",
      "solution": "function wordFrequency(str) {\n  if (!str) return {};\n  const counts = {};\n  for (const word of str.toLowerCase().split(' ')) {\n    counts[word] = (counts[word] || 0) + 1;\n  }\n  return counts;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return wordFrequency;')(); const r1 = fn('the cat sat on the mat'); const r2 = fn('hello hello hello'); return [ { pass: r1 && r1.the === 2, description: '\"the\" appears 2 times', got: r1 && r1.the }, { pass: r1 && r1.cat === 1, description: '\"cat\" appears 1 time', got: r1 && r1.cat }, { pass: r2 && r2.hello === 3, description: '\"hello\" appears 3 times', got: r2 && r2.hello }, { pass: JSON.stringify(fn('')) === '{}', description: 'empty string → {}', got: JSON.stringify(fn('')) } ]; }",
      "hints": [
        "Split the string into words and lowercase them.",
        "Use an object as a frequency counter: `counts[word] = (counts[word] || 0) + 1`.",
        "The `||` pattern handles the case when a word is seen for the first time."
      ],
      "resources": [
        {
          "label": "MDN: Object basics",
          "url": "/docs/mdn/objects.html",
          "description": "Using objects as key-value stores"
        }
      ]
    },
    {
      "id": 644,
      "title": "Remove Duplicates",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "set",
        "unique",
        "beginner"
      ],
      "description": "Remove duplicate values from an array while preserving order.",
      "instructions": "Write a function called `removeDuplicates` that takes an array and returns a new array with duplicate values removed, keeping the first occurrence of each value.\n\nExample:\n  removeDuplicates([1, 2, 2, 3, 1, 4])  →  [1, 2, 3, 4]\n  removeDuplicates([\"a\", \"b\", \"a\"])       →  [\"a\", \"b\"]",
      "starterCode": "function removeDuplicates(arr) {\n  // Your code here\n\n}",
      "solution": "function removeDuplicates(arr) {\n  return [...new Set(arr)];\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return removeDuplicates;')(); return [ { pass: JSON.stringify(fn([1,2,2,3,1,4])) === '[1,2,3,4]', description: 'removeDuplicates([1,2,2,3,1,4]) → [1,2,3,4]', got: JSON.stringify(fn([1,2,2,3,1,4])) }, { pass: JSON.stringify(fn(['a','b','a'])) === '[\"a\",\"b\"]', description: 'removeDuplicates([\"a\",\"b\",\"a\"]) → [\"a\",\"b\"]', got: JSON.stringify(fn(['a','b','a'])) }, { pass: JSON.stringify(fn([])) === '[]', description: 'removeDuplicates([]) → []', got: JSON.stringify(fn([])) } ]; }",
      "hints": [
        "A `Set` automatically removes duplicates.",
        "Convert the array to a Set, then spread it back into an array.",
        "`[...new Set(arr)]` is the concise solution."
      ],
      "resources": [
        {
          "label": "MDN: Set",
          "url": "/docs/mdn/set.html",
          "description": "A collection of unique values"
        }
      ]
    },
    {
      "id": 645,
      "title": "Chunk Array",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "loops",
        "slice",
        "intermediate"
      ],
      "description": "Split an array into groups of a given size.",
      "instructions": "Write a function called `chunk` that takes an array and a size, and splits the array into sub-arrays of the given size. The last chunk may be smaller if the array doesn't divide evenly.\n\nExample:\n  chunk([1,2,3,4,5], 2)  →  [[1,2], [3,4], [5]]\n  chunk([1,2,3], 3)       →  [[1,2,3]]\n  chunk([1,2,3], 1)       →  [[1], [2], [3]]",
      "starterCode": "function chunk(arr, size) {\n  // Your code here\n\n}",
      "solution": "function chunk(arr, size) {\n  const result = [];\n  for (let i = 0; i < arr.length; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return chunk;')(); return [ { pass: JSON.stringify(fn([1,2,3,4,5], 2)) === '[[1,2],[3,4],[5]]', description: 'chunk([1,2,3,4,5], 2) → [[1,2],[3,4],[5]]', got: JSON.stringify(fn([1,2,3,4,5], 2)) }, { pass: JSON.stringify(fn([1,2,3], 3)) === '[[1,2,3]]', description: 'chunk([1,2,3], 3) → [[1,2,3]]', got: JSON.stringify(fn([1,2,3], 3)) }, { pass: JSON.stringify(fn([1,2,3], 1)) === '[[1],[2],[3]]', description: 'chunk([1,2,3], 1) → [[1],[2],[3]]', got: JSON.stringify(fn([1,2,3], 1)) }, { pass: JSON.stringify(fn([], 2)) === '[]', description: 'chunk([], 2) → []', got: JSON.stringify(fn([], 2)) } ]; }",
      "hints": [
        "Use a for loop that increments by `size` each iteration.",
        "`arr.slice(i, i + size)` extracts a chunk without modifying the original.",
        "Push each slice into a results array."
      ],
      "resources": [
        {
          "label": "MDN: Array.slice()",
          "url": "/docs/mdn/array-slice.html",
          "description": "Extracting a section of an array"
        }
      ]
    },
    {
      "id": 646,
      "title": "Flatten One Level",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "concat",
        "flat",
        "intermediate"
      ],
      "description": "Flatten a nested array by one level.",
      "instructions": "Write a function called `flattenOnce` that takes an array which may contain nested arrays and flattens it by one level. Do NOT use `.flat()`.\n\nExample:\n  flattenOnce([[1,2], [3,4], [5]])  →  [1, 2, 3, 4, 5]\n  flattenOnce([1, [2, 3], 4])        →  [1, 2, 3, 4]\n  flattenOnce([[1, [2]], 3])          →  [1, [2], 3]",
      "starterCode": "function flattenOnce(arr) {\n  // Don't use .flat()!\n\n}",
      "solution": "function flattenOnce(arr) {\n  const result = [];\n  for (const item of arr) {\n    if (Array.isArray(item)) {\n      result.push(...item);\n    } else {\n      result.push(item);\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return flattenOnce;')(); return [ { pass: JSON.stringify(fn([[1,2],[3,4],[5]])) === '[1,2,3,4,5]', description: 'flattenOnce([[1,2],[3,4],[5]]) → [1,2,3,4,5]', got: JSON.stringify(fn([[1,2],[3,4],[5]])) }, { pass: JSON.stringify(fn([1,[2,3],4])) === '[1,2,3,4]', description: 'flattenOnce([1,[2,3],4]) → [1,2,3,4]', got: JSON.stringify(fn([1,[2,3],4])) }, { pass: JSON.stringify(fn([[1,[2]],3])) === '[1,[2],3]', description: 'flattenOnce([[1,[2]],3]) → [1,[2],3] (one level only)', got: JSON.stringify(fn([[1,[2]],3])) } ]; }",
      "hints": [
        "Loop through each item. If it's an array, spread its elements into the result.",
        "Use `Array.isArray(item)` to check if an element is an array.",
        "`result.push(...item)` spreads the nested array's elements."
      ],
      "resources": [
        {
          "label": "MDN: Array.isArray()",
          "url": "/docs/mdn/array-isarray.html",
          "description": "Check if a value is an array"
        }
      ]
    },
    {
      "id": 647,
      "title": "Intersection",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "filter",
        "includes",
        "intermediate"
      ],
      "description": "Find the common elements between two arrays.",
      "instructions": "Write a function called `intersection` that takes two arrays and returns a new array containing only the elements that appear in both. No duplicates in the result.\n\nExample:\n  intersection([1,2,3,4], [3,4,5,6])        →  [3, 4]\n  intersection([\"a\",\"b\"], [\"b\",\"c\"])          →  [\"b\"]\n  intersection([1,1,2,2], [2,2,3,3])          →  [2]",
      "starterCode": "function intersection(arr1, arr2) {\n  // Your code here\n\n}",
      "solution": "function intersection(arr1, arr2) {\n  const set2 = new Set(arr2);\n  return [...new Set(arr1)].filter(item => set2.has(item));\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return intersection;')(); return [ { pass: JSON.stringify(fn([1,2,3,4],[3,4,5,6])) === '[3,4]', description: 'intersection([1,2,3,4],[3,4,5,6]) → [3,4]', got: JSON.stringify(fn([1,2,3,4],[3,4,5,6])) }, { pass: JSON.stringify(fn(['a','b'],['b','c'])) === '[\"b\"]', description: 'intersection([\"a\",\"b\"],[\"b\",\"c\"]) → [\"b\"]', got: JSON.stringify(fn(['a','b'],['b','c'])) }, { pass: JSON.stringify(fn([1,1,2,2],[2,2,3,3])) === '[2]', description: 'intersection([1,1,2,2],[2,2,3,3]) → [2]', got: JSON.stringify(fn([1,1,2,2],[2,2,3,3])) }, { pass: JSON.stringify(fn([],[1,2])) === '[]', description: 'intersection([],[1,2]) → []', got: JSON.stringify(fn([],[1,2])) } ]; }",
      "hints": [
        "Convert one array to a Set for fast lookups.",
        "Filter the other array to keep only elements found in the Set.",
        "Deduplicate the first array too — `[...new Set(arr1)].filter(...)`."
      ],
      "resources": [
        {
          "label": "MDN: Set",
          "url": "/docs/mdn/set.html",
          "description": "A collection of unique values"
        }
      ]
    },
    {
      "id": 652,
      "title": "Simple Callback",
      "type": "js",
      "tier": 2,
      "category": [
        "functions",
        "callbacks"
      ],
      "tags": [
        "callbacks",
        "functions",
        "higher-order",
        "beginner"
      ],
      "description": "Apply a callback function to each element and return the results.",
      "instructions": "Write a function called `applyToEach` that takes an array and a callback function, and returns a new array where each element has been transformed by the callback. Do NOT use `.map()`.\n\nExample:\n  applyToEach([1,2,3], x => x * 2)     →  [2, 4, 6]\n  applyToEach(['a','b'], s => s + '!')  →  ['a!', 'b!']",
      "starterCode": "function applyToEach(arr, callback) {\n  // Don't use .map()!\n\n}",
      "solution": "function applyToEach(arr, callback) {\n  const result = [];\n  for (const item of arr) {\n    result.push(callback(item));\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return applyToEach;')(); return [ { pass: JSON.stringify(fn([1,2,3], x => x * 2)) === '[2,4,6]', description: 'applyToEach([1,2,3], x => x*2) → [2,4,6]', got: JSON.stringify(fn([1,2,3], x => x * 2)) }, { pass: JSON.stringify(fn(['a','b'], s => s + '!')) === '[\"a!\",\"b!\"]', description: 'applyToEach([\"a\",\"b\"], s => s+\"!\") → [\"a!\",\"b!\"]', got: JSON.stringify(fn(['a','b'], s => s + '!')) }, { pass: JSON.stringify(fn([], x => x)) === '[]', description: 'applyToEach([], ...) → []', got: JSON.stringify(fn([], x => x)) } ]; }",
      "hints": [
        "A callback is just a function passed as an argument to another function.",
        "Loop through the array and call `callback(item)` for each element.",
        "This is essentially what `.map()` does under the hood."
      ],
      "resources": [
        {
          "label": "MDN: Callback functions",
          "url": "/docs/mdn/callbacks.html",
          "description": "Passing functions as arguments to other functions"
        }
      ]
    },
    {
      "id": 653,
      "title": "Custom Filter",
      "type": "js",
      "tier": 3,
      "category": [
        "functions",
        "callbacks"
      ],
      "tags": [
        "callbacks",
        "functions",
        "higher-order",
        "intermediate"
      ],
      "description": "Implement your own version of Array.filter using a callback.",
      "instructions": "Write a function called `myFilter` that takes an array and a predicate function (a function that returns true/false), and returns a new array containing only the elements for which the predicate returns true. Do NOT use `.filter()`.\n\nExample:\n  myFilter([1,2,3,4,5], n => n > 3)       →  [4, 5]\n  myFilter(['cat','dog','cow'], s => s.startsWith('c'))  →  ['cat', 'cow']",
      "starterCode": "function myFilter(arr, predicate) {\n  // Don't use .filter()!\n\n}",
      "solution": "function myFilter(arr, predicate) {\n  const result = [];\n  for (const item of arr) {\n    if (predicate(item)) result.push(item);\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return myFilter;')(); return [ { pass: JSON.stringify(fn([1,2,3,4,5], n => n > 3)) === '[4,5]', description: 'myFilter([1,2,3,4,5], n => n>3) → [4,5]', got: JSON.stringify(fn([1,2,3,4,5], n => n > 3)) }, { pass: JSON.stringify(fn(['cat','dog','cow'], s => s.startsWith('c'))) === '[\"cat\",\"cow\"]', description: 'myFilter with startsWith(\"c\") → [\"cat\",\"cow\"]', got: JSON.stringify(fn(['cat','dog','cow'], s => s.startsWith('c'))) }, { pass: JSON.stringify(fn([1,2,3], () => false)) === '[]', description: 'Always-false predicate → []', got: JSON.stringify(fn([1,2,3], () => false)) } ]; }",
      "hints": [
        "A predicate is a function that returns true or false.",
        "Loop through the array and only push items where `predicate(item)` is true.",
        "This is exactly how `.filter()` works internally."
      ],
      "resources": [
        {
          "label": "MDN: Array.filter()",
          "url": "/docs/mdn/array-filter.html",
          "description": "How the built-in filter method works"
        }
      ]
    },
    {
      "id": 654,
      "title": "Function Pipeline",
      "type": "js",
      "tier": 4,
      "category": [
        "functions",
        "callbacks"
      ],
      "tags": [
        "callbacks",
        "reduce",
        "composition",
        "advanced"
      ],
      "description": "Pipe a value through a series of functions, left to right.",
      "instructions": "Write a function called `pipe` that takes a value and an array of functions, and applies each function to the result of the previous one, left to right.\n\nExample:\n  pipe(5, [x => x + 1, x => x * 2])       →  12\n  pipe('hello', [s => s.toUpperCase(), s => s + '!'])  →  \"HELLO!\"",
      "starterCode": "function pipe(value, fns) {\n\n}",
      "solution": "function pipe(value, fns) {\n  return fns.reduce((acc, fn) => fn(acc), value);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return pipe;')(); return [ { pass: fn(5, [x => x + 1, x => x * 2]) === 12, description: 'pipe(5, [+1, *2]) → 12', got: fn(5, [x => x + 1, x => x * 2]) }, { pass: fn('hello', [s => s.toUpperCase(), s => s + '!']) === 'HELLO!', description: 'pipe(\"hello\", [toUpper, +!]) → \"HELLO!\"', got: fn('hello', [s => s.toUpperCase(), s => s + '!']) }, { pass: fn(10, []) === 10, description: 'pipe(10, []) → 10 (no functions)', got: fn(10, []) } ]; }",
      "hints": [
        "Each function takes the output of the previous function as input.",
        "`reduce` is perfect here — the accumulator carries the value through each function.",
        "`fns.reduce((acc, fn) => fn(acc), value)` is the one-liner solution."
      ],
      "resources": [
        {
          "label": "MDN: Array.reduce()",
          "url": "/docs/mdn/array-reduce.html",
          "description": "Reducing an array to a single value"
        }
      ]
    },
    {
      "id": 655,
      "title": "Recursive Sum",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "math",
        "beginner"
      ],
      "description": "Sum all numbers from 1 to n using recursion.",
      "instructions": "Write a function called `recursiveSum` that takes a positive integer `n` and returns the sum of all integers from 1 to `n`. Use recursion — no loops.\n\nExample:\n  recursiveSum(5)   →  15  (1+2+3+4+5)\n  recursiveSum(1)   →  1\n  recursiveSum(10)  →  55",
      "starterCode": "function recursiveSum(n) {\n  // Use recursion — no loops!\n\n}",
      "solution": "function recursiveSum(n) {\n  if (n <= 1) return n;\n  return n + recursiveSum(n - 1);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return recursiveSum;')(); return [ { pass: fn(5) === 15, description: 'recursiveSum(5) → 15', got: fn(5) }, { pass: fn(1) === 1, description: 'recursiveSum(1) → 1', got: fn(1) }, { pass: fn(10) === 55, description: 'recursiveSum(10) → 55', got: fn(10) }, { pass: fn(0) === 0, description: 'recursiveSum(0) → 0', got: fn(0) } ]; }",
      "hints": [
        "Every recursive function needs a base case — what's the simplest input?",
        "The base case is n <= 1. Otherwise, n + the sum of everything below it.",
        "`return n + recursiveSum(n - 1)`."
      ],
      "resources": [
        {
          "label": "MDN: Recursion",
          "url": "/docs/mdn/recursion.html",
          "description": "Functions that call themselves"
        }
      ]
    },
    {
      "id": 658,
      "title": "Recursive Reverse",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "recursion"
      ],
      "tags": [
        "recursion",
        "strings",
        "intermediate"
      ],
      "description": "Reverse a string using recursion.",
      "instructions": "Write a function called `reverseStr` that takes a string and returns it reversed, using recursion. No loops or `.reverse()`.\n\nExample:\n  reverseStr(\"hello\")  →  \"olleh\"\n  reverseStr(\"a\")      →  \"a\"\n  reverseStr(\"\")        →  \"\"",
      "starterCode": "function reverseStr(str) {\n  // Use recursion — no loops!\n\n}",
      "solution": "function reverseStr(str) {\n  if (str.length <= 1) return str;\n  return reverseStr(str.slice(1)) + str[0];\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return reverseStr;')(); return [ { pass: fn('hello') === 'olleh', description: 'reverseStr(\"hello\") → \"olleh\"', got: fn('hello') }, { pass: fn('a') === 'a', description: 'reverseStr(\"a\") → \"a\"', got: fn('a') }, { pass: fn('') === '', description: 'reverseStr(\"\") → \"\"', got: fn('') }, { pass: fn('abcde') === 'edcba', description: 'reverseStr(\"abcde\") → \"edcba\"', got: fn('abcde') } ]; }",
      "hints": [
        "Base case: an empty string or single character is already reversed.",
        "Take the first character and put it at the end of the reversed rest.",
        "`reverseStr(str.slice(1)) + str[0]`."
      ],
      "resources": [
        {
          "label": "MDN: String.slice()",
          "url": "/docs/mdn/string-slice.html",
          "description": "Extracting parts of a string"
        }
      ]
    },
    {
      "id": 660,
      "title": "Range Builder",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "arrays",
        "utility",
        "beginner"
      ],
      "description": "Generate an array of numbers within a range.",
      "instructions": "Write a function called `range` that takes a start and end number and returns an array of all integers from start to end (inclusive).\n\nExample:\n  range(1, 5)   →  [1, 2, 3, 4, 5]\n  range(3, 3)   →  [3]\n  range(-2, 2)  →  [-2, -1, 0, 1, 2]",
      "starterCode": "function range(start, end) {\n  // Your code here\n\n}",
      "solution": "function range(start, end) {\n  const result = [];\n  for (let i = start; i <= end; i++) {\n    result.push(i);\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return range;')(); return [ { pass: JSON.stringify(fn(1, 5)) === '[1,2,3,4,5]', description: 'range(1, 5) → [1,2,3,4,5]', got: JSON.stringify(fn(1, 5)) }, { pass: JSON.stringify(fn(3, 3)) === '[3]', description: 'range(3, 3) → [3]', got: JSON.stringify(fn(3, 3)) }, { pass: JSON.stringify(fn(-2, 2)) === '[-2,-1,0,1,2]', description: 'range(-2, 2) → [-2,-1,0,1,2]', got: JSON.stringify(fn(-2, 2)) } ]; }",
      "hints": [
        "Start a for loop at `start` and increment up to `end`.",
        "Push each value into a results array.",
        "This is the same as Python's `range()` but inclusive on both ends."
      ],
      "resources": [
        {
          "label": "MDN: for loop",
          "url": "/docs/mdn/for.html",
          "description": "The classic counting loop"
        }
      ]
    },
    {
      "id": 662,
      "title": "Zip Arrays",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "loops",
        "pairs",
        "intermediate"
      ],
      "description": "Combine two arrays into an array of pairs.",
      "instructions": "Write a function called `zip` that takes two arrays and returns an array of pairs (2-element arrays), combining elements at the same index. Stop at the shorter array's length.\n\nExample:\n  zip([1,2,3], ['a','b','c'])  →  [[1,'a'], [2,'b'], [3,'c']]\n  zip([1,2], ['a','b','c'])    →  [[1,'a'], [2,'b']]\n  zip([], [1])                  →  []",
      "starterCode": "function zip(arr1, arr2) {\n  // Your code here\n\n}",
      "solution": "function zip(arr1, arr2) {\n  const len = Math.min(arr1.length, arr2.length);\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result.push([arr1[i], arr2[i]]);\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return zip;')(); return [ { pass: JSON.stringify(fn([1,2,3],['a','b','c'])) === '[[1,\"a\"],[2,\"b\"],[3,\"c\"]]', description: 'zip([1,2,3],[\"a\",\"b\",\"c\"]) → pairs', got: JSON.stringify(fn([1,2,3],['a','b','c'])) }, { pass: JSON.stringify(fn([1,2],['a','b','c'])) === '[[1,\"a\"],[2,\"b\"]]', description: 'zip([1,2],[\"a\",\"b\",\"c\"]) → stops at shorter', got: JSON.stringify(fn([1,2],['a','b','c'])) }, { pass: JSON.stringify(fn([],['a'])) === '[]', description: 'zip([],[\"a\"]) → []', got: JSON.stringify(fn([],['a'])) } ]; }",
      "hints": [
        "Use `Math.min` to determine the length of the shorter array.",
        "Loop up to that length and pair elements at matching indices.",
        "Push `[arr1[i], arr2[i]]` into the result for each index."
      ],
      "resources": [
        {
          "label": "MDN: Math.min()",
          "url": "/docs/mdn/math-min.html",
          "description": "Finding the smallest value"
        }
      ]
    },
    {
      "id": 663,
      "title": "Most Frequent",
      "type": "js",
      "tier": 3,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "arrays",
        "objects",
        "counting",
        "intermediate"
      ],
      "description": "Find the most frequently occurring element in an array.",
      "instructions": "Write a function called `mostFrequent` that takes an array and returns the element that appears most often. If there's a tie, return the one that appears first.\n\nExample:\n  mostFrequent([1, 2, 2, 3, 3, 3])  →  3\n  mostFrequent(['a', 'b', 'a'])       →  'a'\n  mostFrequent([5])                    →  5",
      "starterCode": "function mostFrequent(arr) {\n  // Your code here\n\n}",
      "solution": "function mostFrequent(arr) {\n  const counts = {};\n  let maxItem = arr[0];\n  let maxCount = 0;\n  for (const item of arr) {\n    counts[item] = (counts[item] || 0) + 1;\n    if (counts[item] > maxCount) {\n      maxCount = counts[item];\n      maxItem = item;\n    }\n  }\n  return maxItem;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return mostFrequent;')(); return [ { pass: fn([1,2,2,3,3,3]) === 3, description: 'mostFrequent([1,2,2,3,3,3]) → 3', got: fn([1,2,2,3,3,3]) }, { pass: fn(['a','b','a']) === 'a', description: 'mostFrequent([\"a\",\"b\",\"a\"]) → \"a\"', got: fn(['a','b','a']) }, { pass: fn([5]) === 5, description: 'mostFrequent([5]) → 5', got: fn([5]) }, { pass: fn([1,1,2,2,3]) === 1, description: 'mostFrequent([1,1,2,2,3]) → 1 (tie: first wins)', got: fn([1,1,2,2,3]) } ]; }",
      "hints": [
        "Use an object to count occurrences of each element.",
        "Track the current maximum count and its element as you iterate.",
        "Update the max only when a strictly greater count is found (to preserve first-seen behavior on ties)."
      ],
      "resources": [
        {
          "label": "MDN: Object basics",
          "url": "/docs/mdn/objects.html",
          "description": "Using objects as frequency counters"
        }
      ]
    },
    {
      "id": 664,
      "title": "Between Two Sets",
      "type": "js",
      "tier": 4,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "math",
        "divisibility",
        "loops",
        "intermediate"
      ],
      "description": "Find numbers that are multiples of one set and factors of another.",
      "instructions": "Write a function called `betweenSets` that takes two arrays of positive integers. Return all integers that are:\n  1. Evenly divisible by every element of the first array, AND\n  2. A factor of every element of the second array\n\nExample:\n  betweenSets([2, 6], [24, 36])  →  [6, 12]\n  betweenSets([1], [100])         →  [1, 2, 4, 5, 10, 20, 25, 50, 100]",
      "starterCode": "function betweenSets(setA, setB) {\n\n}",
      "solution": "function betweenSets(setA, setB) {\n  const maxCandidate = Math.min(...setB);\n  const results = [];\n  for (let i = 1; i <= maxCandidate; i++) {\n    const divisibleByAll = setA.every(a => i % a === 0);\n    const factorOfAll = setB.every(b => b % i === 0);\n    if (divisibleByAll && factorOfAll) results.push(i);\n  }\n  return results;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return betweenSets;')(); return [ { pass: JSON.stringify(fn([2,6],[24,36])) === '[6,12]', description: 'betweenSets([2,6],[24,36]) → [6,12]', got: JSON.stringify(fn([2,6],[24,36])) }, { pass: fn([1],[100]).length === 9, description: 'betweenSets([1],[100]) has 9 results', got: fn([1],[100]).length }, { pass: JSON.stringify(fn([3],[12,18])) === '[3,6]', description: 'betweenSets([3],[12,18]) → [3,6]', got: JSON.stringify(fn([3],[12,18])) } ]; }",
      "hints": [
        "The candidate numbers range from 1 to the smallest number in the second array.",
        "Use `.every()` to check that a candidate meets both conditions.",
        "A candidate must be divisible by all in setA AND divide evenly into all in setB."
      ],
      "resources": [
        {
          "label": "MDN: Array.every()",
          "url": "/docs/mdn/array-every.html",
          "description": "Check if all elements pass a test"
        }
      ]
    },
    {
      "id": 665,
      "title": "Alternating Caps",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "loops",
        "case",
        "beginner"
      ],
      "description": "Alternate between uppercase and lowercase letters.",
      "instructions": "Write a function called `altCaps` that takes a string and returns it with alternating capitalization, starting with uppercase. Non-letter characters don't count toward the alternation.\n\nExample:\n  altCaps(\"hello\")     →  \"HeLlO\"\n  altCaps(\"javascript\") →  \"JaVaScRiPt\"\n  altCaps(\"hi there\")  →  \"Hi ThErE\"",
      "starterCode": "function altCaps(str) {\n  // Your code here\n\n}",
      "solution": "function altCaps(str) {\n  let letterIndex = 0;\n  let result = '';\n  for (const char of str) {\n    if (/[a-z]/i.test(char)) {\n      result += letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\n      letterIndex++;\n    } else {\n      result += char;\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return altCaps;')(); return [ { pass: fn('hello') === 'HeLlO', description: 'altCaps(\"hello\") → \"HeLlO\"', got: fn('hello') }, { pass: fn('javascript') === 'JaVaScRiPt', description: 'altCaps(\"javascript\") → \"JaVaScRiPt\"', got: fn('javascript') }, { pass: fn('hi there') === 'Hi ThErE', description: 'altCaps(\"hi there\") → \"Hi ThErE\"', got: fn('hi there') }, { pass: fn('') === '', description: 'altCaps(\"\") → \"\"', got: fn('') } ]; }",
      "hints": [
        "Track a separate counter for letters only (skip spaces and punctuation).",
        "Even-indexed letters become uppercase, odd-indexed become lowercase.",
        "Use a regex like `/[a-z]/i` to detect letter characters."
      ],
      "resources": [
        {
          "label": "MDN: String.toUpperCase()",
          "url": "/docs/mdn/string-toupper.html",
          "description": "Converting a string to uppercase"
        }
      ]
    },
    {
      "id": 671,
      "title": "Quadrant Finder",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "conditionals",
        "math",
        "coordinates",
        "beginner"
      ],
      "description": "Determine which quadrant a coordinate point falls in.",
      "instructions": "Write a function called `getQuadrant` that takes two numbers `x` and `y` representing a point on a coordinate plane, and returns which quadrant the point is in (1–4). If the point is on an axis (x or y is 0), return `0`.\n\nQuadrant layout:\n- Quadrant 1: x > 0, y > 0 (top-right)\n- Quadrant 2: x < 0, y > 0 (top-left)\n- Quadrant 3: x < 0, y < 0 (bottom-left)\n- Quadrant 4: x > 0, y < 0 (bottom-right)\n\nExample:\n  getQuadrant(3, 5)    →  1\n  getQuadrant(-2, 4)   →  2\n  getQuadrant(0, 7)    →  0",
      "starterCode": "function getQuadrant(x, y) {\n  // Your code here\n\n}",
      "solution": "function getQuadrant(x, y) {\n  if (x === 0 || y === 0) return 0;\n  if (x > 0 && y > 0) return 1;\n  if (x < 0 && y > 0) return 2;\n  if (x < 0 && y < 0) return 3;\n  return 4;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return getQuadrant;')(); return [ { pass: fn(3, 5) === 1, description: 'getQuadrant(3, 5) → 1', got: fn(3, 5) }, { pass: fn(-2, 4) === 2, description: 'getQuadrant(-2, 4) → 2', got: fn(-2, 4) }, { pass: fn(-3, -7) === 3, description: 'getQuadrant(-3, -7) → 3', got: fn(-3, -7) }, { pass: fn(5, -1) === 4, description: 'getQuadrant(5, -1) → 4', got: fn(5, -1) }, { pass: fn(0, 7) === 0, description: 'getQuadrant(0, 7) → 0 (on y-axis)', got: fn(0, 7) }, { pass: fn(4, 0) === 0, description: 'getQuadrant(4, 0) → 0 (on x-axis)', got: fn(4, 0) }, { pass: fn(0, 0) === 0, description: 'getQuadrant(0, 0) → 0 (origin)', got: fn(0, 0) } ]; }",
      "hints": [
        "Check for the axis case first — if either x or y is 0, return 0.",
        "Use `&&` to combine two conditions for each quadrant.",
        "Think about which signs (positive/negative) x and y have in each quadrant."
      ],
      "resources": [
        {
          "label": "MDN: Logical AND (&&)",
          "url": "/docs/mdn/logical-and.html",
          "description": "Combining boolean conditions"
        },
        {
          "label": "MDN: if...else",
          "url": "/docs/mdn/if-else.html",
          "description": "Conditional branching in JavaScript"
        }
      ]
    },
    {
      "id": 674,
      "title": "Age Group Classifier",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "conditionals",
        "if-else",
        "ranges",
        "beginner"
      ],
      "description": "Classify a person into an age group based on their age.",
      "instructions": "Write a function called `ageGroup` that takes an age (number) and returns the life stage:\n\n- 0–2 → `\"baby\"`\n- 3–12 → `\"child\"`\n- 13–17 → `\"teenager\"`\n- 18–64 → `\"adult\"`\n- 65 and above → `\"senior\"`\n\nExample:\n  ageGroup(1)   →  \"baby\"\n  ageGroup(10)  →  \"child\"\n  ageGroup(25)  →  \"adult\"",
      "starterCode": "function ageGroup(age) {\n  // Your code here\n\n}",
      "solution": "function ageGroup(age) {\n  if (age <= 2) return \"baby\";\n  if (age <= 12) return \"child\";\n  if (age <= 17) return \"teenager\";\n  if (age <= 64) return \"adult\";\n  return \"senior\";\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return ageGroup;')(); return [ { pass: fn(1) === 'baby', description: 'ageGroup(1) → \"baby\"', got: fn(1) }, { pass: fn(0) === 'baby', description: 'ageGroup(0) → \"baby\"', got: fn(0) }, { pass: fn(10) === 'child', description: 'ageGroup(10) → \"child\"', got: fn(10) }, { pass: fn(15) === 'teenager', description: 'ageGroup(15) → \"teenager\"', got: fn(15) }, { pass: fn(25) === 'adult', description: 'ageGroup(25) → \"adult\"', got: fn(25) }, { pass: fn(65) === 'senior', description: 'ageGroup(65) → \"senior\"', got: fn(65) }, { pass: fn(2) === 'baby', description: 'ageGroup(2) → \"baby\" (boundary)', got: fn(2) }, { pass: fn(13) === 'teenager', description: 'ageGroup(13) → \"teenager\" (boundary)', got: fn(13) } ]; }",
      "hints": [
        "Use a chain of if/else statements, checking from youngest to oldest.",
        "With early returns, you don't need `else` — each `if` can just return.",
        "Boundary values: 2 is still a baby, 13 is a teenager, 65 is a senior."
      ],
      "resources": [
        {
          "label": "MDN: if...else",
          "url": "/docs/mdn/if-else.html",
          "description": "Conditional branching in JavaScript"
        },
        {
          "label": "MDN: Comparison operators",
          "url": "/docs/mdn/comparison.html",
          "description": "Greater than, less than, and equality operators"
        }
      ]
    },
    {
      "id": 675,
      "title": "Digit Extractor",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "operators",
        "math",
        "modulo",
        "division",
        "beginner"
      ],
      "description": "Extract specific digits from a number using math operators.",
      "instructions": "Write a function called `getDigit` that takes a positive integer `num` and a `position` (0-indexed from the right), and returns the digit at that position.\n\nPosition 0 = ones place, 1 = tens place, 2 = hundreds place, etc.\n\nIf the position is larger than the number of digits, return `0`.\n\nExample:\n  getDigit(7853, 0)  →  3  (ones)\n  getDigit(7853, 2)  →  8  (hundreds)\n  getDigit(7853, 5)  →  0  (out of range)",
      "starterCode": "function getDigit(num, position) {\n  // Your code here\n\n}",
      "solution": "function getDigit(num, position) {\n  return Math.floor(num / Math.pow(10, position)) % 10;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return getDigit;')(); return [ { pass: fn(7853, 0) === 3, description: 'getDigit(7853, 0) → 3 (ones)', got: fn(7853, 0) }, { pass: fn(7853, 1) === 5, description: 'getDigit(7853, 1) → 5 (tens)', got: fn(7853, 1) }, { pass: fn(7853, 2) === 8, description: 'getDigit(7853, 2) → 8 (hundreds)', got: fn(7853, 2) }, { pass: fn(7853, 3) === 7, description: 'getDigit(7853, 3) → 7 (thousands)', got: fn(7853, 3) }, { pass: fn(7853, 5) === 0, description: 'getDigit(7853, 5) → 0 (out of range)', got: fn(7853, 5) }, { pass: fn(100, 2) === 1, description: 'getDigit(100, 2) → 1', got: fn(100, 2) }, { pass: fn(5, 0) === 5, description: 'getDigit(5, 0) → 5', got: fn(5, 0) } ]; }",
      "hints": [
        "Dividing by 10^position shifts the digit you want into the ones place.",
        "`Math.floor()` removes the decimal part, and `% 10` isolates the last digit.",
        "`Math.pow(10, position)` gives you 10 raised to the given power."
      ],
      "resources": [
        {
          "label": "MDN: Math.floor()",
          "url": "/docs/mdn/math-floor.html",
          "description": "Rounds a number down to the nearest integer"
        },
        {
          "label": "MDN: Math.pow()",
          "url": "/docs/mdn/math-pow.html",
          "description": "Raises a number to a power"
        }
      ]
    },
    {
      "id": 676,
      "title": "Time Breakdown",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "operators",
        "math",
        "modulo",
        "objects",
        "beginner"
      ],
      "description": "Convert a total number of seconds into hours, minutes, and seconds.",
      "instructions": "Write a function called `breakdownTime` that takes a total number of seconds and returns an object with `hours`, `minutes`, and `seconds`.\n\nExample:\n  breakdownTime(3661)  →  { hours: 1, minutes: 1, seconds: 1 }\n  breakdownTime(90)    →  { hours: 0, minutes: 1, seconds: 30 }\n  breakdownTime(7200)  →  { hours: 2, minutes: 0, seconds: 0 }",
      "starterCode": "function breakdownTime(totalSeconds) {\n  // Your code here\n\n}",
      "solution": "function breakdownTime(totalSeconds) {\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n  return { hours, minutes, seconds };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return breakdownTime;')(); const r1 = fn(3661); const r2 = fn(90); const r3 = fn(7200); const r4 = fn(0); const r5 = fn(59); return [ { pass: r1.hours === 1 && r1.minutes === 1 && r1.seconds === 1, description: 'breakdownTime(3661) → {hours:1, minutes:1, seconds:1}', got: JSON.stringify(r1) }, { pass: r2.hours === 0 && r2.minutes === 1 && r2.seconds === 30, description: 'breakdownTime(90) → {hours:0, minutes:1, seconds:30}', got: JSON.stringify(r2) }, { pass: r3.hours === 2 && r3.minutes === 0 && r3.seconds === 0, description: 'breakdownTime(7200) → {hours:2, minutes:0, seconds:0}', got: JSON.stringify(r3) }, { pass: r4.hours === 0 && r4.minutes === 0 && r4.seconds === 0, description: 'breakdownTime(0) → {hours:0, minutes:0, seconds:0}', got: JSON.stringify(r4) }, { pass: r5.hours === 0 && r5.minutes === 0 && r5.seconds === 59, description: 'breakdownTime(59) → {hours:0, minutes:0, seconds:59}', got: JSON.stringify(r5) } ]; }",
      "hints": [
        "There are 3600 seconds in an hour and 60 seconds in a minute.",
        "Use `Math.floor()` for integer division and `%` for the remainder.",
        "After extracting hours, use the remainder to find minutes, then seconds."
      ],
      "resources": [
        {
          "label": "MDN: Remainder (%)",
          "url": "/docs/mdn/remainder.html",
          "description": "The modulo operator for extracting remainders"
        },
        {
          "label": "MDN: Math.floor()",
          "url": "/docs/mdn/math-floor.html",
          "description": "Rounds a number down to the nearest integer"
        }
      ]
    },
    {
      "id": 677,
      "title": "Coin Changer",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "operators",
        "math",
        "modulo",
        "greedy",
        "beginner"
      ],
      "description": "Make change using the fewest coins possible.",
      "instructions": "Write a function called `makeChange` that takes an amount in cents and returns an object showing the fewest coins needed.\n\nCoin values: quarter (25¢), dime (10¢), nickel (5¢), penny (1¢)\n\nExample:\n  makeChange(87)  →  { quarters: 3, dimes: 1, nickels: 0, pennies: 2 }\n  makeChange(41)  →  { quarters: 1, dimes: 1, nickels: 1, pennies: 1 }",
      "starterCode": "function makeChange(cents) {\n  // Your code here\n\n}",
      "solution": "function makeChange(cents) {\n  const quarters = Math.floor(cents / 25);\n  cents %= 25;\n  const dimes = Math.floor(cents / 10);\n  cents %= 10;\n  const nickels = Math.floor(cents / 5);\n  const pennies = cents % 5;\n  return { quarters, dimes, nickels, pennies };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return makeChange;')(); const r1 = fn(87); const r2 = fn(41); const r3 = fn(100); const r4 = fn(1); return [ { pass: r1.quarters === 3 && r1.dimes === 1 && r1.nickels === 0 && r1.pennies === 2, description: 'makeChange(87) → {quarters:3, dimes:1, nickels:0, pennies:2}', got: JSON.stringify(r1) }, { pass: r2.quarters === 1 && r2.dimes === 1 && r2.nickels === 1 && r2.pennies === 1, description: 'makeChange(41) → {quarters:1, dimes:1, nickels:1, pennies:1}', got: JSON.stringify(r2) }, { pass: r3.quarters === 4 && r3.dimes === 0 && r3.nickels === 0 && r3.pennies === 0, description: 'makeChange(100) → {quarters:4, dimes:0, nickels:0, pennies:0}', got: JSON.stringify(r3) }, { pass: r4.quarters === 0 && r4.dimes === 0 && r4.nickels === 0 && r4.pennies === 1, description: 'makeChange(1) → {quarters:0, dimes:0, nickels:0, pennies:1}', got: JSON.stringify(r4) } ]; }",
      "hints": [
        "Start with the largest coin (quarter) and work your way down.",
        "Use `Math.floor(cents / coinValue)` to get the count of each coin.",
        "After counting each coin, update the remaining cents with `%`."
      ],
      "resources": [
        {
          "label": "MDN: Math.floor()",
          "url": "/docs/mdn/math-floor.html",
          "description": "Rounds down to the nearest integer"
        },
        {
          "label": "MDN: Arithmetic operators",
          "url": "/docs/mdn/arithmetic.html",
          "description": "All math operators including modulo (%)"
        }
      ]
    },
    {
      "id": 680,
      "title": "Number Grid",
      "type": "js",
      "tier": 3,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "nested-loops",
        "strings",
        "intermediate"
      ],
      "description": "Generate a formatted grid of numbers using nested loops.",
      "instructions": "Write a function called `numberGrid` that takes a number `n` and returns a string representing an n×n grid where each cell contains its row number (1-based).\n\nEach number should be separated by a space, and each row on a new line. No trailing spaces.\n\nExample:\n  numberGrid(3) →\n  \"1 1 1\\n2 2 2\\n3 3 3\"\n\n  numberGrid(4) →\n  \"1 1 1 1\\n2 2 2 2\\n3 3 3 3\\n4 4 4 4\"",
      "starterCode": "function numberGrid(n) {\n  // Build the grid string\n\n}",
      "solution": "function numberGrid(n) {\n  const rows = [];\n  for (let i = 1; i <= n; i++) {\n    rows.push(Array(n).fill(i).join(' '));\n  }\n  return rows.join('\\n');\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return numberGrid;')(); return [ { pass: fn(3) === '1 1 1\\n2 2 2\\n3 3 3', description: 'numberGrid(3) produces a 3x3 grid', got: fn(3) }, { pass: fn(1) === '1', description: 'numberGrid(1) → \"1\"', got: fn(1) }, { pass: fn(4) === '1 1 1 1\\n2 2 2 2\\n3 3 3 3\\n4 4 4 4', description: 'numberGrid(4) produces a 4x4 grid', got: fn(4) }, { pass: fn(2) === '1 1\\n2 2', description: 'numberGrid(2) produces a 2x2 grid', got: fn(2) } ]; }",
      "hints": [
        "Use an outer loop for rows and an inner loop (or Array.fill) for columns.",
        "Join cells in a row with spaces and rows with newline characters.",
        "The row number (1-based) is repeated `n` times in each row."
      ],
      "resources": [
        {
          "label": "MDN: Array.fill()",
          "url": "/docs/mdn/array-fill.html",
          "description": "Fills an array with a static value"
        },
        {
          "label": "MDN: Array.join()",
          "url": "/docs/mdn/array-join.html",
          "description": "Joins array elements into a string"
        }
      ]
    },
    {
      "id": 681,
      "title": "Receipt Formatter",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literals",
        "string-formatting",
        "es6",
        "beginner"
      ],
      "description": "Format a simple receipt string using template literals.",
      "instructions": "Write a function called `formatReceipt` that takes an array of item objects (each with `name` and `price`) and returns a formatted receipt string.\n\nEach item should be on its own line as: `\"  item_name: $price\"`\nThe last line should show the total.\n\nExample:\n  formatReceipt([{name: 'Apple', price: 1.50}, {name: 'Bread', price: 3.00}])\n  →  \"  Apple: $1.50\\n  Bread: $3.00\\n  Total: $4.50\"",
      "starterCode": "function formatReceipt(items) {\n  // Your code here\n\n}",
      "solution": "function formatReceipt(items) {\n  const lines = items.map(item => `  ${item.name}: $${item.price.toFixed(2)}`);\n  const total = items.reduce((sum, item) => sum + item.price, 0);\n  lines.push(`  Total: $${total.toFixed(2)}`);\n  return lines.join('\\n');\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return formatReceipt;')(); const r1 = fn([{name: 'Apple', price: 1.50}, {name: 'Bread', price: 3.00}]); const r2 = fn([{name: 'Milk', price: 2.99}]); const r3 = fn([{name: 'A', price: 1}, {name: 'B', price: 2}, {name: 'C', price: 3}]); return [ { pass: r1 === '  Apple: $1.50\\n  Bread: $3.00\\n  Total: $4.50', description: 'Formats a 2-item receipt correctly', got: r1 }, { pass: r2 === '  Milk: $2.99\\n  Total: $2.99', description: 'Formats a single-item receipt', got: r2 }, { pass: r3.includes('Total: $6.00'), description: 'Calculates correct total for 3 items', got: r3 } ]; }",
      "hints": [
        "Use `.map()` to create a formatted string for each item.",
        "Template literals use backticks and `${}` for embedding expressions.",
        "Use `.toFixed(2)` to ensure prices always show 2 decimal places."
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: Number.toFixed()",
          "url": "/docs/mdn/number-tofixed.html",
          "description": "Formatting numbers with fixed decimal places"
        }
      ]
    },
    {
      "id": 682,
      "title": "HTML Tag Builder",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literals",
        "html",
        "strings",
        "beginner"
      ],
      "description": "Generate HTML strings using template literals.",
      "instructions": "Write a function called `buildTag` that takes a tag name, content, and an optional className, and returns an HTML string.\n\n- If `className` is provided: `<tag class=\"className\">content</tag>`\n- If no `className`: `<tag>content</tag>`\n\nExample:\n  buildTag('p', 'Hello')           →  '<p>Hello</p>'\n  buildTag('div', 'Hi', 'card')    →  '<div class=\"card\">Hi</div>'\n  buildTag('h1', 'Title', 'big')   →  '<h1 class=\"big\">Title</h1>'",
      "starterCode": "function buildTag(tag, content, className) {\n  // Your code here\n\n}",
      "solution": "function buildTag(tag, content, className) {\n  const classAttr = className ? ` class=\"${className}\"` : '';\n  return `<${tag}${classAttr}>${content}</${tag}>`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return buildTag;')(); return [ { pass: fn('p', 'Hello') === '<p>Hello</p>', description: 'buildTag(\"p\", \"Hello\") → <p>Hello</p>', got: fn('p', 'Hello') }, { pass: fn('div', 'Hi', 'card') === '<div class=\"card\">Hi</div>', description: 'buildTag(\"div\", \"Hi\", \"card\") adds class', got: fn('div', 'Hi', 'card') }, { pass: fn('h1', 'Title', 'big') === '<h1 class=\"big\">Title</h1>', description: 'buildTag(\"h1\", \"Title\", \"big\") → correct', got: fn('h1', 'Title', 'big') }, { pass: fn('span', 'text') === '<span>text</span>', description: 'buildTag(\"span\", \"text\") → no class attr', got: fn('span', 'text') } ]; }",
      "hints": [
        "Use a conditional (ternary or if) to build the class attribute string.",
        "Template literals make it easy to embed variables inside the HTML string.",
        "When className is undefined, the class attribute should not appear at all."
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "Inline conditional expressions"
        }
      ]
    },
    {
      "id": 683,
      "title": "Greeting Builder",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literals",
        "conditionals",
        "strings",
        "beginner"
      ],
      "description": "Build personalized greeting messages using template literals.",
      "instructions": "Write a function called `timeGreeting` that takes a `name` and an `hour` (0–23) and returns a greeting string.\n\n- Hours 5–11: `\"Good morning, {name}!\"`\n- Hours 12–17: `\"Good afternoon, {name}!\"`\n- Hours 18–21: `\"Good evening, {name}!\"`\n- Hours 22–4: `\"Good night, {name}!\"`\n\nExample:\n  timeGreeting('Alice', 9)   →  \"Good morning, Alice!\"\n  timeGreeting('Bob', 14)    →  \"Good afternoon, Bob!\"\n  timeGreeting('Eve', 23)    →  \"Good night, Eve!\"",
      "starterCode": "function timeGreeting(name, hour) {\n  // Your code here\n\n}",
      "solution": "function timeGreeting(name, hour) {\n  let period;\n  if (hour >= 5 && hour <= 11) period = 'morning';\n  else if (hour >= 12 && hour <= 17) period = 'afternoon';\n  else if (hour >= 18 && hour <= 21) period = 'evening';\n  else period = 'night';\n  return `Good ${period}, ${name}!`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return timeGreeting;')(); return [ { pass: fn('Alice', 9) === 'Good morning, Alice!', description: 'timeGreeting(\"Alice\", 9) → morning', got: fn('Alice', 9) }, { pass: fn('Bob', 14) === 'Good afternoon, Bob!', description: 'timeGreeting(\"Bob\", 14) → afternoon', got: fn('Bob', 14) }, { pass: fn('Eve', 20) === 'Good evening, Eve!', description: 'timeGreeting(\"Eve\", 20) → evening', got: fn('Eve', 20) }, { pass: fn('Zara', 23) === 'Good night, Zara!', description: 'timeGreeting(\"Zara\", 23) → night', got: fn('Zara', 23) }, { pass: fn('Max', 3) === 'Good night, Max!', description: 'timeGreeting(\"Max\", 3) → night (early morning)', got: fn('Max', 3) }, { pass: fn('Jo', 12) === 'Good afternoon, Jo!', description: 'timeGreeting(\"Jo\", 12) → afternoon (boundary)', got: fn('Jo', 12) } ]; }",
      "hints": [
        "First determine the time period with if/else, then embed it in a template literal.",
        "Template literals: `Good ${period}, ${name}!`",
        "Night covers both late evening (22-23) and early morning (0-4)."
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "A shorthand for if/else"
        }
      ]
    },
    {
      "id": 684,
      "title": "Table Row Generator",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literals",
        "html",
        "arrays",
        "beginner"
      ],
      "description": "Generate HTML table rows from arrays of data.",
      "instructions": "Write a function called `buildTableRow` that takes an array of cell values and returns an HTML table row string.\n\nEach value should be wrapped in `<td>` tags, and the whole row in `<tr>` tags.\n\nExample:\n  buildTableRow(['Alice', 25, 'NY'])\n  →  '<tr><td>Alice</td><td>25</td><td>NY</td></tr>'\n\n  buildTableRow([1, 2, 3])\n  →  '<tr><td>1</td><td>2</td><td>3</td></tr>'",
      "starterCode": "function buildTableRow(cells) {\n  // Your code here\n\n}",
      "solution": "function buildTableRow(cells) {\n  const tds = cells.map(cell => `<td>${cell}</td>`).join('');\n  return `<tr>${tds}</tr>`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return buildTableRow;')(); return [ { pass: fn(['Alice', 25, 'NY']) === '<tr><td>Alice</td><td>25</td><td>NY</td></tr>', description: 'buildTableRow([\"Alice\", 25, \"NY\"]) formats correctly', got: fn(['Alice', 25, 'NY']) }, { pass: fn([1, 2, 3]) === '<tr><td>1</td><td>2</td><td>3</td></tr>', description: 'buildTableRow([1, 2, 3]) works with numbers', got: fn([1, 2, 3]) }, { pass: fn(['solo']) === '<tr><td>solo</td></tr>', description: 'buildTableRow([\"solo\"]) works with single cell', got: fn(['solo']) } ]; }",
      "hints": [
        "Use `.map()` to wrap each cell value in `<td>` tags.",
        "Use `.join('')` to combine the cells with no separator.",
        "Wrap everything in `<tr>` tags using a template literal."
      ],
      "resources": [
        {
          "label": "MDN: Array.map()",
          "url": "/docs/mdn/array-map.html",
          "description": "Transform each element of an array"
        },
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        }
      ]
    },
    {
      "id": 685,
      "title": "Swap with Destructuring",
      "type": "js",
      "tier": 1,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "destructuring",
        "es6",
        "variables",
        "beginner"
      ],
      "description": "Use array destructuring to swap two values.",
      "instructions": "Complete the function `swap` that takes an array of two elements and returns a new array with the elements swapped.\n\nUse array destructuring assignment to perform the swap.\n\nExample:\n  swap([1, 2])         →  [2, 1]\n  swap(['a', 'b'])     →  ['b', 'a']\n  swap([true, false])  →  [false, true]",
      "starterCode": "function swap(arr) {\n  let [a, b] = arr;\n  // Swap a and b using destructuring\n  ___;\n  return [a, b];\n}",
      "solution": "function swap(arr) {\n  let [a, b] = arr;\n  [a, b] = [b, a];\n  return [a, b];\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return swap;')(); const r1 = fn([1, 2]); const r2 = fn(['a', 'b']); const r3 = fn([true, false]); return [ { pass: r1[0] === 2 && r1[1] === 1, description: 'swap([1, 2]) → [2, 1]', got: JSON.stringify(r1) }, { pass: r2[0] === 'b' && r2[1] === 'a', description: 'swap([\"a\", \"b\"]) → [\"b\", \"a\"]', got: JSON.stringify(r2) }, { pass: r3[0] === false && r3[1] === true, description: 'swap([true, false]) → [false, true]', got: JSON.stringify(r3) } ]; }",
      "hints": [
        "Array destructuring can swap in one line: `[a, b] = [b, a]`",
        "The right side creates a new temporary array before assigning.",
        "No need for a temporary variable when using destructuring swap!"
      ],
      "resources": [
        {
          "label": "MDN: Destructuring assignment",
          "url": "/docs/mdn/destructuring.html",
          "description": "Unpacking values from arrays and objects"
        },
        {
          "label": "MDN: Array destructuring",
          "url": "/docs/mdn/array-destructuring.html",
          "description": "Swapping values and unpacking arrays"
        }
      ]
    },
    {
      "id": 686,
      "title": "Config Extractor",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "destructuring",
        "objects",
        "nested",
        "es6",
        "intermediate"
      ],
      "description": "Extract deeply nested values using object destructuring.",
      "instructions": "Write a function called `getDbConfig` that takes a config object and uses nested destructuring to extract and return the database host, port, and name.\n\nThe config structure:\n```\n{\n  app: { name: '...', version: '...' },\n  database: { host: '...', port: ..., name: '...' }\n}\n```\n\nReturn an object: `{ host, port, name }`\n\nExample:\n  getDbConfig({ app: { name: 'MyApp', version: '1.0' }, database: { host: 'localhost', port: 5432, name: 'mydb' } })\n  →  { host: 'localhost', port: 5432, name: 'mydb' }",
      "starterCode": "function getDbConfig(config) {\n  // Use destructuring to extract database properties\n\n}",
      "solution": "function getDbConfig(config) {\n  const { database: { host, port, name } } = config;\n  return { host, port, name };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return getDbConfig;')(); const r1 = fn({ app: { name: 'MyApp', version: '1.0' }, database: { host: 'localhost', port: 5432, name: 'mydb' } }); const r2 = fn({ app: { name: 'Test' }, database: { host: '192.168.1.1', port: 3306, name: 'testdb' } }); return [ { pass: r1.host === 'localhost' && r1.port === 5432 && r1.name === 'mydb', description: 'Extracts localhost:5432/mydb correctly', got: JSON.stringify(r1) }, { pass: r2.host === '192.168.1.1' && r2.port === 3306 && r2.name === 'testdb', description: 'Extracts 192.168.1.1:3306/testdb correctly', got: JSON.stringify(r2) }, { pass: Object.keys(r1).length === 3, description: 'Returns object with exactly 3 keys', got: Object.keys(r1).length } ]; }",
      "hints": [
        "Nested destructuring: `const { database: { host, port, name } } = config;`",
        "The colon in destructuring means 'go deeper', not 'rename'.",
        "Use shorthand property names when returning: `{ host, port, name }`"
      ],
      "resources": [
        {
          "label": "MDN: Destructuring assignment",
          "url": "/docs/mdn/destructuring.html",
          "description": "Unpacking values from arrays and objects"
        },
        {
          "label": "MDN: Default values",
          "url": "/docs/mdn/default-parameters.html",
          "description": "Setting default values for function parameters"
        }
      ]
    },
    {
      "id": 687,
      "title": "Rest Collector",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "destructuring",
        "rest",
        "es6",
        "intermediate"
      ],
      "description": "Use the rest pattern to collect remaining elements.",
      "instructions": "Write a function called `headAndTail` that takes an array and returns an object with `head` (the first element) and `tail` (an array of remaining elements).\n\nUse array destructuring with the rest operator.\n\nExample:\n  headAndTail([1, 2, 3, 4])    →  { head: 1, tail: [2, 3, 4] }\n  headAndTail(['a'])            →  { head: 'a', tail: [] }\n  headAndTail([10, 20])         →  { head: 10, tail: [20] }",
      "starterCode": "function headAndTail(arr) {\n  // Use destructuring with rest\n\n}",
      "solution": "function headAndTail(arr) {\n  const [head, ...tail] = arr;\n  return { head, tail };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return headAndTail;')(); const r1 = fn([1, 2, 3, 4]); const r2 = fn(['a']); const r3 = fn([10, 20]); return [ { pass: r1.head === 1 && JSON.stringify(r1.tail) === '[2,3,4]', description: 'headAndTail([1,2,3,4]) → {head:1, tail:[2,3,4]}', got: JSON.stringify(r1) }, { pass: r2.head === 'a' && r2.tail.length === 0, description: 'headAndTail([\"a\"]) → {head:\"a\", tail:[]}', got: JSON.stringify(r2) }, { pass: r3.head === 10 && r3.tail[0] === 20, description: 'headAndTail([10, 20]) → {head:10, tail:[20]}', got: JSON.stringify(r3) } ]; }",
      "hints": [
        "The rest syntax `...tail` collects all remaining elements into an array.",
        "Destructure like: `const [head, ...tail] = arr;`",
        "If there's only one element, `tail` will be an empty array `[]`."
      ],
      "resources": [
        {
          "label": "MDN: Rest parameters",
          "url": "/docs/mdn/rest-parameters.html",
          "description": "Collecting remaining elements with ..."
        },
        {
          "label": "MDN: Destructuring assignment",
          "url": "/docs/mdn/destructuring.html",
          "description": "Unpacking values from arrays and objects"
        }
      ]
    },
    {
      "id": 689,
      "title": "Event Dispatcher",
      "type": "js",
      "tier": 3,
      "category": [
        "functions",
        "callbacks"
      ],
      "tags": [
        "callbacks",
        "events",
        "objects",
        "intermediate"
      ],
      "description": "Build a simple event system using callbacks.",
      "instructions": "Write a function called `createDispatcher` that returns an object with two methods:\n\n- `on(callback)` — registers a callback\n- `emit(data)` — calls all registered callbacks with the given data\n\nExample:\n  const d = createDispatcher();\n  const results = [];\n  d.on(val => results.push(val));\n  d.on(val => results.push(val * 10));\n  d.emit(5);\n  // results is [5, 50]",
      "starterCode": "function createDispatcher() {\n  // Your code here\n\n}",
      "solution": "function createDispatcher() {\n  const listeners = [];\n  return {\n    on(callback) {\n      listeners.push(callback);\n    },\n    emit(data) {\n      listeners.forEach(cb => cb(data));\n    }\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return createDispatcher;')(); const d1 = fn(); const r1 = []; d1.on(v => r1.push(v)); d1.on(v => r1.push(v * 10)); d1.emit(5); const d2 = fn(); const r2 = []; d2.on(v => r2.push(v.toUpperCase())); d2.emit('hi'); d2.emit('bye'); return [ { pass: JSON.stringify(r1) === '[5,50]', description: 'Two listeners receive emit(5)', got: JSON.stringify(r1) }, { pass: JSON.stringify(r2) === '[\"HI\",\"BYE\"]', description: 'String listener called on multiple emits', got: JSON.stringify(r2) }, { pass: typeof d1.on === 'function' && typeof d1.emit === 'function', description: 'Returns object with on and emit methods', got: `on: ${typeof d1.on}, emit: ${typeof d1.emit}` } ]; }",
      "hints": [
        "Use a closure to store an array of registered callbacks.",
        "`on()` should push the callback into the array.",
        "`emit()` should loop through the array and call each callback with the data."
      ],
      "resources": [
        {
          "label": "MDN: Closures",
          "url": "/docs/mdn/closures.html",
          "description": "Functions that remember their scope"
        },
        {
          "label": "MDN: Array.forEach()",
          "url": "/docs/mdn/array-foreach.html",
          "description": "Running a function on each array element"
        }
      ]
    },
    {
      "id": 690,
      "title": "Compose Functions",
      "type": "js",
      "tier": 3,
      "category": [
        "functions",
        "higher-order"
      ],
      "tags": [
        "higher-order",
        "compose",
        "functional",
        "advanced"
      ],
      "description": "Create a function that composes multiple functions together.",
      "instructions": "Write a function called `composeAll` that takes any number of functions and returns a new function that applies them from right to left.\n\nThe rightmost function receives the input, and each subsequent function receives the result of the previous one.\n\nExample:\n  const double = x => x * 2;\n  const addOne = x => x + 1;\n  const square = x => x * x;\n\n  const transform = composeAll(addOne, double);\n  transform(3)  →  7  (double(3)=6, addOne(6)=7)\n\n  const calc = composeAll(double, addOne, square);\n  calc(3)  →  20  (square(3)=9, addOne(9)=10, double(10)=20)",
      "starterCode": "function composeAll(...fns) {\n  // Return a new function that applies fns right-to-left\n\n}",
      "solution": "function composeAll(...fns) {\n  return function(x) {\n    return fns.reduceRight((acc, fn) => fn(acc), x);\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return composeAll;')(); const double = x => x * 2; const addOne = x => x + 1; const square = x => x * x; const t1 = fn(addOne, double); const t2 = fn(double, addOne, square); const t3 = fn(x => x.toUpperCase(), x => x + '!'); return [ { pass: t1(3) === 7, description: 'composeAll(addOne, double)(3) → 7', got: t1(3) }, { pass: t2(3) === 20, description: 'composeAll(double, addOne, square)(3) → 20', got: t2(3) }, { pass: t3('hi') === 'HI!', description: 'composeAll(upper, addBang)(\"hi\") → \"HI!\"', got: t3('hi') }, { pass: fn(addOne)(5) === 6, description: 'Single function composeAll works', got: fn(addOne)(5) } ]; }",
      "hints": [
        "Use the rest operator `...fns` to collect all function arguments.",
        "`reduceRight` processes an array from right to left — perfect for composition.",
        "The accumulator starts as the input value and gets transformed by each function."
      ],
      "resources": [
        {
          "label": "MDN: Array.reduceRight()",
          "url": "/docs/mdn/array-reduceright.html",
          "description": "Reduces an array from right to left"
        },
        {
          "label": "MDN: Rest parameters",
          "url": "/docs/mdn/rest-parameters.html",
          "description": "Collecting remaining arguments with ..."
        }
      ]
    },
    {
      "id": 693,
      "title": "Inventory Tracker",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "objects",
        "methods",
        "state",
        "intermediate"
      ],
      "description": "Build an inventory management system using objects.",
      "instructions": "Write a function called `createInventory` that returns an object with these methods:\n\n- `add(item, quantity)` — adds quantity to the item (creates it if new)\n- `remove(item, quantity)` — removes quantity (don't go below 0)\n- `getStock(item)` — returns the quantity (0 if item doesn't exist)\n- `getItems()` — returns an array of all item names\n\nExample:\n  const inv = createInventory();\n  inv.add('apples', 10);\n  inv.add('apples', 5);\n  inv.getStock('apples')   →  15\n  inv.remove('apples', 3);\n  inv.getStock('apples')   →  12\n  inv.getItems()           →  ['apples']",
      "starterCode": "function createInventory() {\n  // Your code here\n\n}",
      "solution": "function createInventory() {\n  const stock = {};\n  return {\n    add(item, quantity) {\n      stock[item] = (stock[item] || 0) + quantity;\n    },\n    remove(item, quantity) {\n      if (stock[item]) {\n        stock[item] = Math.max(0, stock[item] - quantity);\n      }\n    },\n    getStock(item) {\n      return stock[item] || 0;\n    },\n    getItems() {\n      return Object.keys(stock);\n    }\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return createInventory;')(); const inv = fn(); inv.add('apples', 10); inv.add('apples', 5); inv.add('bread', 3); const s1 = inv.getStock('apples'); inv.remove('apples', 3); const s2 = inv.getStock('apples'); inv.remove('bread', 10); const s3 = inv.getStock('bread'); const s4 = inv.getStock('milk'); return [ { pass: s1 === 15, description: 'add(\"apples\", 10) then add(\"apples\", 5) → stock is 15', got: s1 }, { pass: s2 === 12, description: 'remove(\"apples\", 3) → stock drops to 12', got: s2 }, { pass: s3 === 0, description: 'Removing more than stock gives 0, not negative', got: s3 }, { pass: s4 === 0, description: 'getStock of non-existent item returns 0', got: s4 }, { pass: inv.getItems().includes('apples') && inv.getItems().includes('bread'), description: 'getItems() returns all item names', got: JSON.stringify(inv.getItems()) } ]; }",
      "hints": [
        "Use a closure to store the inventory object privately.",
        "`stock[item] = (stock[item] || 0) + quantity` handles both new and existing items.",
        "Use `Math.max(0, ...)` to prevent negative quantities."
      ],
      "resources": [
        {
          "label": "MDN: Object.keys()",
          "url": "/docs/mdn/object-keys.html",
          "description": "Getting all keys of an object"
        },
        {
          "label": "MDN: Closures",
          "url": "/docs/mdn/closures.html",
          "description": "Functions that remember their scope"
        }
      ]
    },
    {
      "id": 694,
      "title": "Student Gradebook",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "objects",
        "arrays",
        "math",
        "intermediate"
      ],
      "description": "Manage student grades and calculate averages.",
      "instructions": "Write a function called `createGradebook` that returns an object with these methods:\n\n- `addGrade(student, grade)` — records a grade for the student\n- `getAverage(student)` — returns the average of all grades for that student (rounded to 1 decimal), or `null` if student has no grades\n- `getTopStudent()` — returns the name of the student with the highest average\n\nExample:\n  const gb = createGradebook();\n  gb.addGrade('Alice', 90);\n  gb.addGrade('Alice', 80);\n  gb.addGrade('Bob', 95);\n  gb.getAverage('Alice')   →  85.0\n  gb.getTopStudent()       →  'Bob'",
      "starterCode": "function createGradebook() {\n  // Your code here\n\n}",
      "solution": "function createGradebook() {\n  const grades = {};\n  return {\n    addGrade(student, grade) {\n      if (!grades[student]) grades[student] = [];\n      grades[student].push(grade);\n    },\n    getAverage(student) {\n      if (!grades[student] || grades[student].length === 0) return null;\n      const sum = grades[student].reduce((a, b) => a + b, 0);\n      return Math.round((sum / grades[student].length) * 10) / 10;\n    },\n    getTopStudent() {\n      let top = null;\n      let best = -1;\n      for (const student of Object.keys(grades)) {\n        const avg = this.getAverage(student);\n        if (avg > best) {\n          best = avg;\n          top = student;\n        }\n      }\n      return top;\n    }\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return createGradebook;')(); const gb = fn(); gb.addGrade('Alice', 90); gb.addGrade('Alice', 80); gb.addGrade('Bob', 95); gb.addGrade('Bob', 85); gb.addGrade('Carol', 100); return [ { pass: gb.getAverage('Alice') === 85, description: 'Alice avg: (90+80)/2 = 85', got: gb.getAverage('Alice') }, { pass: gb.getAverage('Bob') === 90, description: 'Bob avg: (95+85)/2 = 90', got: gb.getAverage('Bob') }, { pass: gb.getTopStudent() === 'Carol', description: 'Top student is Carol (avg 100)', got: gb.getTopStudent() }, { pass: gb.getAverage('Unknown') === null, description: 'Unknown student returns null', got: gb.getAverage('Unknown') } ]; }",
      "hints": [
        "Store grades as an object where keys are student names and values are arrays of grades.",
        "Calculate average: sum all grades with `.reduce()`, then divide by array length.",
        "For `getTopStudent`, loop through all students and track the highest average."
      ],
      "resources": [
        {
          "label": "MDN: Array.reduce()",
          "url": "/docs/mdn/array-reduce.html",
          "description": "Reducing an array to a single value"
        },
        {
          "label": "MDN: Object.keys()",
          "url": "/docs/mdn/object-keys.html",
          "description": "Getting all keys of an object"
        }
      ]
    },
    {
      "id": 695,
      "title": "Phonebook",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "objects",
        "crud",
        "methods",
        "beginner"
      ],
      "description": "Build a phonebook using an object to store contacts.",
      "instructions": "Write a function called `createPhonebook` that returns an object with these methods:\n\n- `add(name, number)` — adds or updates a contact\n- `lookup(name)` — returns the number, or `\"Contact not found\"` if missing\n- `remove(name)` — deletes a contact\n- `listAll()` — returns an array of strings like `\"Name: Number\"`\n\nExample:\n  const pb = createPhonebook();\n  pb.add('Alice', '555-1234');\n  pb.lookup('Alice')    →  '555-1234'\n  pb.lookup('Bob')      →  'Contact not found'\n  pb.listAll()          →  ['Alice: 555-1234']",
      "starterCode": "function createPhonebook() {\n  // Your code here\n\n}",
      "solution": "function createPhonebook() {\n  const contacts = {};\n  return {\n    add(name, number) {\n      contacts[name] = number;\n    },\n    lookup(name) {\n      return contacts[name] || 'Contact not found';\n    },\n    remove(name) {\n      delete contacts[name];\n    },\n    listAll() {\n      return Object.entries(contacts).map(([name, num]) => `${name}: ${num}`);\n    }\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return createPhonebook;')(); const pb = fn(); pb.add('Alice', '555-1234'); pb.add('Bob', '555-5678'); const r1 = pb.lookup('Alice'); const r2 = pb.lookup('Charlie'); pb.remove('Bob'); const r3 = pb.lookup('Bob'); const r4 = pb.listAll(); return [ { pass: r1 === '555-1234', description: 'lookup(\"Alice\") → \"555-1234\"', got: r1 }, { pass: r2 === 'Contact not found', description: 'lookup(\"Charlie\") → \"Contact not found\"', got: r2 }, { pass: r3 === 'Contact not found', description: 'After remove, lookup returns not found', got: r3 }, { pass: r4.length === 1 && r4[0] === 'Alice: 555-1234', description: 'listAll() returns remaining contacts', got: JSON.stringify(r4) } ]; }",
      "hints": [
        "Use a plain object to store contacts as key-value pairs.",
        "The `delete` operator removes a property from an object.",
        "`Object.entries()` returns [key, value] pairs for easy formatting."
      ],
      "resources": [
        {
          "label": "MDN: delete operator",
          "url": "/docs/mdn/delete.html",
          "description": "Removing properties from objects"
        },
        {
          "label": "MDN: Object.entries()",
          "url": "/docs/mdn/object-entries.html",
          "description": "Getting key-value pairs from an object"
        }
      ]
    },
    {
      "id": 696,
      "title": "Number Formatter",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "formatting",
        "loops",
        "intermediate"
      ],
      "description": "Format a number with comma separators for thousands.",
      "instructions": "Write a function called `addCommas` that takes a non-negative integer and returns a string with commas inserted every three digits from the right.\n\nExample:\n  addCommas(1234567)  →  \"1,234,567\"\n  addCommas(1000)     →  \"1,000\"\n  addCommas(42)       →  \"42\"\n  addCommas(0)        →  \"0\"",
      "starterCode": "function addCommas(num) {\n  // Your code here\n\n}",
      "solution": "function addCommas(num) {\n  const str = String(num);\n  const result = [];\n  for (let i = str.length - 1, count = 0; i >= 0; i--, count++) {\n    if (count > 0 && count % 3 === 0) result.unshift(',');\n    result.unshift(str[i]);\n  }\n  return result.join('');\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return addCommas;')(); return [ { pass: fn(1234567) === '1,234,567', description: 'addCommas(1234567) → \"1,234,567\"', got: fn(1234567) }, { pass: fn(1000) === '1,000', description: 'addCommas(1000) → \"1,000\"', got: fn(1000) }, { pass: fn(42) === '42', description: 'addCommas(42) → \"42\"', got: fn(42) }, { pass: fn(0) === '0', description: 'addCommas(0) → \"0\"', got: fn(0) }, { pass: fn(1000000) === '1,000,000', description: 'addCommas(1000000) → \"1,000,000\"', got: fn(1000000) }, { pass: fn(999) === '999', description: 'addCommas(999) → \"999\"', got: fn(999) } ]; }",
      "hints": [
        "Convert the number to a string first, then work from right to left.",
        "Insert a comma every 3 digits from the right.",
        "You can build the result backwards using `.unshift()` or reverse at the end."
      ],
      "resources": [
        {
          "label": "MDN: String()",
          "url": "/docs/mdn/string.html",
          "description": "Converting values to strings"
        },
        {
          "label": "MDN: Array.unshift()",
          "url": "/docs/mdn/array-unshift.html",
          "description": "Adding elements to the beginning of an array"
        }
      ]
    },
    {
      "id": 700,
      "title": "Find Peak Element",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "searching"
      ],
      "tags": [
        "searching",
        "arrays",
        "binary-search",
        "intermediate"
      ],
      "description": "Find an element that is greater than its neighbors.",
      "instructions": "Write a function called `findPeak` that takes an array of numbers and returns the index of any peak element.\n\nA peak element is one that is strictly greater than its neighbors. The first and last elements only need to be greater than their single neighbor.\n\nYou may assume the array has at least one element and that no two adjacent elements are equal.\n\nExample:\n  findPeak([1, 3, 2])        →  1  (3 > 1 and 3 > 2)\n  findPeak([1, 2, 3, 1])     →  2  (3 is the peak)\n  findPeak([5, 1, 2])        →  0  (5 > 1, and it's the first element)",
      "starterCode": "function findPeak(arr) {\n  // Find any peak element and return its index\n\n}",
      "solution": "function findPeak(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    const left = i === 0 || arr[i] > arr[i - 1];\n    const right = i === arr.length - 1 || arr[i] > arr[i + 1];\n    if (left && right) return i;\n  }\n  return -1;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return findPeak;')(); const r1 = fn([1, 3, 2]); const r2 = fn([1, 2, 3, 1]); const r3 = fn([5, 1, 2]); const r4 = fn([1, 2, 3]); const a4 = [1, 2, 3]; const r5 = fn([7]); return [ { pass: r1 === 1, description: 'findPeak([1,3,2]) → 1', got: r1 }, { pass: r2 === 2, description: 'findPeak([1,2,3,1]) → 2', got: r2 }, { pass: r3 === 0 || r3 === 2, description: 'findPeak([5,1,2]) returns a valid peak', got: r3 }, { pass: r4 === 2, description: 'findPeak([1,2,3]) → 2 (last element)', got: r4 }, { pass: r5 === 0, description: 'findPeak([7]) → 0 (single element)', got: r5 } ]; }",
      "hints": [
        "A peak element is greater than both its left and right neighbors.",
        "Edge elements only have one neighbor to check.",
        "You can use a simple loop — check if each element is a peak."
      ],
      "resources": [
        {
          "label": "MDN: Comparison operators",
          "url": "/docs/mdn/comparison.html",
          "description": "Greater than, less than operators"
        },
        {
          "label": "MDN: Array iteration methods",
          "url": "/docs/mdn/array-iteration.html",
          "description": "Overview of map, filter, reduce, and more"
        }
      ]
    },
    {
      "id": 701,
      "title": "Private Counter",
      "type": "js",
      "tier": 2,
      "category": [
        "functions",
        "scope"
      ],
      "tags": [
        "closures",
        "scope",
        "encapsulation",
        "intermediate"
      ],
      "description": "Use closures to create a counter with private state.",
      "instructions": "Write a function called `createCounter` that takes an optional starting value (default 0) and returns an object with three methods:\n\n- `increment()` — increases the count by 1 and returns the new value\n- `decrement()` — decreases the count by 1 and returns the new value\n- `getValue()` — returns the current count\n\nThe count should not be directly accessible from outside.\n\nExample:\n  const counter = createCounter(10);\n  counter.increment()   →  11\n  counter.increment()   →  12\n  counter.decrement()   →  11\n  counter.getValue()    →  11",
      "starterCode": "function createCounter(start) {\n  // Your code here\n\n}",
      "solution": "function createCounter(start = 0) {\n  let count = start;\n  return {\n    increment() { return ++count; },\n    decrement() { return --count; },\n    getValue() { return count; }\n  };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return createCounter;')(); const c1 = fn(10); const r1 = c1.increment(); const r2 = c1.increment(); const r3 = c1.decrement(); const c2 = fn(); return [ { pass: r1 === 11, description: 'increment() from 10 → 11', got: r1 }, { pass: r2 === 12, description: 'increment() again → 12', got: r2 }, { pass: r3 === 11, description: 'decrement() → 11', got: r3 }, { pass: c1.getValue() === 11, description: 'getValue() returns current count', got: c1.getValue() }, { pass: c2.getValue() === 0, description: 'Default start is 0', got: c2.getValue() }, { pass: c2.count === undefined, description: 'count is not directly accessible', got: c2.count } ]; }",
      "hints": [
        "Use a closure: define `count` inside the function and return methods that access it.",
        "The returned object's methods \"close over\" the `count` variable.",
        "Use a default parameter `start = 0` for the optional starting value."
      ],
      "resources": [
        {
          "label": "MDN: Closures",
          "url": "/docs/mdn/closures.html",
          "description": "Functions that remember their scope"
        },
        {
          "label": "MDN: Default parameters",
          "url": "/docs/mdn/default-parameters.html",
          "description": "Setting default values for function parameters"
        }
      ]
    },
    {
      "id": 702,
      "title": "All Unique Characters",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "patterns"
      ],
      "tags": [
        "strings",
        "sets",
        "algorithms",
        "intermediate"
      ],
      "description": "Check if all characters in a string are unique.",
      "instructions": "Write a function called `isUnique` that takes a string and returns `true` if all characters are unique (no repeats), `false` otherwise.\n\nThe check should be case-sensitive ('A' and 'a' are different).\n\nExample:\n  isUnique('abcdef')    →  true\n  isUnique('hello')     →  false  (l repeats)\n  isUnique('AaBb')      →  true   (case-sensitive)",
      "starterCode": "function isUnique(str) {\n  // Your code here\n\n}",
      "solution": "function isUnique(str) {\n  return new Set(str).size === str.length;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return isUnique;')(); return [ { pass: fn('abcdef') === true, description: 'isUnique(\"abcdef\") → true', got: fn('abcdef') }, { pass: fn('hello') === false, description: 'isUnique(\"hello\") → false', got: fn('hello') }, { pass: fn('AaBb') === true, description: 'isUnique(\"AaBb\") → true (case-sensitive)', got: fn('AaBb') }, { pass: fn('') === true, description: 'isUnique(\"\") → true (empty string)', got: fn('') }, { pass: fn('a') === true, description: 'isUnique(\"a\") → true', got: fn('a') }, { pass: fn('aA') === true, description: 'isUnique(\"aA\") → true', got: fn('aA') } ]; }",
      "hints": [
        "A Set automatically removes duplicates. Compare its size to the string length.",
        "Alternative: use an object to track which characters you've seen.",
        "Remember that 'A' and 'a' are different characters."
      ],
      "resources": [
        {
          "label": "MDN: Set",
          "url": "/docs/mdn/set.html",
          "description": "A collection of unique values"
        },
        {
          "label": "MDN: Set",
          "url": "/docs/mdn/set.html",
          "description": "A collection of unique values"
        }
      ]
    },
    {
      "id": 703,
      "title": "Median of Three",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "conditionals",
        "math",
        "comparison",
        "beginner"
      ],
      "description": "Find the median (middle value) of three numbers.",
      "instructions": "Write a function called `medianOfThree` that takes three numbers and returns the one that falls in the middle when sorted.\n\nDo NOT use arrays or sorting methods — solve it with comparisons only.\n\nExample:\n  medianOfThree(3, 1, 2)   →  2\n  medianOfThree(7, 7, 5)   →  7\n  medianOfThree(10, 4, 6)  →  6",
      "starterCode": "function medianOfThree(a, b, c) {\n  // Your code here\n\n}",
      "solution": "function medianOfThree(a, b, c) {\n  if ((a >= b && a <= c) || (a <= b && a >= c)) return a;\n  if ((b >= a && b <= c) || (b <= a && b >= c)) return b;\n  return c;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return medianOfThree;')(); return [ { pass: fn(3, 1, 2) === 2, description: 'medianOfThree(3, 1, 2) → 2', got: fn(3, 1, 2) }, { pass: fn(7, 7, 5) === 7, description: 'medianOfThree(7, 7, 5) → 7', got: fn(7, 7, 5) }, { pass: fn(10, 4, 6) === 6, description: 'medianOfThree(10, 4, 6) → 6', got: fn(10, 4, 6) }, { pass: fn(1, 2, 3) === 2, description: 'medianOfThree(1, 2, 3) → 2', got: fn(1, 2, 3) }, { pass: fn(5, 5, 5) === 5, description: 'medianOfThree(5, 5, 5) → 5', got: fn(5, 5, 5) }, { pass: fn(-1, 0, 1) === 0, description: 'medianOfThree(-1, 0, 1) → 0', got: fn(-1, 0, 1) }, { pass: fn(100, 1, 50) === 50, description: 'medianOfThree(100, 1, 50) → 50', got: fn(100, 1, 50) } ]; }",
      "hints": [
        "The median is the value that is between the other two.",
        "Check if `a` is between `b` and `c`, then if `b` is between `a` and `c`.",
        "Use compound conditions: `(a >= b && a <= c) || (a <= b && a >= c)` means a is between b and c."
      ],
      "resources": [
        {
          "label": "MDN: Logical AND (&&)",
          "url": "/docs/mdn/logical-and.html",
          "description": "Combining boolean conditions"
        },
        {
          "label": "MDN: Logical OR (||)",
          "url": "/docs/mdn/logical-or.html",
          "description": "Alternative conditions"
        }
      ]
    },
    {
      "id": 707,
      "title": "Search Insert Position",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "searching"
      ],
      "tags": [
        "searching",
        "binary-search",
        "arrays",
        "intermediate"
      ],
      "description": "Find where a target should be inserted in a sorted array.",
      "instructions": "Write a function called `searchInsert` that takes a sorted array of numbers and a target value. Return the index where the target is found, or the index where it would be inserted to keep the array sorted.\n\nExample:\n  searchInsert([1, 3, 5, 6], 5)  →  2  (found at index 2)\n  searchInsert([1, 3, 5, 6], 2)  →  1  (insert before 3)\n  searchInsert([1, 3, 5, 6], 7)  →  4  (insert at end)\n  searchInsert([1, 3, 5, 6], 0)  →  0  (insert at start)",
      "starterCode": "function searchInsert(arr, target) {\n  // Your code here\n\n}",
      "solution": "function searchInsert(arr, target) {\n  let lo = 0, hi = arr.length;\n  while (lo < hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return searchInsert;')(); return [ { pass: fn([1,3,5,6], 5) === 2, description: 'searchInsert([1,3,5,6], 5) → 2 (found)', got: fn([1,3,5,6], 5) }, { pass: fn([1,3,5,6], 2) === 1, description: 'searchInsert([1,3,5,6], 2) → 1 (insert)', got: fn([1,3,5,6], 2) }, { pass: fn([1,3,5,6], 7) === 4, description: 'searchInsert([1,3,5,6], 7) → 4 (end)', got: fn([1,3,5,6], 7) }, { pass: fn([1,3,5,6], 0) === 0, description: 'searchInsert([1,3,5,6], 0) → 0 (start)', got: fn([1,3,5,6], 0) }, { pass: fn([], 5) === 0, description: 'searchInsert([], 5) → 0 (empty)', got: fn([], 5) }, { pass: fn([1], 1) === 0, description: 'searchInsert([1], 1) → 0', got: fn([1], 1) } ]; }",
      "hints": [
        "This is a modified binary search problem.",
        "Use two pointers (lo, hi) and narrow the search range by comparing the midpoint to the target.",
        "When the loop ends, `lo` is the correct insertion position."
      ],
      "resources": [
        {
          "label": "MDN: Math.floor()",
          "url": "/docs/mdn/math-floor.html",
          "description": "Rounds down to nearest integer"
        },
        {
          "label": "MDN: while statement",
          "url": "/docs/mdn/while.html",
          "description": "Looping while a condition is true"
        }
      ]
    },
    {
      "id": 708,
      "title": "Count in Range",
      "type": "js",
      "tier": 2,
      "category": [
        "algorithms",
        "searching"
      ],
      "tags": [
        "searching",
        "arrays",
        "loops",
        "beginner"
      ],
      "description": "Count how many array elements fall within a given range.",
      "instructions": "Write a function called `countInRange` that takes an array of numbers, a `low` value, and a `high` value. Return the count of elements that are between `low` and `high` (inclusive).\n\nExample:\n  countInRange([1, 5, 3, 8, 2, 7], 3, 7)  →  3  (3, 5, 7)\n  countInRange([10, 20, 30], 15, 25)       →  1  (20)\n  countInRange([1, 2, 3], 5, 10)           →  0",
      "starterCode": "function countInRange(arr, low, high) {\n  // Your code here\n\n}",
      "solution": "function countInRange(arr, low, high) {\n  let count = 0;\n  for (const num of arr) {\n    if (num >= low && num <= high) count++;\n  }\n  return count;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countInRange;')(); return [ { pass: fn([1,5,3,8,2,7], 3, 7) === 3, description: 'countInRange([1,5,3,8,2,7], 3, 7) → 3', got: fn([1,5,3,8,2,7], 3, 7) }, { pass: fn([10,20,30], 15, 25) === 1, description: 'countInRange([10,20,30], 15, 25) → 1', got: fn([10,20,30], 15, 25) }, { pass: fn([1,2,3], 5, 10) === 0, description: 'countInRange([1,2,3], 5, 10) → 0', got: fn([1,2,3], 5, 10) }, { pass: fn([5,5,5], 5, 5) === 3, description: 'countInRange([5,5,5], 5, 5) → 3 (exact match)', got: fn([5,5,5], 5, 5) }, { pass: fn([], 1, 10) === 0, description: 'countInRange([], 1, 10) → 0', got: fn([], 1, 10) }, { pass: fn([1,2,3,4,5], 1, 5) === 5, description: 'countInRange([1..5], 1, 5) → 5 (all)', got: fn([1,2,3,4,5], 1, 5) } ]; }",
      "hints": [
        "Loop through the array and check if each element is >= low AND <= high.",
        "Keep a counter and increment it when a value is in range.",
        "The range is inclusive — values equal to low or high should be counted."
      ],
      "resources": [
        {
          "label": "MDN: for...of",
          "url": "/docs/mdn/for-of.html",
          "description": "Iterating over array values"
        },
        {
          "label": "MDN: Array.filter()",
          "url": "/docs/mdn/array-filter.html",
          "description": "Creating a subset of an array based on a condition"
        }
      ]
    },
    {
      "id": 709,
      "title": "Rectangle Math",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "variables",
        "math",
        "objects",
        "beginner"
      ],
      "description": "Store rectangle dimensions in variables and compute properties.",
      "instructions": "Write a function called `rectangleInfo` that takes `width` and `height` and returns an object with:\n\n- `area` — width × height\n- `perimeter` — 2 × (width + height)\n- `diagonal` — the length of the diagonal (use the Pythagorean theorem), rounded to 2 decimal places\n- `isSquare` — `true` if width equals height\n\nExample:\n  rectangleInfo(3, 4)  →  { area: 12, perimeter: 14, diagonal: 5.00, isSquare: false }\n  rectangleInfo(5, 5)  →  { area: 25, perimeter: 20, diagonal: 7.07, isSquare: true }",
      "starterCode": "function rectangleInfo(width, height) {\n  // Your code here\n\n}",
      "solution": "function rectangleInfo(width, height) {\n  const area = width * height;\n  const perimeter = 2 * (width + height);\n  const diagonal = Math.round(Math.sqrt(width * width + height * height) * 100) / 100;\n  const isSquare = width === height;\n  return { area, perimeter, diagonal, isSquare };\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return rectangleInfo;')(); const r1 = fn(3, 4); const r2 = fn(5, 5); const r3 = fn(10, 1); return [ { pass: r1.area === 12, description: 'rectangleInfo(3,4).area → 12', got: r1.area }, { pass: r1.perimeter === 14, description: 'rectangleInfo(3,4).perimeter → 14', got: r1.perimeter }, { pass: r1.diagonal === 5, description: 'rectangleInfo(3,4).diagonal → 5', got: r1.diagonal }, { pass: r1.isSquare === false, description: 'rectangleInfo(3,4).isSquare → false', got: r1.isSquare }, { pass: r2.area === 25 && r2.isSquare === true, description: 'rectangleInfo(5,5) is a square with area 25', got: JSON.stringify(r2) }, { pass: r2.diagonal === 7.07, description: 'rectangleInfo(5,5).diagonal → 7.07', got: r2.diagonal }, { pass: r3.perimeter === 22, description: 'rectangleInfo(10,1).perimeter → 22', got: r3.perimeter } ]; }",
      "hints": [
        "Area = width * height, Perimeter = 2 * (width + height).",
        "Diagonal uses Pythagorean theorem: `Math.sqrt(width**2 + height**2)`.",
        "To round to 2 decimals: `Math.round(value * 100) / 100`."
      ],
      "resources": [
        {
          "label": "MDN: Math.sqrt()",
          "url": "/docs/mdn/math-sqrt.html",
          "description": "Calculating square roots"
        },
        {
          "label": "MDN: Object initializer",
          "url": "/docs/mdn/object-initializer.html",
          "description": "Creating objects with shorthand properties"
        }
      ]
    },
    {
      "id": 711,
      "title": "Error Message Builder",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literals",
        "strings",
        "formatting",
        "beginner"
      ],
      "description": "Build structured error messages using template literals.",
      "instructions": "Write a function called `formatError` that takes an error `code` (number), a `message` (string), and a `timestamp` (string), and returns a formatted error string.\n\nFormat: `\"[{timestamp}] Error {code}: {message}\"`\n\nExample:\n  formatError(404, 'Not Found', '2024-01-15')\n  →  '[2024-01-15] Error 404: Not Found'\n\n  formatError(500, 'Server Error', '2024-03-20')\n  →  '[2024-03-20] Error 500: Server Error'",
      "starterCode": "function formatError(code, message, timestamp) {\n  // Your code here\n\n}",
      "solution": "function formatError(code, message, timestamp) {\n  return `[${timestamp}] Error ${code}: ${message}`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return formatError;')(); return [ { pass: fn(404, 'Not Found', '2024-01-15') === '[2024-01-15] Error 404: Not Found', description: 'formatError(404, \"Not Found\", \"2024-01-15\")', got: fn(404, 'Not Found', '2024-01-15') }, { pass: fn(500, 'Server Error', '2024-03-20') === '[2024-03-20] Error 500: Server Error', description: 'formatError(500, \"Server Error\", \"2024-03-20\")', got: fn(500, 'Server Error', '2024-03-20') }, { pass: fn(403, 'Forbidden', '2024-06-01') === '[2024-06-01] Error 403: Forbidden', description: 'formatError(403, \"Forbidden\", \"2024-06-01\")', got: fn(403, 'Forbidden', '2024-06-01') }, { pass: fn(200, 'OK', '2024-12-25') === '[2024-12-25] Error 200: OK', description: 'Works with any code/message combo', got: fn(200, 'OK', '2024-12-25') } ]; }",
      "hints": [
        "Template literals use backticks and `${}` to embed expressions.",
        "The format is: `[${timestamp}] Error ${code}: ${message}`",
        "Make sure to include the brackets, spaces, and colon exactly as shown."
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "A shorthand for if/else"
        }
      ]
    },
    {
      "id": 712,
      "title": "Insertion Sort",
      "type": "js",
      "tier": 3,
      "category": [
        "algorithms",
        "sorting"
      ],
      "tags": [
        "sorting",
        "algorithms",
        "loops",
        "intermediate"
      ],
      "description": "Implement the insertion sort algorithm.",
      "instructions": "Write a function called `insertionSort` that takes an array of numbers and returns a new sorted array using the insertion sort algorithm.\n\nInsertion sort works by building a sorted portion one element at a time. For each element, shift it left until it’s in the correct position relative to the already-sorted elements.\n\nDo NOT use built-in `.sort()`. Do not modify the original array.\n\nExample:\n  insertionSort([5, 3, 1, 4, 2])  →  [1, 2, 3, 4, 5]\n  insertionSort([1])               →  [1]",
      "starterCode": "function insertionSort(arr) {\n  // Create a copy and sort it using insertion sort\n\n}",
      "solution": "function insertionSort(arr) {\n  const sorted = [...arr];\n  for (let i = 1; i < sorted.length; i++) {\n    const key = sorted[i];\n    let j = i - 1;\n    while (j >= 0 && sorted[j] > key) {\n      sorted[j + 1] = sorted[j];\n      j--;\n    }\n    sorted[j + 1] = key;\n  }\n  return sorted;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return insertionSort;')(); const r1 = fn([5,3,1,4,2]); const r2 = fn([1]); const r3 = fn([3,1,4,1,5,9,2,6]); const orig = [5,3,1]; fn(orig); return [ { pass: JSON.stringify(r1) === '[1,2,3,4,5]', description: 'insertionSort([5,3,1,4,2]) → [1,2,3,4,5]', got: JSON.stringify(r1) }, { pass: JSON.stringify(r2) === '[1]', description: 'insertionSort([1]) → [1]', got: JSON.stringify(r2) }, { pass: JSON.stringify(r3) === '[1,1,2,3,4,5,6,9]', description: 'Sorts array with duplicates', got: JSON.stringify(r3) }, { pass: JSON.stringify(fn([])) === '[]', description: 'Empty array returns []', got: JSON.stringify(fn([])) }, { pass: JSON.stringify(orig) === '[5,3,1]', description: 'Does not modify original array', got: JSON.stringify(orig) } ]; }",
      "hints": [
        "Start from the second element. For each element, compare it to the ones before it.",
        "Shift larger elements to the right to make room for the current element.",
        "Use a `while` loop to shift elements: `while (j >= 0 && sorted[j] > key)`."
      ],
      "resources": [
        {
          "label": "MDN: Spread syntax",
          "url": "/docs/mdn/spread-syntax.html",
          "description": "Copying an array with [...]"
        },
        {
          "label": "MDN: Array.splice()",
          "url": "/docs/mdn/array-splice.html",
          "description": "Inserting and removing array elements"
        }
      ]
    },
    {
      "id": 713,
      "title": "GCD Calculator",
      "type": "js",
      "tier": 2,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "loops",
        "math",
        "while",
        "intermediate"
      ],
      "description": "Find the greatest common divisor of two numbers using the Euclidean algorithm.",
      "instructions": "Write a function called `gcd` that takes two positive integers and returns their greatest common divisor (GCD).\n\nUse the Euclidean algorithm:\n- While `b` is not 0, replace `(a, b)` with `(b, a % b)`\n- When `b` is 0, `a` is the GCD\n\nExample:\n  gcd(12, 8)   →  4\n  gcd(54, 24)  →  6\n  gcd(7, 13)   →  1  (coprime)",
      "starterCode": "function gcd(a, b) {\n  // Your code here\n\n}",
      "solution": "function gcd(a, b) {\n  while (b !== 0) {\n    const temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return gcd;')(); return [ { pass: fn(12, 8) === 4, description: 'gcd(12, 8) → 4', got: fn(12, 8) }, { pass: fn(54, 24) === 6, description: 'gcd(54, 24) → 6', got: fn(54, 24) }, { pass: fn(7, 13) === 1, description: 'gcd(7, 13) → 1 (coprime)', got: fn(7, 13) }, { pass: fn(100, 100) === 100, description: 'gcd(100, 100) → 100', got: fn(100, 100) }, { pass: fn(17, 1) === 1, description: 'gcd(17, 1) → 1', got: fn(17, 1) }, { pass: fn(48, 18) === 6, description: 'gcd(48, 18) → 6', got: fn(48, 18) } ]; }",
      "hints": [
        "The Euclidean algorithm repeatedly divides and takes the remainder.",
        "In each step: save `b`, set `b = a % b`, set `a` to the saved value.",
        "The loop ends when `b` becomes 0 — at that point `a` is the answer."
      ],
      "resources": [
        {
          "label": "MDN: Remainder (%)",
          "url": "/docs/mdn/remainder.html",
          "description": "The modulo operator"
        },
        {
          "label": "MDN: while statement",
          "url": "/docs/mdn/while.html",
          "description": "Looping while a condition is true"
        }
      ]
    },
    {
      "id": 714,
      "title": "DNA Complement",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "strings",
        "mapping",
        "science",
        "beginner"
      ],
      "description": "Return the complementary DNA strand by swapping base pairs.",
      "instructions": "Write a function called `dnaComplement` that takes a DNA strand string and returns its complement.\n\nBase pair rules:\n- `A` ↔ `T`\n- `C` ↔ `G`\n\nThe input will only contain characters A, T, C, and G.\n\nExample:\n  dnaComplement('ATTGC')   →  'TAACG'\n  dnaComplement('GATTACA')  →  'CTAATGT'\n  dnaComplement('AAAA')     →  'TTTT'",
      "starterCode": "function dnaComplement(strand) {\n  // Your code here\n\n}",
      "solution": "function dnaComplement(strand) {\n  const pairs = { A: 'T', T: 'A', C: 'G', G: 'C' };\n  return strand.split('').map(base => pairs[base]).join('');\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return dnaComplement;')(); return [ { pass: fn('ATTGC') === 'TAACG', description: 'dnaComplement(\"ATTGC\") → \"TAACG\"', got: fn('ATTGC') }, { pass: fn('GATTACA') === 'CTAATGT', description: 'dnaComplement(\"GATTACA\") → \"CTAATGT\"', got: fn('GATTACA') }, { pass: fn('AAAA') === 'TTTT', description: 'dnaComplement(\"AAAA\") → \"TTTT\"', got: fn('AAAA') }, { pass: fn('CCGG') === 'GGCC', description: 'dnaComplement(\"CCGG\") → \"GGCC\"', got: fn('CCGG') }, { pass: fn('') === '', description: 'dnaComplement(\"\") → \"\"', got: fn('') } ]; }",
      "hints": [
        "Create a lookup object mapping each base to its complement.",
        "Split the string, map each character through the lookup, and join back.",
        "A pairs with T, and C pairs with G (and vice versa)."
      ],
      "resources": [
        {
          "label": "MDN: Array.map()",
          "url": "/docs/mdn/array-map.html",
          "description": "Transforming each element of an array"
        },
        {
          "label": "MDN: String.split()",
          "url": "/docs/mdn/string-split.html",
          "description": "Breaking a string into an array"
        }
      ]
    },
    {
      "id": 715,
      "title": "Object Intersection",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "objects",
        "comparison",
        "keys",
        "intermediate"
      ],
      "description": "Find the common key-value pairs between two objects.",
      "instructions": "Write a function called `objectIntersect` that takes two objects and returns a new object containing only the key-value pairs that exist in BOTH objects (same key AND same value).\n\nExample:\n  objectIntersect({a: 1, b: 2, c: 3}, {b: 2, c: 5, d: 4})\n  →  {b: 2}\n\n  objectIntersect({x: 10, y: 20}, {x: 10, y: 20})\n  →  {x: 10, y: 20}\n\n  objectIntersect({a: 1}, {b: 2})\n  →  {}",
      "starterCode": "function objectIntersect(obj1, obj2) {\n  // Your code here\n\n}",
      "solution": "function objectIntersect(obj1, obj2) {\n  const result = {};\n  for (const key of Object.keys(obj1)) {\n    if (obj2[key] === obj1[key]) {\n      result[key] = obj1[key];\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return objectIntersect;')(); const r1 = fn({a:1, b:2, c:3}, {b:2, c:5, d:4}); const r2 = fn({x:10, y:20}, {x:10, y:20}); const r3 = fn({a:1}, {b:2}); const r4 = fn({}, {a:1}); return [ { pass: JSON.stringify(r1) === '{\"b\":2}', description: 'Finds common pair {b:2}', got: JSON.stringify(r1) }, { pass: r2.x === 10 && r2.y === 20 && Object.keys(r2).length === 2, description: 'All pairs common → {x:10, y:20}', got: JSON.stringify(r2) }, { pass: Object.keys(r3).length === 0, description: 'No common pairs → {}', got: JSON.stringify(r3) }, { pass: Object.keys(r4).length === 0, description: 'Empty object intersect → {}', got: JSON.stringify(r4) } ]; }",
      "hints": [
        "Loop through the keys of one object and check if the other object has the same key with the same value.",
        "Use `Object.keys(obj1)` to get the keys, then check `obj2[key] === obj1[key]`.",
        "Build a new result object with only the matching pairs."
      ],
      "resources": [
        {
          "label": "MDN: Object.keys()",
          "url": "/docs/mdn/object-keys.html",
          "description": "Getting all keys of an object"
        },
        {
          "label": "MDN: for...in statement",
          "url": "/docs/mdn/for-in.html",
          "description": "Iterating over object properties"
        }
      ]
    },
    {
      "id": 716,
      "title": "First Variables",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "let",
        "const",
        "types",
        "declaration"
      ],
      "description": "Declare variables of different types: string, number, and boolean.",
      "instructions": "Declare three variables:\n\n- `petName` — a string set to `\"Buddy\"`\n- `petAge` — a number set to `3`\n- `isVaccinated` — a boolean set to `true`\n\nUse `const` for all three since the values won't change.",
      "starterCode": "// Declare a string variable called petName\n\n\n// Declare a number variable called petAge\n\n\n// Declare a boolean variable called isVaccinated\n",
      "solution": "const petName = \"Buddy\";\nconst petAge = 3;\nconst isVaccinated = true;",
      "testRunner": "(code) => { const v = new Function(code + '; return { petName, petAge, isVaccinated };')(); return [ { pass: v.petName === \"Buddy\", description: 'petName should be \"Buddy\"', got: v.petName }, { pass: v.petAge === 3, description: 'petAge should be 3', got: v.petAge }, { pass: v.isVaccinated === true, description: 'isVaccinated should be true', got: v.isVaccinated }, { pass: typeof v.petName === \"string\", description: 'petName should be a string', got: typeof v.petName }, { pass: typeof v.petAge === \"number\", description: 'petAge should be a number', got: typeof v.petAge }, { pass: typeof v.isVaccinated === \"boolean\", description: 'isVaccinated should be a boolean', got: typeof v.isVaccinated } ]; }",
      "hints": [
        "Use const to declare a variable: const myVar = value;",
        "Strings use quotes: \"Buddy\". Numbers are plain: 3. Booleans are true or false.",
        "const petName = \"Buddy\"; const petAge = 3; const isVaccinated = true;"
      ],
      "resources": [
        {
          "label": "MDN: Variables",
          "url": "/docs/mdn/variables.html",
          "description": "Declaring and using variables in JavaScript"
        },
        {
          "label": "MDN: Data types",
          "url": "/docs/mdn/data-types.html",
          "description": "Strings, numbers, booleans, and more"
        }
      ]
    },
    {
      "id": 717,
      "title": "String Building",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "variables"
      ],
      "tags": [
        "string",
        "concatenation",
        "variables"
      ],
      "description": "Join two strings together using the + operator to build a full name.",
      "instructions": "Two variables are already declared: `first` and `last`.\n\nCreate a new variable called `fullName` that combines them with a space in between.\n\nExample: if first is `\"Jane\"` and last is `\"Smith\"`, then fullName should be `\"Jane Smith\"`.",
      "starterCode": "const first = \"Jane\";\nconst last = \"Smith\";\n\n// Create fullName by joining first and last with a space\nconst fullName = ___;",
      "solution": "const first = \"Jane\";\nconst last = \"Smith\";\n\nconst fullName = first + \" \" + last;",
      "testRunner": "(code) => { const v = new Function(code + '; return { first, last, fullName };')(); return [ { pass: v.fullName === \"Jane Smith\", description: 'fullName should be \"Jane Smith\"', got: v.fullName }, { pass: typeof v.fullName === \"string\", description: 'fullName should be a string', got: typeof v.fullName }, { pass: v.fullName.includes(\" \"), description: 'fullName should contain a space between the names', got: v.fullName } ]; }",
      "hints": [
        "Use the + operator to join strings: \"hello\" + \" \" + \"world\"",
        "Don't forget the space between the names: first + \" \" + last",
        "const fullName = first + \" \" + last;"
      ],
      "resources": [
        {
          "label": "MDN: Strings",
          "url": "/docs/mdn/strings.html",
          "description": "Working with text strings in JavaScript"
        },
        {
          "label": "MDN: String concatenation",
          "url": "/docs/mdn/string-concat.html",
          "description": "Combining strings with + or template literals"
        }
      ]
    },
    {
      "id": 718,
      "title": "Shopping Math",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "arithmetic",
        "multiplication",
        "operators"
      ],
      "description": "Use arithmetic operators to calculate a shopping total with tax.",
      "instructions": "Given a `price` of `19.99` and a `quantity` of `4`:\n\n1. Calculate `subtotal` — the price times the quantity\n2. Calculate `taxAmount` — 8% of the subtotal (multiply by 0.08)\n3. Calculate `total` — the subtotal plus the tax amount\n\nRound `total` to 2 decimal places using: `Math.round(value * 100) / 100`",
      "starterCode": "const price = 19.99;\nconst quantity = 4;\n\n// Calculate the subtotal\nconst subtotal = ___;\n\n// Calculate 8% tax\nconst taxAmount = ___;\n\n// Calculate the total (rounded to 2 decimals)\nconst total = ___;",
      "solution": "const price = 19.99;\nconst quantity = 4;\n\nconst subtotal = price * quantity;\nconst taxAmount = subtotal * 0.08;\nconst total = Math.round((subtotal + taxAmount) * 100) / 100;",
      "testRunner": "(code) => { const v = new Function(code + '; return { subtotal, taxAmount, total };')(); return [ { pass: v.subtotal === 79.96, description: 'subtotal should be 79.96', got: v.subtotal }, { pass: Math.abs(v.taxAmount - 6.3968) < 0.001, description: 'taxAmount should be ~6.3968', got: v.taxAmount }, { pass: v.total === 86.36, description: 'total should be 86.36 (rounded)', got: v.total } ]; }",
      "hints": [
        "Multiply price * quantity to get the subtotal",
        "Tax is subtotal * 0.08. Total is subtotal + taxAmount.",
        "Round with: Math.round((subtotal + taxAmount) * 100) / 100"
      ],
      "resources": [
        {
          "label": "MDN: Math",
          "url": "/docs/mdn/math.html",
          "description": "Arithmetic and number operations"
        },
        {
          "label": "MDN: Arithmetic operators",
          "url": "/docs/mdn/arithmetic.html",
          "description": "All math operators including modulo (%)"
        }
      ]
    },
    {
      "id": 719,
      "title": "Strict vs Loose",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "equality",
        "comparison",
        "strict",
        "loose"
      ],
      "description": "Understand the difference between === (strict) and == (loose) equality.",
      "instructions": "Evaluate each comparison and store the result in the given variable:\n\n- `a` — Is `5 === \"5\"`? (strict equality, checks type too)\n- `b` — Is `5 == \"5\"`? (loose equality, converts types)\n- `c` — Is `null === undefined`?\n- `d` — Is `null == undefined`?\n- `e` — Is `0 === false`?\n- `f` — Is `0 == false`?\n\nThink carefully about which pairs JavaScript considers equal!",
      "starterCode": "const a = (5 === \"5\");     // strict: number vs string\nconst b = (5 == \"5\");      // loose: number vs string\nconst c = (null === undefined);\nconst d = (null == undefined);\nconst e = (0 === false);\nconst f = (0 == false);",
      "solution": "const a = (5 === \"5\");\nconst b = (5 == \"5\");\nconst c = (null === undefined);\nconst d = (null == undefined);\nconst e = (0 === false);\nconst f = (0 == false);",
      "testRunner": "(code) => { const v = new Function(code + '; return { a, b, c, d, e, f };')(); return [ { pass: v.a === false, description: '5 === \"5\" should be false', got: v.a }, { pass: v.b === true, description: '5 == \"5\" should be true', got: v.b }, { pass: v.c === false, description: 'null === undefined should be false', got: v.c }, { pass: v.d === true, description: 'null == undefined should be true', got: v.d }, { pass: v.e === false, description: '0 === false should be false', got: v.e }, { pass: v.f === true, description: '0 == false should be true', got: v.f } ]; }",
      "hints": [
        "=== checks both value AND type. == converts types before comparing.",
        "5 and \"5\" have different types (number vs string), so === is false but == is true.",
        "null and undefined are == but not ===. 0 and false are == but not ===."
      ],
      "resources": [
        {
          "label": "MDN: Equality comparisons",
          "url": "/docs/mdn/equality.html",
          "description": "Understanding === vs == and type coercion"
        },
        {
          "label": "MDN: Comparison operators",
          "url": "/docs/mdn/comparison.html",
          "description": "Greater than, less than, and equality operators"
        }
      ]
    },
    {
      "id": 721,
      "title": "Hello Template",
      "type": "js",
      "tier": 1,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literal",
        "interpolation",
        "string"
      ],
      "description": "Use template literal syntax to embed variables inside a string.",
      "instructions": "Given `name` and `age`, create a `greeting` string using a template literal (backticks).\n\nThe result should be:\n`\"Hello, my name is Alice and I am 25 years old.\"`\n\nTemplate literals use backticks (\\`) and `${expression}` to embed values:\n```\nconst msg = `My name is ${name}`;\n```",
      "starterCode": "const name = \"Alice\";\nconst age = 25;\n\n// Create greeting using a template literal with backticks\nconst greeting = ___;",
      "solution": "const name = \"Alice\";\nconst age = 25;\n\nconst greeting = `Hello, my name is ${name} and I am ${age} years old.`;",
      "testRunner": "(code) => { const v = new Function(code + '; return { greeting };')(); return [ { pass: v.greeting === \"Hello, my name is Alice and I am 25 years old.\", description: 'greeting should match the expected string', got: v.greeting }, { pass: v.greeting.includes(\"Alice\"), description: 'greeting should contain the name', got: v.greeting }, { pass: v.greeting.includes(\"25\"), description: 'greeting should contain the age', got: v.greeting } ]; }",
      "hints": [
        "Use backticks (`) instead of quotes, and ${variableName} to insert values.",
        "The template should look like: `Hello, my name is ${name} and I am ${age} years old.`",
        "const greeting = `Hello, my name is ${name} and I am ${age} years old.`;"
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: String concatenation",
          "url": "/docs/mdn/string-concat.html",
          "description": "Combining strings with + or template literals"
        }
      ]
    },
    {
      "id": 722,
      "title": "Math in Templates",
      "type": "js",
      "tier": 1,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literal",
        "expression",
        "math"
      ],
      "description": "Embed math expressions directly inside template literals.",
      "instructions": "Template literals can contain any expression inside `${}`, including math!\n\nGiven `a = 8` and `b = 3`, create:\n\n- `sum` — a string like `\"8 + 3 = 11\"`\n- `product` — a string like `\"8 x 3 = 24\"`\n\nUse `${a + b}` inside a template literal to calculate directly.",
      "starterCode": "const a = 8;\nconst b = 3;\n\n// Create sum using a template literal with ${a + b}\nconst sum = ___;\n\n// Create product using a template literal with ${a * b}\nconst product = ___;",
      "solution": "const a = 8;\nconst b = 3;\n\nconst sum = `${a} + ${b} = ${a + b}`;\nconst product = `${a} x ${b} = ${a * b}`;",
      "testRunner": "(code) => { const v = new Function(code + '; return { sum, product };')(); return [ { pass: v.sum === \"8 + 3 = 11\", description: 'sum should be \"8 + 3 = 11\"', got: v.sum }, { pass: v.product === \"8 x 3 = 24\", description: 'product should be \"8 x 3 = 24\"', got: v.product } ]; }",
      "hints": [
        "You can put math inside ${}: `${a + b}` calculates and inserts the result.",
        "sum should be: `${a} + ${b} = ${a + b}`",
        "product should be: `${a} x ${b} = ${a * b}`"
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: Expressions and operators",
          "url": "/docs/mdn/expressions.html",
          "description": "How JavaScript evaluates expressions"
        }
      ]
    },
    {
      "id": 723,
      "title": "String Cleanup",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "string-methods",
        "trim",
        "toUpperCase",
        "toLowerCase"
      ],
      "description": "Use string methods to clean up and transform a messy string.",
      "instructions": "Given a messy string: `\"  hELLo wORLd  \"`\n\nCreate three cleaned-up versions:\n\n- `trimmed` — remove the extra spaces from both ends using `.trim()`\n- `shouted` — convert the trimmed version to ALL UPPERCASE using `.toUpperCase()`\n- `whispered` — convert the trimmed version to all lowercase using `.toLowerCase()`",
      "starterCode": "const messy = \"  hELLo wORLd  \";\n\n// Remove spaces from both ends\nconst trimmed = ___;\n\n// Convert trimmed to uppercase\nconst shouted = ___;\n\n// Convert trimmed to lowercase\nconst whispered = ___;",
      "solution": "const messy = \"  hELLo wORLd  \";\n\nconst trimmed = messy.trim();\nconst shouted = trimmed.toUpperCase();\nconst whispered = trimmed.toLowerCase();",
      "testRunner": "(code) => { const v = new Function(code + '; return { trimmed, shouted, whispered };')(); return [ { pass: v.trimmed === \"hELLo wORLd\", description: 'trimmed should be \"hELLo wORLd\" (no extra spaces)', got: v.trimmed }, { pass: v.shouted === \"HELLO WORLD\", description: 'shouted should be \"HELLO WORLD\"', got: v.shouted }, { pass: v.whispered === \"hello world\", description: 'whispered should be \"hello world\"', got: v.whispered } ]; }",
      "hints": [
        ".trim() removes whitespace from both ends of a string.",
        ".toUpperCase() makes every character uppercase. .toLowerCase() makes every character lowercase.",
        "const trimmed = messy.trim(); const shouted = trimmed.toUpperCase();"
      ],
      "resources": [
        {
          "label": "MDN: String.trim()",
          "url": "/docs/mdn/string-trim.html",
          "description": "Removing whitespace from both ends"
        },
        {
          "label": "MDN: String methods",
          "url": "/docs/mdn/string-methods.html",
          "description": "Common methods for working with strings"
        }
      ]
    },
    {
      "id": 724,
      "title": "Substring Extract",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "slice",
        "indexOf",
        "substring"
      ],
      "description": "Extract parts of a string using slice and indexOf.",
      "instructions": "Given an email address: `\"user@example.com\"`\n\nExtract two parts:\n\n- `username` — the part before the `@` symbol (`\"user\"`)\n- `domain` — the part after the `@` symbol (`\"example.com\"`)\n\nHint: Use `.indexOf(\"@\")` to find the position of `@`, then `.slice()` to extract each part.\n\n```\nstr.slice(0, position)    // from start to position\nstr.slice(position + 1)   // from after position to end\n```",
      "starterCode": "const email = \"user@example.com\";\n\n// Find where the @ symbol is\nconst atIndex = email.indexOf(\"@\");\n\n// Extract the username (everything before @)\nconst username = ___;\n\n// Extract the domain (everything after @)\nconst domain = ___;",
      "solution": "const email = \"user@example.com\";\n\nconst atIndex = email.indexOf(\"@\");\nconst username = email.slice(0, atIndex);\nconst domain = email.slice(atIndex + 1);",
      "testRunner": "(code) => { const v = new Function(code + '; return { username, domain };')(); return [ { pass: v.username === \"user\", description: 'username should be \"user\"', got: v.username }, { pass: v.domain === \"example.com\", description: 'domain should be \"example.com\"', got: v.domain } ]; }",
      "hints": [
        ".indexOf(\"@\") returns the position of @. For \"user@example.com\" it returns 4.",
        ".slice(0, 4) gives \"user\". .slice(5) gives \"example.com\".",
        "username = email.slice(0, atIndex); domain = email.slice(atIndex + 1);"
      ],
      "resources": [
        {
          "label": "MDN: String.slice()",
          "url": "/docs/mdn/string-slice.html",
          "description": "Extracting part of a string"
        },
        {
          "label": "MDN: String.indexOf()",
          "url": "/docs/mdn/string-indexof.html",
          "description": "Finding the position of a substring"
        }
      ]
    },
    {
      "id": 725,
      "title": "Build an Object",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "object-literal",
        "properties",
        "creation"
      ],
      "description": "Create an object with multiple properties of different types.",
      "instructions": "Create an object called `book` with these properties:\n\n- `title` — `\"The Great Gatsby\"` (string)\n- `author` — `\"F. Scott Fitzgerald\"` (string)\n- `year` — `1925` (number)\n- `isRead` — `true` (boolean)\n\nUse an object literal with curly braces: `{ key: value, ... }`",
      "starterCode": "// Create a book object with title, author, year, and isRead\nconst book = {\n  ___\n};",
      "solution": "const book = {\n  title: \"The Great Gatsby\",\n  author: \"F. Scott Fitzgerald\",\n  year: 1925,\n  isRead: true\n};",
      "testRunner": "(code) => { const v = new Function(code + '; return book;')(); return [ { pass: v.title === \"The Great Gatsby\", description: 'book.title should be \"The Great Gatsby\"', got: v.title }, { pass: v.author === \"F. Scott Fitzgerald\", description: 'book.author should be \"F. Scott Fitzgerald\"', got: v.author }, { pass: v.year === 1925, description: 'book.year should be 1925', got: v.year }, { pass: v.isRead === true, description: 'book.isRead should be true', got: v.isRead } ]; }",
      "hints": [
        "Object literals use key: value pairs: { name: \"Alex\", age: 30 }",
        "Separate each property with a comma. Strings need quotes, numbers and booleans don't.",
        "const book = { title: \"The Great Gatsby\", author: \"F. Scott Fitzgerald\", year: 1925, isRead: true };"
      ],
      "resources": [
        {
          "label": "MDN: Working with objects",
          "url": "/docs/mdn/objects.html",
          "description": "Creating and accessing object properties"
        },
        {
          "label": "MDN: Object initializer",
          "url": "/docs/mdn/object-initializer.html",
          "description": "Creating objects with shorthand properties"
        }
      ]
    },
    {
      "id": 726,
      "title": "Read from Object",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "property-access",
        "dot-notation",
        "bracket-notation"
      ],
      "description": "Access object properties using dot notation and bracket notation.",
      "instructions": "Given a `student` object, read its properties two different ways:\n\n- `studentName` — use **dot notation**: `student.name`\n- `studentGrade` — use **bracket notation**: `student[\"grade\"]`\n- `studentSubject` — use bracket notation with a **variable**: `student[key]`\n\nBracket notation is useful when the property name is stored in a variable.",
      "starterCode": "const student = {\n  name: \"Maria\",\n  grade: \"A\",\n  subject: \"Math\"\n};\nconst key = \"subject\";\n\n// Read name using dot notation\nconst studentName = ___;\n\n// Read grade using bracket notation with a string\nconst studentGrade = ___;\n\n// Read subject using bracket notation with the variable 'key'\nconst studentSubject = ___;",
      "solution": "const student = {\n  name: \"Maria\",\n  grade: \"A\",\n  subject: \"Math\"\n};\nconst key = \"subject\";\n\nconst studentName = student.name;\nconst studentGrade = student[\"grade\"];\nconst studentSubject = student[key];",
      "testRunner": "(code) => { const v = new Function(code + '; return { studentName, studentGrade, studentSubject };')(); return [ { pass: v.studentName === \"Maria\", description: 'studentName should be \"Maria\" (dot notation)', got: v.studentName }, { pass: v.studentGrade === \"A\", description: 'studentGrade should be \"A\" (bracket notation)', got: v.studentGrade }, { pass: v.studentSubject === \"Math\", description: 'studentSubject should be \"Math\" (variable bracket notation)', got: v.studentSubject } ]; }",
      "hints": [
        "Dot notation: object.property — like student.name",
        "Bracket notation: object[\"property\"] — like student[\"grade\"]",
        "Variable bracket: object[variable] — like student[key] where key = \"subject\""
      ],
      "resources": [
        {
          "label": "MDN: Property accessors",
          "url": "/docs/mdn/property-access.html",
          "description": "Dot notation and bracket notation"
        },
        {
          "label": "MDN: Working with objects",
          "url": "/docs/mdn/objects.html",
          "description": "Creating and accessing object properties"
        }
      ]
    },
    {
      "id": 727,
      "title": "Array Basics",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "array",
        "index",
        "access",
        "creation"
      ],
      "description": "Create an array and access elements by their index.",
      "instructions": "Create an array called `colors` with these values: `\"red\"`, `\"green\"`, `\"blue\"`, `\"yellow\"`\n\nThen read from it:\n\n- `first` — the first element (index 0)\n- `last` — the last element (index 3)\n- `count` — the total number of elements using `.length`\n\nRemember: array indexes start at 0!",
      "starterCode": "// Create an array with 4 colors\nconst colors = [___];\n\n// Access the first element (index 0)\nconst first = ___;\n\n// Access the last element (index 3)\nconst last = ___;\n\n// Get the total count using .length\nconst count = ___;",
      "solution": "const colors = [\"red\", \"green\", \"blue\", \"yellow\"];\n\nconst first = colors[0];\nconst last = colors[3];\nconst count = colors.length;",
      "testRunner": "(code) => { const v = new Function(code + '; return { colors, first, last, count };')(); return [ { pass: Array.isArray(v.colors) && v.colors.length === 4, description: 'colors should be an array with 4 items', got: JSON.stringify(v.colors) }, { pass: v.first === \"red\", description: 'first should be \"red\" (index 0)', got: v.first }, { pass: v.last === \"yellow\", description: 'last should be \"yellow\" (index 3)', got: v.last }, { pass: v.count === 4, description: 'count should be 4', got: v.count } ]; }",
      "hints": [
        "Arrays are created with square brackets: [\"red\", \"green\", \"blue\", \"yellow\"]",
        "Access elements by index: colors[0] is the first, colors[3] is the fourth.",
        "colors.length gives the total number of elements."
      ],
      "resources": [
        {
          "label": "MDN: Arrays",
          "url": "/docs/mdn/arrays.html",
          "description": "Creating and working with arrays"
        },
        {
          "label": "MDN: Indexed collections",
          "url": "/docs/mdn/indexed-collections.html",
          "description": "Working with arrays and typed arrays"
        }
      ]
    },
    {
      "id": 728,
      "title": "Array Modify",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "push",
        "pop",
        "array-methods"
      ],
      "description": "Add and remove elements from an array using push and pop.",
      "instructions": "Start with: `let fruits = [\"apple\", \"banana\"]`\n\n1. Use `.push()` to add `\"cherry\"` to the **end** of the array\n2. Use `.push()` to add `\"date\"` to the end\n3. Use `.pop()` to remove the **last** element and store it in `removed`\n\nAfter all operations, fruits should be `[\"apple\", \"banana\", \"cherry\"]` and removed should be `\"date\"`.",
      "starterCode": "let fruits = [\"apple\", \"banana\"];\n\n// Add \"cherry\" to the end\n___;\n\n// Add \"date\" to the end\n___;\n\n// Remove the last element and save it\nconst removed = ___;",
      "solution": "let fruits = [\"apple\", \"banana\"];\n\nfruits.push(\"cherry\");\nfruits.push(\"date\");\nconst removed = fruits.pop();",
      "testRunner": "(code) => { const v = new Function(code + '; return { fruits, removed };')(); return [ { pass: JSON.stringify(v.fruits) === '[\"apple\",\"banana\",\"cherry\"]', description: 'fruits should be [\"apple\", \"banana\", \"cherry\"]', got: JSON.stringify(v.fruits) }, { pass: v.removed === \"date\", description: 'removed should be \"date\"', got: v.removed }, { pass: v.fruits.length === 3, description: 'fruits should have 3 elements', got: v.fruits.length } ]; }",
      "hints": [
        ".push(item) adds an item to the end of an array.",
        ".pop() removes and returns the last item from an array.",
        "fruits.push(\"cherry\"); fruits.push(\"date\"); const removed = fruits.pop();"
      ],
      "resources": [
        {
          "label": "MDN: Array.push()",
          "url": "/docs/mdn/array-push.html",
          "description": "Adding elements to the end of an array"
        },
        {
          "label": "MDN: Array.pop()",
          "url": "/docs/mdn/array-pop.html",
          "description": "Removing the last element from an array"
        }
      ]
    },
    {
      "id": 731,
      "title": "Age Check",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "ternary",
        "comparison",
        "conditional"
      ],
      "description": "Use the ternary operator to return different values based on a condition.",
      "instructions": "Write a function called `canVote` that takes an `age` (number) and returns:\n\n- `\"yes\"` if age is 18 or older\n- `\"no\"` if age is under 18\n\nUse the **ternary operator**: `condition ? valueIfTrue : valueIfFalse`\n\nExample:\n  canVote(21)  →  \"yes\"\n  canVote(16)  →  \"no\"\n  canVote(18)  →  \"yes\"",
      "starterCode": "function canVote(age) {\n  return ___;\n}",
      "solution": "function canVote(age) {\n  return age >= 18 ? \"yes\" : \"no\";\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return canVote;')(); return [ { pass: fn(21) === \"yes\", description: 'canVote(21) → \"yes\"', got: fn(21) }, { pass: fn(16) === \"no\", description: 'canVote(16) → \"no\"', got: fn(16) }, { pass: fn(18) === \"yes\", description: 'canVote(18) → \"yes\"', got: fn(18) }, { pass: fn(0) === \"no\", description: 'canVote(0) → \"no\"', got: fn(0) } ]; }",
      "hints": [
        "The ternary operator is: condition ? valueIfTrue : valueIfFalse",
        "The condition is: age >= 18",
        "return age >= 18 ? \"yes\" : \"no\";"
      ],
      "resources": [
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "A shorthand for if/else"
        },
        {
          "label": "MDN: Comparison operators",
          "url": "/docs/mdn/comparison.html",
          "description": "Greater than, less than, and equality operators"
        }
      ]
    },
    {
      "id": 732,
      "title": "Bigger of Two",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "conditionals"
      ],
      "tags": [
        "comparison",
        "conditional",
        "math"
      ],
      "description": "Return the larger of two numbers using a comparison.",
      "instructions": "Write a function called `bigger` that takes two numbers `a` and `b`, and returns the larger one.\n\nIf they are equal, return either one.\n\nExample:\n  bigger(5, 3)   →  5\n  bigger(2, 8)   →  8\n  bigger(4, 4)   →  4\n  bigger(-1, -5) →  -1",
      "starterCode": "function bigger(a, b) {\n  // Return the larger of a and b\n\n}",
      "solution": "function bigger(a, b) {\n  return a > b ? a : b;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return bigger;')(); return [ { pass: fn(5, 3) === 5, description: 'bigger(5, 3) → 5', got: fn(5, 3) }, { pass: fn(2, 8) === 8, description: 'bigger(2, 8) → 8', got: fn(2, 8) }, { pass: fn(4, 4) === 4, description: 'bigger(4, 4) → 4', got: fn(4, 4) }, { pass: fn(-1, -5) === -1, description: 'bigger(-1, -5) → -1', got: fn(-1, -5) } ]; }",
      "hints": [
        "Compare a and b with > or use a ternary: a > b ? a : b",
        "You could also use Math.max(a, b)",
        "return a > b ? a : b;"
      ],
      "resources": [
        {
          "label": "MDN: Conditional (ternary) operator",
          "url": "/docs/mdn/ternary.html",
          "description": "A shorthand for if/else"
        },
        {
          "label": "MDN: Math.max()",
          "url": "/docs/mdn/math-max.html",
          "description": "Returns the largest of given numbers"
        }
      ]
    },
    {
      "id": 733,
      "title": "First Letter Upper",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "charAt",
        "toUpperCase",
        "slice"
      ],
      "description": "Extract the first character of a string and return it uppercase.",
      "instructions": "Write a function called `firstUpper` that takes a string and returns its first character in uppercase.\n\nExample:\n  firstUpper(\"hello\")  →  \"H\"\n  firstUpper(\"world\")  →  \"W\"\n  firstUpper(\"javaScript\")  →  \"J\"",
      "starterCode": "function firstUpper(str) {\n  // Get the first character and make it uppercase\n\n}",
      "solution": "function firstUpper(str) {\n  return str[0].toUpperCase();\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return firstUpper;')(); return [ { pass: fn(\"hello\") === \"H\", description: 'firstUpper(\"hello\") → \"H\"', got: fn(\"hello\") }, { pass: fn(\"world\") === \"W\", description: 'firstUpper(\"world\") → \"W\"', got: fn(\"world\") }, { pass: fn(\"javaScript\") === \"J\", description: 'firstUpper(\"javaScript\") → \"J\"', got: fn(\"javaScript\") }, { pass: fn(\"a\") === \"A\", description: 'firstUpper(\"a\") → \"A\"', got: fn(\"a\") } ]; }",
      "hints": [
        "Access the first character with str[0] or str.charAt(0).",
        "Then call .toUpperCase() on that character.",
        "return str[0].toUpperCase();"
      ],
      "resources": [
        {
          "label": "MDN: String.toUpperCase()",
          "url": "/docs/mdn/string-touppercase.html",
          "description": "Converting characters to uppercase"
        },
        {
          "label": "MDN: String methods",
          "url": "/docs/mdn/string-methods.html",
          "description": "Common methods for working with strings"
        }
      ]
    },
    {
      "id": 734,
      "title": "Last Element",
      "type": "js",
      "tier": 1,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "array",
        "index",
        "length"
      ],
      "description": "Return the last element of any array using its length.",
      "instructions": "Write a function called `lastElement` that takes an array and returns the last item.\n\nUse `arr.length - 1` to find the index of the last element.\n\nExample:\n  lastElement([1, 2, 3])       →  3\n  lastElement([\"a\", \"b\"])      →  \"b\"\n  lastElement([true])          →  true",
      "starterCode": "function lastElement(arr) {\n  // Return the last element using arr.length\n\n}",
      "solution": "function lastElement(arr) {\n  return arr[arr.length - 1];\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return lastElement;')(); return [ { pass: fn([1, 2, 3]) === 3, description: 'lastElement([1, 2, 3]) → 3', got: fn([1, 2, 3]) }, { pass: fn([\"a\", \"b\"]) === \"b\", description: 'lastElement([\"a\", \"b\"]) → \"b\"', got: fn([\"a\", \"b\"]) }, { pass: fn([true]) === true, description: 'lastElement([true]) → true', got: fn([true]) }, { pass: fn([10, 20, 30, 40]) === 40, description: 'lastElement([10, 20, 30, 40]) → 40', got: fn([10, 20, 30, 40]) } ]; }",
      "hints": [
        "The last index of an array is always arr.length - 1.",
        "For [1, 2, 3]: length is 3, so the last index is 2.",
        "return arr[arr.length - 1];"
      ],
      "resources": [
        {
          "label": "MDN: Array.length",
          "url": "/docs/mdn/array-length.html",
          "description": "Getting the number of elements in an array"
        },
        {
          "label": "MDN: Arrays",
          "url": "/docs/mdn/arrays.html",
          "description": "Creating and working with arrays"
        }
      ]
    },
    {
      "id": 735,
      "title": "Format Price",
      "type": "js",
      "tier": 1,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literal",
        "toFixed",
        "formatting"
      ],
      "description": "Use template literals and toFixed to format a price string.",
      "instructions": "Write a function called `formatPrice` that takes a number and returns it formatted as a dollar amount.\n\nUse `.toFixed(2)` to ensure exactly 2 decimal places, and a template literal to add the `$` sign.\n\nExample:\n  formatPrice(9.99)   →  \"$9.99\"\n  formatPrice(5)      →  \"$5.00\"\n  formatPrice(12.5)   →  \"$12.50\"",
      "starterCode": "function formatPrice(amount) {\n  // Return the amount formatted as \"$X.XX\"\n\n}",
      "solution": "function formatPrice(amount) {\n  return `$${amount.toFixed(2)}`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return formatPrice;')(); return [ { pass: fn(9.99) === \"$9.99\", description: 'formatPrice(9.99) → \"$9.99\"', got: fn(9.99) }, { pass: fn(5) === \"$5.00\", description: 'formatPrice(5) → \"$5.00\"', got: fn(5) }, { pass: fn(12.5) === \"$12.50\", description: 'formatPrice(12.5) → \"$12.50\"', got: fn(12.5) }, { pass: fn(0) === \"$0.00\", description: 'formatPrice(0) → \"$0.00\"', got: fn(0) } ]; }",
      "hints": [
        ".toFixed(2) returns a string with exactly 2 decimal places: (5).toFixed(2) → \"5.00\"",
        "Use a template literal: `$${amount.toFixed(2)}`",
        "return `$${amount.toFixed(2)}`;"
      ],
      "resources": [
        {
          "label": "MDN: Number.toFixed()",
          "url": "/docs/mdn/number-tofixed.html",
          "description": "Formatting numbers with fixed decimal places"
        },
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        }
      ]
    },
    {
      "id": 736,
      "title": "Negate It",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "not",
        "boolean",
        "logical-operator"
      ],
      "description": "Use the NOT operator (!) to flip boolean values.",
      "instructions": "Write a function called `negate` that takes a boolean value and returns the opposite.\n\nUse the `!` (NOT) operator.\n\nExample:\n  negate(true)   →  false\n  negate(false)  →  true",
      "starterCode": "function negate(value) {\n  // Return the opposite boolean\n\n}",
      "solution": "function negate(value) {\n  return !value;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return negate;')(); return [ { pass: fn(true) === false, description: 'negate(true) → false', got: fn(true) }, { pass: fn(false) === true, description: 'negate(false) → true', got: fn(false) } ]; }",
      "hints": [
        "The ! operator flips a boolean: !true becomes false, !false becomes true.",
        "Just return the negated value: return !value;",
        "return !value;"
      ],
      "resources": [
        {
          "label": "MDN: Logical NOT (!)",
          "url": "/docs/mdn/logical-not.html",
          "description": "Negating a boolean value"
        },
        {
          "label": "MDN: Boolean",
          "url": "/docs/mdn/boolean.html",
          "description": "True and false values in JavaScript"
        }
      ]
    },
    {
      "id": 737,
      "title": "Counting Loop",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "for-loop",
        "accumulator",
        "basics"
      ],
      "description": "Use a for loop to build a string by counting from 1 to a given number.",
      "instructions": "Write a function called `countUp` that takes a number `n` and returns a string of numbers from 1 to n, separated by spaces.\n\nUse a `for` loop to build the string.\n\nExample:\n  countUp(5)  →  \"1 2 3 4 5\"\n  countUp(3)  →  \"1 2 3\"\n  countUp(1)  →  \"1\"",
      "starterCode": "function countUp(n) {\n  let result = \"\";\n  // Use a for loop to add each number to result\n  for (___) {\n    ___;\n  }\n  return result.trim();\n}",
      "solution": "function countUp(n) {\n  let result = \"\";\n  for (let i = 1; i <= n; i++) {\n    result += i + \" \";\n  }\n  return result.trim();\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countUp;')(); return [ { pass: fn(5) === \"1 2 3 4 5\", description: 'countUp(5) → \"1 2 3 4 5\"', got: fn(5) }, { pass: fn(3) === \"1 2 3\", description: 'countUp(3) → \"1 2 3\"', got: fn(3) }, { pass: fn(1) === \"1\", description: 'countUp(1) → \"1\"', got: fn(1) }, { pass: fn(8) === \"1 2 3 4 5 6 7 8\", description: 'countUp(8) → \"1 2 3 4 5 6 7 8\"', got: fn(8) } ]; }",
      "hints": [
        "A for loop: for (let i = 1; i <= n; i++) { ... }",
        "Append each number to result: result += i + \" \";",
        "for (let i = 1; i <= n; i++) { result += i + \" \"; }"
      ],
      "resources": [
        {
          "label": "MDN: Loops and iteration",
          "url": "/docs/mdn/loops.html",
          "description": "Repeating code with for, while, and more"
        },
        {
          "label": "MDN: for statement",
          "url": "/docs/mdn/for-loop.html",
          "description": "Iterating through arrays with for"
        }
      ]
    },
    {
      "id": 741,
      "title": "Initials",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "strings"
      ],
      "tags": [
        "split",
        "map",
        "string-methods"
      ],
      "description": "Extract the initials from a full name string.",
      "instructions": "Write a function called `initials` that takes a full name and returns the initials with dots.\n\nSplit the name into words, take the first character of each, uppercase it, and join with dots.\n\nExample:\n  initials(\"John Doe\")           →  \"J.D.\"\n  initials(\"Mary Jane Watson\")   →  \"M.J.W.\"\n  initials(\"Cher\")               →  \"C.\"",
      "starterCode": "function initials(name) {\n\n}",
      "solution": "function initials(name) {\n  return name.split(\" \").map(w => w[0].toUpperCase()).join(\".\") + \".\";\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return initials;')(); return [ { pass: fn(\"John Doe\") === \"J.D.\", description: 'initials(\"John Doe\") → \"J.D.\"', got: fn(\"John Doe\") }, { pass: fn(\"Mary Jane Watson\") === \"M.J.W.\", description: 'initials(\"Mary Jane Watson\") → \"M.J.W.\"', got: fn(\"Mary Jane Watson\") }, { pass: fn(\"Cher\") === \"C.\", description: 'initials(\"Cher\") → \"C.\"', got: fn(\"Cher\") }, { pass: fn(\"lebron james\") === \"L.J.\", description: 'initials(\"lebron james\") → \"L.J.\"', got: fn(\"lebron james\") } ]; }",
      "hints": [
        "Split the name into words with .split(\" \"), then get the first character of each.",
        "Use .map(word => word[0].toUpperCase()) to get uppercase initials.",
        "Join with \".\" and add a final \".\": .join(\".\") + \".\""
      ],
      "resources": [
        {
          "label": "MDN: String.split()",
          "url": "/docs/mdn/string-split.html",
          "description": "Breaking a string into an array"
        },
        {
          "label": "MDN: Array.map()",
          "url": "/docs/mdn/array-map.html",
          "description": "Transforming every element in an array"
        }
      ]
    },
    {
      "id": 742,
      "title": "Count Properties",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "Object.keys",
        "length",
        "objects"
      ],
      "description": "Count the number of properties in an object using Object.keys.",
      "instructions": "Write a function called `countKeys` that takes an object and returns how many properties it has.\n\nUse `Object.keys(obj)` to get an array of all property names, then check its `.length`.\n\nExample:\n  countKeys({ a: 1, b: 2, c: 3 })  →  3\n  countKeys({ name: \"Jo\" })          →  1\n  countKeys({})                      →  0",
      "starterCode": "function countKeys(obj) {\n\n}",
      "solution": "function countKeys(obj) {\n  return Object.keys(obj).length;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return countKeys;')(); return [ { pass: fn({ a: 1, b: 2, c: 3 }) === 3, description: 'countKeys({ a: 1, b: 2, c: 3 }) → 3', got: fn({ a: 1, b: 2, c: 3 }) }, { pass: fn({ name: \"Jo\" }) === 1, description: 'countKeys({ name: \"Jo\" }) → 1', got: fn({ name: \"Jo\" }) }, { pass: fn({}) === 0, description: 'countKeys({}) → 0', got: fn({}) }, { pass: fn({ x: 1, y: 2, z: 3, w: 4 }) === 4, description: 'countKeys({ x, y, z, w }) → 4', got: fn({ x: 1, y: 2, z: 3, w: 4 }) } ]; }",
      "hints": [
        "Object.keys(obj) returns an array of property names: Object.keys({a:1, b:2}) → [\"a\", \"b\"]",
        "Then just check the length of that array.",
        "return Object.keys(obj).length;"
      ],
      "resources": [
        {
          "label": "MDN: Object.keys()",
          "url": "/docs/mdn/object-keys.html",
          "description": "Getting all keys of an object"
        },
        {
          "label": "MDN: Working with objects",
          "url": "/docs/mdn/objects.html",
          "description": "Creating and accessing object properties"
        }
      ]
    },
    {
      "id": 743,
      "title": "Without Extremes",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "slice",
        "array-methods"
      ],
      "description": "Return an array with the first and last elements removed.",
      "instructions": "Write a function called `withoutExtremes` that takes an array and returns a new array without the first and last elements.\n\nUse `.slice()` to extract the middle portion.\n\nExample:\n  withoutExtremes([1, 2, 3, 4, 5])  →  [2, 3, 4]\n  withoutExtremes([\"a\", \"b\", \"c\"])   →  [\"b\"]\n  withoutExtremes([1, 2])            →  []",
      "starterCode": "function withoutExtremes(arr) {\n\n}",
      "solution": "function withoutExtremes(arr) {\n  return arr.slice(1, -1);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return withoutExtremes;')(); return [ { pass: JSON.stringify(fn([1,2,3,4,5])) === \"[2,3,4]\", description: 'withoutExtremes([1,2,3,4,5]) → [2,3,4]', got: JSON.stringify(fn([1,2,3,4,5])) }, { pass: JSON.stringify(fn([\"a\",\"b\",\"c\"])) === '[\"b\"]', description: 'withoutExtremes([\"a\",\"b\",\"c\"]) → [\"b\"]', got: JSON.stringify(fn([\"a\",\"b\",\"c\"])) }, { pass: JSON.stringify(fn([1,2])) === \"[]\", description: 'withoutExtremes([1,2]) → []', got: JSON.stringify(fn([1,2])) }, { pass: JSON.stringify(fn([10,20,30,40])) === \"[20,30]\", description: 'withoutExtremes([10,20,30,40]) → [20,30]', got: JSON.stringify(fn([10,20,30,40])) } ]; }",
      "hints": [
        ".slice(start, end) returns a portion of the array without modifying the original.",
        ".slice(1, -1) starts at index 1 and stops one before the end.",
        "return arr.slice(1, -1);"
      ],
      "resources": [
        {
          "label": "MDN: Array.slice()",
          "url": "/docs/mdn/array-slice.html",
          "description": "Extracting a portion of an array"
        },
        {
          "label": "MDN: Arrays",
          "url": "/docs/mdn/arrays.html",
          "description": "Creating and working with arrays"
        }
      ]
    },
    {
      "id": 744,
      "title": "Has Property",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "objects"
      ],
      "tags": [
        "hasOwnProperty",
        "in",
        "objects"
      ],
      "description": "Check if an object contains a specific property.",
      "instructions": "Write a function called `hasProp` that takes an object and a key (string), and returns `true` if the object has that property, or `false` if it does not.\n\nExample:\n  hasProp({ name: \"Jo\", age: 25 }, \"name\")   →  true\n  hasProp({ name: \"Jo\", age: 25 }, \"email\")  →  false\n  hasProp({}, \"anything\")                    →  false",
      "starterCode": "function hasProp(obj, key) {\n\n}",
      "solution": "function hasProp(obj, key) {\n  return key in obj;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return hasProp;')(); return [ { pass: fn({ name: \"Jo\", age: 25 }, \"name\") === true, description: 'hasProp({name, age}, \"name\") → true', got: fn({ name: \"Jo\", age: 25 }, \"name\") }, { pass: fn({ name: \"Jo\", age: 25 }, \"email\") === false, description: 'hasProp({name, age}, \"email\") → false', got: fn({ name: \"Jo\", age: 25 }, \"email\") }, { pass: fn({}, \"anything\") === false, description: 'hasProp({}, \"anything\") → false', got: fn({}, \"anything\") }, { pass: fn({ x: 0 }, \"x\") === true, description: 'hasProp({ x: 0 }, \"x\") → true (even falsy values)', got: fn({ x: 0 }, \"x\") } ]; }",
      "hints": [
        "Use the 'in' operator: \"name\" in obj returns true if the property exists.",
        "You can also use obj.hasOwnProperty(key).",
        "return key in obj;"
      ],
      "resources": [
        {
          "label": "MDN: in operator",
          "url": "/docs/mdn/in-operator.html",
          "description": "Checking if a property exists in an object"
        },
        {
          "label": "MDN: Working with objects",
          "url": "/docs/mdn/objects.html",
          "description": "Creating and accessing object properties"
        }
      ]
    },
    {
      "id": 746,
      "title": "Spread Merge",
      "type": "js",
      "tier": 1,
      "category": [
        "es6-plus",
        "destructuring"
      ],
      "tags": [
        "spread",
        "array",
        "merge"
      ],
      "description": "Use the spread operator to combine two arrays into one.",
      "instructions": "Given two arrays `front` and `back`, create a new array called `combined` that contains all elements from both arrays using the spread operator (`...`).\n\nThe spread operator expands an array into individual elements:\n```\nconst merged = [...arrayA, ...arrayB];\n```\n\nExample: if front is `[1, 2]` and back is `[3, 4]`, then combined should be `[1, 2, 3, 4]`.",
      "starterCode": "const front = [1, 2, 3];\nconst back = [4, 5, 6];\n\n// Combine both arrays using the spread operator\nconst combined = ___;",
      "solution": "const front = [1, 2, 3];\nconst back = [4, 5, 6];\n\nconst combined = [...front, ...back];",
      "testRunner": "(code) => { const v = new Function(code + '; return { combined };')(); return [ { pass: JSON.stringify(v.combined) === '[1,2,3,4,5,6]', description: 'combined should be [1, 2, 3, 4, 5, 6]', got: JSON.stringify(v.combined) }, { pass: v.combined.length === 6, description: 'combined should have 6 elements', got: v.combined.length } ]; }",
      "hints": [
        "The spread operator ... expands an array: [...arr] makes a copy of arr.",
        "To merge: [...front, ...back] puts all elements of front followed by all of back.",
        "const combined = [...front, ...back];"
      ],
      "resources": [
        {
          "label": "MDN: Spread syntax",
          "url": "/docs/mdn/spread-syntax.html",
          "description": "Expanding arrays and objects with ..."
        },
        {
          "label": "MDN: Destructuring assignment",
          "url": "/docs/mdn/destructuring.html",
          "description": "Unpacking values from arrays and objects"
        }
      ]
    },
    {
      "id": 747,
      "title": "Short-Circuit Defaults",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "operators"
      ],
      "tags": [
        "logical-or",
        "default-values",
        "short-circuit"
      ],
      "description": "Use the || operator to provide default values for falsy variables.",
      "instructions": "The `||` (OR) operator returns the first truthy value it finds. This is useful for providing defaults:\n\n```\nconst name = \"\" || \"Anonymous\";  // \"Anonymous\" (because \"\" is falsy)\nconst count = 0 || 10;           // 10 (because 0 is falsy)\nconst title = \"Hello\" || \"Default\"; // \"Hello\" (already truthy)\n```\n\nEvaluate each expression and store the result:\n\n- `a` — `null || \"fallback\"`\n- `b` — `\"keep me\" || \"replaced\"`\n- `c` — `0 || 42`\n- `d` — `undefined || \"safe\"`",
      "starterCode": "const a = null || \"fallback\";\nconst b = \"keep me\" || \"replaced\";\nconst c = 0 || 42;\nconst d = undefined || \"safe\";",
      "solution": "const a = null || \"fallback\";\nconst b = \"keep me\" || \"replaced\";\nconst c = 0 || 42;\nconst d = undefined || \"safe\";",
      "testRunner": "(code) => { const v = new Function(code + '; return { a, b, c, d };')(); return [ { pass: v.a === 'fallback', description: 'null || \"fallback\" should be \"fallback\"', got: v.a }, { pass: v.b === 'keep me', description: '\"keep me\" || \"replaced\" should be \"keep me\"', got: v.b }, { pass: v.c === 42, description: '0 || 42 should be 42', got: v.c }, { pass: v.d === 'safe', description: 'undefined || \"safe\" should be \"safe\"', got: v.d } ]; }",
      "hints": [
        "|| returns the first truthy value. Falsy values are: false, 0, \"\", null, undefined, NaN.",
        "null is falsy, so null || \"fallback\" returns \"fallback\". \"keep me\" is truthy, so it's returned immediately.",
        "const a = \"fallback\"; const b = \"keep me\"; const c = 42; const d = \"safe\";"
      ],
      "resources": [
        {
          "label": "MDN: Logical OR (||)",
          "url": "/docs/mdn/logical-or.html",
          "description": "Alternative conditions and default values"
        },
        {
          "label": "MDN: Nullish coalescing (??)",
          "url": "/docs/mdn/nullish-coalescing.html",
          "description": "Providing defaults only for null/undefined"
        }
      ]
    },
    {
      "id": 748,
      "title": "Loop and Filter",
      "type": "js",
      "tier": 1,
      "category": [
        "js-fundamentals",
        "loops"
      ],
      "tags": [
        "for-loop",
        "if",
        "push",
        "filter"
      ],
      "description": "Use a for loop with an if statement to collect matching items.",
      "instructions": "Write a function called `positives` that takes an array of numbers and returns a new array containing only the positive numbers (greater than 0).\n\nUse a `for` loop and an `if` statement to check each number, then `.push()` the positive ones into a result array.\n\nExample:\n  positives([3, -1, 4, -5, 0, 2])  →  [3, 4, 2]\n  positives([-1, -2, -3])            →  []\n  positives([1, 2, 3])               →  [1, 2, 3]",
      "starterCode": "function positives(nums) {\n  const result = [];\n  // Loop through nums and push positive numbers to result\n  for (___) {\n    if (___) {\n      ___;\n    }\n  }\n  return result;\n}",
      "solution": "function positives(nums) {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      result.push(nums[i]);\n    }\n  }\n  return result;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return positives;')(); return [ { pass: JSON.stringify(fn([3,-1,4,-5,0,2])) === '[3,4,2]', description: 'positives([3,-1,4,-5,0,2]) → [3,4,2]', got: JSON.stringify(fn([3,-1,4,-5,0,2])) }, { pass: JSON.stringify(fn([-1,-2,-3])) === '[]', description: 'positives([-1,-2,-3]) → []', got: JSON.stringify(fn([-1,-2,-3])) }, { pass: JSON.stringify(fn([1,2,3])) === '[1,2,3]', description: 'positives([1,2,3]) → [1,2,3]', got: JSON.stringify(fn([1,2,3])) }, { pass: JSON.stringify(fn([])) === '[]', description: 'positives([]) → []', got: JSON.stringify(fn([])) } ]; }",
      "hints": [
        "Loop with: for (let i = 0; i < nums.length; i++)",
        "Check if positive: if (nums[i] > 0) { result.push(nums[i]); }",
        "for (let i = 0; i < nums.length; i++) { if (nums[i] > 0) { result.push(nums[i]); } }"
      ],
      "resources": [
        {
          "label": "MDN: Loops and iteration",
          "url": "/docs/mdn/loops.html",
          "description": "Repeating code with for, while, and more"
        },
        {
          "label": "MDN: Array.push()",
          "url": "/docs/mdn/array-push.html",
          "description": "Adding elements to the end of an array"
        }
      ]
    },
    {
      "id": 751,
      "title": "Apply Callback",
      "type": "js",
      "tier": 2,
      "category": [
        "functions",
        "callbacks"
      ],
      "tags": [
        "callback",
        "function-argument",
        "basics"
      ],
      "description": "Take a value and a callback function, and return the result of calling the callback with the value.",
      "instructions": "Write a function called `applyTo` that takes a `value` and a `callback` function. It should call the callback with the value and return the result.\n\nThis is the simplest form of a callback — passing a function as an argument.\n\nExample:\n  applyTo(5, x => x * 2)          →  10\n  applyTo(\"hello\", s => s.length)  →  5\n  applyTo(3, x => x * x)          →  9\n  applyTo(true, x => !x)          →  false",
      "starterCode": "function applyTo(value, callback) {\n\n}",
      "solution": "function applyTo(value, callback) {\n  return callback(value);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return applyTo;')(); return [ { pass: fn(5, x => x * 2) === 10, description: 'applyTo(5, x => x * 2) → 10', got: fn(5, x => x * 2) }, { pass: fn('hello', s => s.length) === 5, description: 'applyTo(\"hello\", s => s.length) → 5', got: fn('hello', s => s.length) }, { pass: fn(3, x => x * x) === 9, description: 'applyTo(3, x => x * x) → 9', got: fn(3, x => x * x) }, { pass: fn(true, x => !x) === false, description: 'applyTo(true, x => !x) → false', got: fn(true, x => !x) } ]; }",
      "hints": [
        "A callback is just a function passed as an argument. You call it like any function.",
        "return callback(value); — call the callback with value as its argument.",
        "return callback(value);"
      ],
      "resources": [
        {
          "label": "MDN: Callback function",
          "url": "/docs/mdn/callbacks.html",
          "description": "Passing functions as arguments"
        },
        {
          "label": "MDN: Arrow functions",
          "url": "/docs/mdn/arrow-functions.html",
          "description": "Compact function syntax for callbacks"
        }
      ]
    },
    {
      "id": 753,
      "title": "Keep Evens",
      "type": "js",
      "tier": 2,
      "category": [
        "functions",
        "higher-order"
      ],
      "tags": [
        "filter",
        "callback",
        "even"
      ],
      "description": "Use .filter() with a callback to keep only even numbers.",
      "instructions": "Write a function called `keepEvens` that takes an array of numbers and returns a new array containing only the even numbers.\n\nUse the `.filter()` method with a callback that checks if a number is even.\n\nExample:\n  keepEvens([1, 2, 3, 4, 5, 6])  →  [2, 4, 6]\n  keepEvens([1, 3, 5])            →  []\n  keepEvens([2, 4, 8])            →  [2, 4, 8]\n  keepEvens([])                   →  []",
      "starterCode": "function keepEvens(nums) {\n\n}",
      "solution": "function keepEvens(nums) {\n  return nums.filter(n => n % 2 === 0);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return keepEvens;')(); return [ { pass: JSON.stringify(fn([1,2,3,4,5,6])) === '[2,4,6]', description: 'keepEvens([1,2,3,4,5,6]) → [2,4,6]', got: JSON.stringify(fn([1,2,3,4,5,6])) }, { pass: JSON.stringify(fn([1,3,5])) === '[]', description: 'keepEvens([1,3,5]) → []', got: JSON.stringify(fn([1,3,5])) }, { pass: JSON.stringify(fn([2,4,8])) === '[2,4,8]', description: 'keepEvens([2,4,8]) → [2,4,8]', got: JSON.stringify(fn([2,4,8])) }, { pass: JSON.stringify(fn([])) === '[]', description: 'keepEvens([]) → []', got: JSON.stringify(fn([])) } ]; }",
      "hints": [
        ".filter() keeps only elements where the callback returns true.",
        "A number is even when n % 2 === 0.",
        "return nums.filter(n => n % 2 === 0);"
      ],
      "resources": [
        {
          "label": "MDN: Array.filter()",
          "url": "/docs/mdn/array-filter.html",
          "description": "Creating a subset of an array based on a condition"
        },
        {
          "label": "MDN: Remainder (%)",
          "url": "/docs/mdn/remainder.html",
          "description": "The modulo operator for extracting remainders"
        }
      ]
    },
    {
      "id": 755,
      "title": "Wrap in Tag",
      "type": "js",
      "tier": 2,
      "category": [
        "es6-plus",
        "template-literals"
      ],
      "tags": [
        "template-literal",
        "html",
        "formatting"
      ],
      "description": "Use template literals to wrap text inside an HTML tag string.",
      "instructions": "Write a function called `wrapTag` that takes a `text` string and a `tag` string, and returns the text wrapped in that HTML tag.\n\nExample:\n  wrapTag(\"Hello\", \"h1\")    →  \"<h1>Hello</h1>\"\n  wrapTag(\"Click me\", \"button\")  →  \"<button>Click me</button>\"\n  wrapTag(\"Paragraph\", \"p\")  →  \"<p>Paragraph</p>\"",
      "starterCode": "function wrapTag(text, tag) {\n\n}",
      "solution": "function wrapTag(text, tag) {\n  return `<${tag}>${text}</${tag}>`;\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return wrapTag;')(); return [ { pass: fn('Hello', 'h1') === '<h1>Hello</h1>', description: 'wrapTag(\"Hello\", \"h1\") → \"<h1>Hello</h1>\"', got: fn('Hello', 'h1') }, { pass: fn('Click me', 'button') === '<button>Click me</button>', description: 'wrapTag(\"Click me\", \"button\") → \"<button>Click me</button>\"', got: fn('Click me', 'button') }, { pass: fn('Paragraph', 'p') === '<p>Paragraph</p>', description: 'wrapTag(\"Paragraph\", \"p\") → \"<p>Paragraph</p>\"', got: fn('Paragraph', 'p') }, { pass: fn('Item', 'li') === '<li>Item</li>', description: 'wrapTag(\"Item\", \"li\") → \"<li>Item</li>\"', got: fn('Item', 'li') } ]; }",
      "hints": [
        "Use a template literal with the tag variable: `<${tag}>...`",
        "The closing tag needs a /: `</${tag}>`",
        "return `<${tag}>${text}</${tag}>`;"
      ],
      "resources": [
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        },
        {
          "label": "MDN: Template literals",
          "url": "/docs/mdn/template-literals.html",
          "description": "String interpolation with backticks"
        }
      ]
    },
    {
      "id": 757,
      "title": "Every Other",
      "type": "js",
      "tier": 2,
      "category": [
        "data-structures",
        "arrays"
      ],
      "tags": [
        "loop",
        "filter",
        "index"
      ],
      "description": "Return every other element from an array (even indexes).",
      "instructions": "Write a function called `everyOther` that takes an array and returns a new array containing only the elements at even indexes (0, 2, 4, ...).\n\nExample:\n  everyOther([\"a\", \"b\", \"c\", \"d\", \"e\"])  →  [\"a\", \"c\", \"e\"]\n  everyOther([1, 2, 3, 4])                  →  [1, 3]\n  everyOther([10])                          →  [10]\n  everyOther([])                            →  []",
      "starterCode": "function everyOther(arr) {\n\n}",
      "solution": "function everyOther(arr) {\n  return arr.filter((_, i) => i % 2 === 0);\n}",
      "testRunner": "(code) => { const fn = new Function(code + '; return everyOther;')(); return [ { pass: JSON.stringify(fn(['a','b','c','d','e'])) === '[\"a\",\"c\",\"e\"]', description: 'everyOther([\"a\",\"b\",\"c\",\"d\",\"e\"]) → [\"a\",\"c\",\"e\"]', got: JSON.stringify(fn(['a','b','c','d','e'])) }, { pass: JSON.stringify(fn([1,2,3,4])) === '[1,3]', description: 'everyOther([1,2,3,4]) → [1,3]', got: JSON.stringify(fn([1,2,3,4])) }, { pass: JSON.stringify(fn([10])) === '[10]', description: 'everyOther([10]) → [10]', got: JSON.stringify(fn([10])) }, { pass: JSON.stringify(fn([])) === '[]', description: 'everyOther([]) → []', got: JSON.stringify(fn([])) } ]; }",
      "hints": [
        "Even indexes are 0, 2, 4... You can check with i % 2 === 0.",
        "Use .filter() with the index parameter: arr.filter((element, index) => ...)",
        "return arr.filter((_, i) => i % 2 === 0);"
      ],
      "resources": [
        {
          "label": "MDN: Array.filter()",
          "url": "/docs/mdn/array-filter.html",
          "description": "Creating a subset of an array based on a condition"
        },
        {
          "label": "MDN: Array.filter()",
          "url": "/docs/mdn/array-filter.html",
          "description": "Creating a subset of an array based on a condition"
        }
      ]
    }
  ]
}